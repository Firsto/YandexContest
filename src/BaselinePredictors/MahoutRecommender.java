package BaselinePredictors;

import BaselinePredictors.MahoutRecommender.Maps.EntryTransformer;
import com.sun.istack.internal.Nullable;

import java.io.*;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.math.BigInteger;
import java.net.URL;
import java.net.URLClassLoader;
import java.net.URLConnection;
import java.nio.charset.Charset;
import java.security.SecureRandom;
import java.text.MessageFormat;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReferenceArray;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.regex.Pattern;

import static BaselinePredictors.MahoutRecommender.CustomConcurrentHashMap.Strength;
import static BaselinePredictors.MahoutRecommender.ImmutableSet.ArrayImmutableSet;
import static BaselinePredictors.MahoutRecommender.MapMaker.Cache;
import static BaselinePredictors.MahoutRecommender.Multisets.setCountImpl;
import static BaselinePredictors.MahoutRecommender.Objects.firstNonNull;
import static BaselinePredictors.MahoutRecommender.Preconditions.*;

//import BaselinePredictors.MahoutRecommender.Multiset.Entry;

//import java.util.Map.Entry;

//import org.apache.mahout.cf.taste.impl.model.file.*;
//import org.apache.mahout.cf.taste.impl.recommender.*;
//import org.apache.mahout.cf.taste.impl.similarity.*;
//import org.apache.mahout.cf.taste.model.*;
//import org.apache.mahout.cf.taste.neighborhood.*;
//import org.apache.mahout.cf.taste.recommender.*;
//import org.apache.mahout.cf.taste.similarity.*;


/**
 * Created with IntelliJ IDEA.
 * User: Razor
 * Date: 14.12.13
 * Time: 23:52
 */
public class MahoutRecommender {
    /*
    public static void main(String[] args) throws Exception {
        // Create a data source from the CSV file
        File userPreferencesFile = new File("data/dataset1.csv");
        DataModel dataModel = new FileDataModel(userPreferencesFile);

        UserSimilarity userSimilarity = new PearsonCorrelationSimilarity(dataModel);
        UserNeighborhood userNeighborhood = new NearestNUserNeighborhood(2, userSimilarity, dataModel);

        // Create a generic user based recommender with the dataModel, the userNeighborhood and the userSimilarity
        Recommender genericRecommender =  new GenericUserBasedRecommender(dataModel, userNeighborhood, userSimilarity);

        // Generate a list of 3 recommended items for user 1001
        List<RecommendedItem> itemRecommendations = genericRecommender.recommend(1001, 3);

        // Display the item recommendations generated by the recommendation engine
        for (RecommendedItem recommendedItem : itemRecommendations) {
            System.out.println(recommendedItem);
        }
    }
*/

    public interface RecommendedItem {
        long getItemID();
        float getValue();
    }
    public interface IDRescorer {

        double rescore(long id, double originalScore);
        boolean isFiltered(long id);

    }
    public interface Recommender extends Refreshable {

        List<RecommendedItem> recommend(long userID, int howMany) throws TasteException;
        List<RecommendedItem> recommend(long userID, int howMany, IDRescorer rescorer) throws TasteException;

        float estimatePreference(long userID, long itemID) throws TasteException;

        void setPreference(long userID, long itemID, float value) throws TasteException;

        void removePreference(long userID, long itemID) throws TasteException;

        DataModel getDataModel();

    }

    public interface Refreshable {
        void refresh(Collection<Refreshable> alreadyRefreshed);
    }

    public class TasteException extends Exception {

        public TasteException() { }

        public TasteException(String message) {
            super(message);
        }

        public TasteException(Throwable cause) {
            super(cause);
        }

        public TasteException(String message, Throwable cause) {
            super(message, cause);
        }

    }
    public final static class Preconditions {
        private Preconditions() {}

        public static void checkArgument(boolean expression) {
            if (!expression) {
                throw new IllegalArgumentException();
            }
        }

        public static void checkArgument(boolean expression, Object errorMessage) {
            if (!expression) {
                throw new IllegalArgumentException(String.valueOf(errorMessage));
            }
        }

        public static void checkArgument(boolean expression,
                                         String errorMessageFormat, Object... errorMessageArgs) {
            if (!expression) {
                throw new IllegalArgumentException(
                        String.format(errorMessageFormat, errorMessageArgs));
            }
        }

        public static void checkState(boolean expression) {
            if (!expression) {
                throw new IllegalStateException();
            }
        }

        public static void checkState(boolean expression, Object errorMessage) {
            if (!expression) {
                throw new IllegalStateException(String.valueOf(errorMessage));
            }
        }

        public static void checkState(boolean expression,
                                      String errorMessageFormat, Object... errorMessageArgs) {
            if (!expression) {
                throw new IllegalStateException(
                        String.format(errorMessageFormat, errorMessageArgs));
            }
        }


        public static <T> T checkNotNull(T reference) {
            if (reference == null) {
                throw new NullPointerException();
            }
            return reference;
        }


        public static <T> T checkNotNull(T reference, Object errorMessage) {
            if (reference == null) {
                throw new NullPointerException(String.valueOf(errorMessage));
            }
            return reference;
        }

        public static <T> T checkNotNull(T reference, String errorMessageFormat,
                                         Object... errorMessageArgs) {
            if (reference == null) {
                // If either of these parameters is null, the right thing happens anyway
                throw new NullPointerException(
                        String.format(errorMessageFormat, errorMessageArgs));
            }
            return reference;
        }

        public static int checkElementIndex(int index, int size) {
            return checkElementIndex(index, size, "index");
        }

        public static int checkElementIndex(
                int index, int size, String desc) {
            // Carefully optimized for execution by hotspot (explanatory comment above)
            if (index < 0 || index >= size) {
                throw new IndexOutOfBoundsException(badElementIndex(index, size, desc));
            }
            return index;
        }
        private static String badElementIndex(int index, int size, String desc) {
            if (index < 0) {
                return String.format("%s (%s) must not be negative", desc, index);
            } else if (size < 0) {
                throw new IllegalArgumentException("negative size: " + size);
            } else { // index >= size
                return String.format("%s (%s) must be less than size (%s)", desc, index, size);
            }
        }
        public static void checkPositionIndexes(int start, int end, int size) {
            // Carefully optimized for execution by hotspot (explanatory comment above)
            if (start < 0 || end < start || end > size) {
                throw new IndexOutOfBoundsException(badPositionIndexes(start, end, size));
            }
        }

        public static int checkPositionIndex(int index, int size) {
            return checkPositionIndex(index, size, "index");
        }

        public static int checkPositionIndex(
                int index, int size, String desc) {
            // Carefully optimized for execution by hotspot (explanatory comment above)
            if (index < 0 || index > size) {
                throw new IndexOutOfBoundsException(badPositionIndex(index, size, desc));
            }
            return index;
        }

        private static String badPositionIndex(int index, int size, String desc) {
            if (index < 0) {
                return String.format("%s (%s) must not be negative", desc, index);
            } else if (size < 0) {
                throw new IllegalArgumentException("negative size: " + size);
            } else { // index > size
                return String.format("%s (%s) must not be greater than size (%s)",
                        desc, index, size);
            }
        }
        private static String badPositionIndexes(int start, int end, int size) {
            if (start < 0 || start > size) {
                return badPositionIndex(start, size, "start index");
            }
            if (end < 0 || end > size) {
                return badPositionIndex(end, size, "end index");
            }
            // end < start
            return String.format("end index (%s) must not be less than start index (%s)",
                    end, start);
        }
        public static <T extends Iterable<?>> T checkContentsNotNull(T iterable) {
            // TODO: call Iterables.containsNull()
            for (Object element : iterable) {
                checkNotNull(element);
            }
            return iterable;
        }

        public static <T extends Iterable<?>> T checkContentsNotNull(
                T iterable, Object errorMessage) {
            checkNotNull(iterable, errorMessage);

            // TODO: call Iterables.containsNull()
            for (Object element : iterable) {
                checkNotNull(element, errorMessage);
            }
            return iterable;
        }

        public static <T extends Iterable<?>> T checkContentsNotNull(T iterable,
                                                                     String errorMessageFormat, Object... errorMessageArgs) {
            checkNotNull(iterable, errorMessageFormat, errorMessageArgs);

            // TODO: call Iterables.containsNull()
            for (Object element : iterable) {
                checkNotNull(element, errorMessageFormat, errorMessageArgs);
            }
            return iterable;
        }
    }

    public interface Preference {

        long getUserID();
        long getItemID();
        float getValue();
        void setValue(float value);

    }

    public interface PreferenceArray extends Cloneable, Serializable, Iterable<Preference> {

        int length();
        Preference get(int i);
        void set(int i, Preference pref);
        long getUserID(int i);
        void setUserID(int i, long userID);
        long getItemID(int i);
        void setItemID(int i, long itemID);
        long[] getIDs();
        float getValue(int i);
        void setValue(int i, float value);
        PreferenceArray clone();
        void sortByUser();
        void sortByItem();
        void sortByValue();
        void sortByValueReversed();
        boolean hasPrefWithUserID(long userID);
        boolean hasPrefWithItemID(long itemID);

    }

    public interface DataModel extends Refreshable, Serializable {

        LongPrimitiveIterator getUserIDs() throws TasteException;
        PreferenceArray getPreferencesFromUser(long userID) throws TasteException;
        FastIDSet getItemIDsFromUser(long userID) throws TasteException;
        LongPrimitiveIterator getItemIDs() throws TasteException;
        PreferenceArray getPreferencesForItem(long itemID) throws TasteException;
        Float getPreferenceValue(long userID, long itemID) throws TasteException;
        Long getPreferenceTime(long userID, long itemID) throws TasteException;
        int getNumItems() throws TasteException;
        int getNumUsers() throws TasteException;
        int getNumUsersWithPreferenceFor(long itemID) throws TasteException;
        int getNumUsersWithPreferenceFor(long itemID1, long itemID2) throws TasteException;
        void setPreference(long userID, long itemID, float value) throws TasteException;
        void removePreference(long userID, long itemID) throws TasteException;
        boolean hasPreferenceValues();
        float getMaxPreference();
        float getMinPreference();
    }

    public interface LongPrimitiveIterator extends SkippingIterator<Long> {

        long nextLong();
        long peek();
    }
    public abstract static class AbstractLongPrimitiveIterator implements LongPrimitiveIterator {

        @Override
        public Long next() {
            return nextLong();
        }

    }
    public interface SkippingIterator<V> extends Iterator<V> {

        void skip(int n);

    }
    public interface RepeatableRNG
    {
         byte[] getSeed();
    }
    public static final class BitString implements Cloneable, Serializable
    {
        private static final int WORD_LENGTH = 32;

        private final int length;

        private int[] data;


        public BitString(int length)
        {
            if (length < 0)
            {
                throw new IllegalArgumentException("Length must be non-negative.");
            }
            this.length = length;
            this.data = new int[(length + WORD_LENGTH - 1) / WORD_LENGTH];
        }



        public BitString(int length, Random rng)
        {
            this(length);
            // We can set bits 32 at a time rather than calling rng.nextBoolean()
            // and setting each one individually.
            for (int i = 0; i < data.length; i++)
            {
                data[i] = rng.nextInt();
            }
            // If the last word is not fully utilised, zero any out-of-bounds bits.
            // This is necessary because the countSetBits() methods will count
            // out-of-bounds bits.
            int bitsUsed = length % WORD_LENGTH;
            if (bitsUsed < WORD_LENGTH)
            {
                int unusedBits = WORD_LENGTH - bitsUsed;
                int mask = 0xFFFFFFFF >>> unusedBits;
                data[data.length - 1] &= mask;
            }
        }


        public BitString(String value)
        {
            this(value.length());
            for (int i = 0; i < value.length(); i++)
            {
                if (value.charAt(i) == '1')
                {
                    setBit(value.length() - (i + 1), true);
                }
                else if (value.charAt(i) != '0')
                {
                    throw new IllegalArgumentException("Illegal character at position " + i);
                }
            }
        }


        public int getLength()
        {
            return length;
        }


        public boolean getBit(int index)
        {
            assertValidIndex(index);
            int word = index / WORD_LENGTH;
            int offset = index % WORD_LENGTH;
            return (data[word] & (1 << offset)) != 0;
        }

        public void setBit(int index, boolean set)
        {
            assertValidIndex(index);
            int word = index / WORD_LENGTH;
            int offset = index % WORD_LENGTH;
            if (set)
            {
                data[word] = (data[word] | (1 << offset));
            }
            else // Unset the bit.
            {
                data[word] = (data[word] & ~(1 << offset));
            }
        }


        public void flipBit(int index)
        {
            assertValidIndex(index);
            int word = index / WORD_LENGTH;
            int offset = index % WORD_LENGTH;
            data[word] = (data[word] ^ (1 << offset));
        }


        private void assertValidIndex(int index)
        {
            if (index >= length || index < 0)
            {
                throw new IndexOutOfBoundsException("Invalid index: " + index + " (length: " + length + ")");
            }
        }

        public int countSetBits()
        {
            int count = 0;
            for (int x : data)
            {
                while (x != 0)
                {
                    x &= (x - 1); // Unsets the least significant on bit.
                    ++count; // Count how many times we have to unset a bit before x equals zero.
                }
            }
            return count;
        }


        public int countUnsetBits()
        {
            return length - countSetBits();
        }


        public BigInteger toNumber()
        {
            return (new BigInteger(toString(), 2));
        }


        @Override
        public String toString()
        {
            StringBuilder buffer = new StringBuilder();
            for (int i = length - 1; i >= 0; i--)
            {
                buffer.append(getBit(i) ? '1' : '0');
            }
            return buffer.toString();
        }


        @Override
        public BitString clone()
        {
            try
            {
                BitString clone = (BitString) super.clone();
                clone.data = data.clone();
                return clone;
            }
            catch (CloneNotSupportedException ex)
            {
                // Not possible.
                throw (Error) new InternalError("Cloning failed.").initCause(ex);
            }
        }


        @Override
        public boolean equals(Object o)
        {
            if (this == o)
            {
                return true;
            }
            if (o == null || getClass() != o.getClass())
            {
                return false;
            }

            BitString bitString = (BitString) o;

            return length == bitString.length && Arrays.equals(data, bitString.data);
        }


        @Override
        public int hashCode()
        {
            int result = length;
            result = 31 * result + Arrays.hashCode(data);
            return result;
        }
    }
    public final static class BinaryUtils
    {
        // Mask for casting a byte to an int, bit-by-bit (with
        // bitwise AND) with no special consideration for the sign bit.
        private static final int BITWISE_BYTE_TO_INT = 0x000000FF;

        private static final char[] HEX_CHARS = {'0', '1', '2', '3', '4', '5', '6', '7',
                '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

        private BinaryUtils()
        {
            // Prevents instantiation of utility class.
        }


        public static String convertBytesToHexString(byte[] data)
        {
            StringBuilder buffer = new StringBuilder(data.length * 2);
            for (byte b : data)
            {
                buffer.append(HEX_CHARS[(b >>> 4) & 0x0F]);
                buffer.append(HEX_CHARS[b & 0x0F]);
            }
            return buffer.toString();
        }


        public static byte[] convertHexStringToBytes(String hex)
        {
            if (hex.length() % 2 != 0)
            {
                throw new IllegalArgumentException("Hex string must have even number of characters.");
            }
            byte[] seed = new byte[hex.length() / 2];
            for (int i = 0; i < seed.length; i++)
            {
                int index = i * 2;
                seed[i] = (byte) Integer.parseInt(hex.substring(index, index + 2), 16);
            }
            return seed;
        }


        public static int convertBytesToInt(byte[] bytes, int offset)
        {
            return (BITWISE_BYTE_TO_INT & bytes[offset + 3])
                    | ((BITWISE_BYTE_TO_INT & bytes[offset + 2]) << 8)
                    | ((BITWISE_BYTE_TO_INT & bytes[offset + 1]) << 16)
                    | ((BITWISE_BYTE_TO_INT & bytes[offset]) << 24);
        }


        public static int[] convertBytesToInts(byte[] bytes)
        {
            if (bytes.length % 4 != 0)
            {
                throw new IllegalArgumentException("Number of input bytes must be a multiple of 4.");
            }
            int[] ints = new int[bytes.length / 4];
            for (int i = 0; i < ints.length; i++)
            {
                ints[i] = convertBytesToInt(bytes, i * 4);
            }
            return ints;
        }

        public static long convertBytesToLong(byte[] bytes, int offset)
        {
            long value = 0;
            for (int i = offset; i < offset + 8; i++)
            {
                byte b = bytes[i];
                value <<= 8;
                value += b;
            }
            return value;

        }


        public static BitString convertDoubleToFixedPointBits(double value)
        {
            if (value < 0.0d || value >= 1.0d)
            {
                throw new IllegalArgumentException("Value must be between 0 and 1.");
            }
            StringBuilder bits = new StringBuilder(64);
            double bitValue = 0.5d;
            double d = value;
            while (d > 0)
            {
                if (d >= bitValue)
                {
                    bits.append('1');
                    d -= bitValue;
                }
                else
                {
                    bits.append('0');
                }
                bitValue /= 2;
            }
            return new BitString(bits.toString());
        }
    }
    public static class SeedException extends Exception
    {

        public SeedException(String message)
        {
            super(message);
        }

        public SeedException(String message, Throwable cause)
        {
            super(message, cause);
        }
    }
    public interface SeedGenerator
    {

        byte[] generateSeed(int length) throws SeedException, IOException;
    }

    public static class DevRandomSeedGenerator implements SeedGenerator
    {
        private static final File DEV_RANDOM = new File("/dev/random");

        public byte[] generateSeed(int length) throws SeedException, IOException {
            FileInputStream file = null;
            try
            {
                file = new FileInputStream(DEV_RANDOM);
                byte[] randomSeed = new byte[length];
                int count = 0;
                while (count < length)
                {
                    int bytesRead = file.read(randomSeed, count, length - count);
                    if (bytesRead == -1)
                    {
                        throw new SeedException("EOF encountered reading random data.");
                    }
                    count += bytesRead;
                }
                return randomSeed;
            }
            catch (IOException ex)
            {
                throw new SeedException("Failed reading from " + DEV_RANDOM.getName(), ex);
            }
            catch (SecurityException ex)
            {
                // Might be thrown if resource access is restricted (such as in
                // an applet sandbox).
                throw new SeedException("SecurityManager prevented access to " + DEV_RANDOM.getName(), ex);
            }
            finally
            {
                if (file != null)
                {
                    try
                    {
                        file.close();
                    }
                    catch (IOException ex)
                    {
                        // Ignore.
                    }
                }
            }
        }


        @Override
        public String toString()
        {
            return "/dev/random";
        }
    }
    public static class RandomDotOrgSeedGenerator implements SeedGenerator
    {
        private static final String BASE_URL = "https://www.random.org";

        private static final String RANDOM_URL = BASE_URL + "/integers/?num={0,number,0}&min=0&max=255&col=1&base=16&format=plain&rnd=new";

        private static final String USER_AGENT = RandomDotOrgSeedGenerator.class.getName();

        private static final int MAX_REQUEST_SIZE = 10000;

        private static final Lock cacheLock = new ReentrantLock();
        private static byte[] cache = new byte[1024];
        private static int cacheOffset = cache.length;

        public byte[] generateSeed(int length) throws SeedException
        {
            byte[] seedData = new byte[length];
            try
            {
                cacheLock.lock();
                int count = 0;
                while (count < length)
                {
                    if (cacheOffset < cache.length)
                    {
                        int numberOfBytes = Math.min(length - count, cache.length - cacheOffset);
                        System.arraycopy(cache, cacheOffset, seedData, count, numberOfBytes);
                        count += numberOfBytes;
                        cacheOffset += numberOfBytes;
                    }
                    else
                    {
                        refreshCache(length - count);
                    }
                }
            }
            catch (IOException ex)
            {
                throw new SeedException("Failed downloading bytes from " + BASE_URL, ex);
            }
            catch (SecurityException ex)
            {
                // Might be thrown if resource access is restricted (such as in an applet sandbox).
                throw new SeedException("SecurityManager prevented access to " + BASE_URL, ex);
            }
            finally
            {
                cacheLock.unlock();
            }
            return seedData;
        }


        private void refreshCache(int requiredBytes) throws IOException
        {
            int numberOfBytes = Math.max(requiredBytes, cache.length);
            numberOfBytes = Math.min(numberOfBytes, MAX_REQUEST_SIZE);
            if (numberOfBytes != cache.length)
            {
                cache = new byte[numberOfBytes];
                cacheOffset = numberOfBytes;
            }
            URL url = new URL(MessageFormat.format(RANDOM_URL, numberOfBytes));
            URLConnection connection = url.openConnection();
            connection.setRequestProperty("User-Agent", USER_AGENT);
            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));

            try
            {
                int index = -1;
                for (String line = reader.readLine(); line != null; line = reader.readLine())
                {
                    cache[++index] = (byte) Integer.parseInt(line, 16);
                }
                if (index < cache.length - 1)
                {
                    throw new IOException("Insufficient data received.");
                }
                cacheOffset = 0;
            }
            finally
            {
                reader.close();
            }
        }


        @Override
        public String toString()
        {
            return BASE_URL;
        }
    }
    public static class SecureRandomSeedGenerator implements SeedGenerator
    {
        private static final SecureRandom SOURCE = new SecureRandom();

        public byte[] generateSeed(int length) throws SeedException
        {
            return SOURCE.generateSeed(length);
        }


        @Override
        public String toString()
        {
            return "java.security.SecureRandom";
        }
    }
    public final static class DefaultSeedGenerator implements SeedGenerator
    {
        private static final String DEBUG_PROPERTY = "org.uncommons.maths.random.debug";

        private static final DefaultSeedGenerator INSTANCE = new DefaultSeedGenerator();

        private static final SeedGenerator[] GENERATORS = new SeedGenerator[]
                {
                        new DevRandomSeedGenerator(),
                        new RandomDotOrgSeedGenerator(),
                        new SecureRandomSeedGenerator()
                };


        private DefaultSeedGenerator()
        {
            // Private constructor prevents external instantiation.
        }

        public static DefaultSeedGenerator getInstance()
        {
            return INSTANCE;
        }

        public byte[] generateSeed(int length) throws IOException {
            for (SeedGenerator generator : GENERATORS)
            {
                try
                {
                    byte[] seed = generator.generateSeed(length);
                    try
                    {
                        boolean debug = System.getProperty(DEBUG_PROPERTY, "false").equals("true");
                        if (debug)
                        {
                            String seedString = BinaryUtils.convertBytesToHexString(seed);
                            System.out.println(seed.length + " bytes of seed data acquired from " + generator + ":");
                            System.out.println("  " + seedString);
                        }
                    }
                    catch (SecurityException ex)
                    {
                        // Ignore, means we can't read the property so just default to false.
                    }

                    return seed;
                }
                catch (SeedException ex)
                {
                    // Ignore and try the next generator...
                }
            }
            // This shouldn't happen as at least one the generators should be
            // able to generate a seed.
            throw new IllegalStateException("All available seed generation strategies failed.");
        }
    }
    public static class MersenneTwisterRNG extends Random implements RepeatableRNG
    {
        // The actual seed size isn't that important, but it should be a multiple of 4.
        private static final int SEED_SIZE_BYTES = 16;

        // Magic numbers from original C version.
        private static final int N = 624;
        private static final int M = 397;
        private static final int[] MAG01 = {0, 0x9908b0df};
        private static final int UPPER_MASK = 0x80000000;
        private static final int LOWER_MASK = 0x7fffffff;
        private static final int BOOTSTRAP_SEED = 19650218;
        private static final int BOOTSTRAP_FACTOR = 1812433253;
        private static final int SEED_FACTOR1 = 1664525;
        private static final int SEED_FACTOR2 = 1566083941;
        private static final int GENERATE_MASK1 = 0x9d2c5680;
        private static final int GENERATE_MASK2 = 0xefc60000;

        private final byte[] seed;

        // Lock to prevent concurrent modification of the RNG's internal state.
        private final Object lock = new Object();

        private final int[] mt = new int[N]; // State vector.
        private int mtIndex = 0; // Index into state vector.

        public MersenneTwisterRNG() throws IOException {
            this(DefaultSeedGenerator.getInstance().generateSeed(SEED_SIZE_BYTES));
        }

        public MersenneTwisterRNG(SeedGenerator seedGenerator) throws SeedException, IOException {
            this(seedGenerator.generateSeed(SEED_SIZE_BYTES));
        }

        public MersenneTwisterRNG(byte[] seed)
        {
            if (seed == null || seed.length != SEED_SIZE_BYTES)
            {
                throw new IllegalArgumentException("Mersenne Twister RNG requires a 128-bit (16-byte) seed.");
            }
            this.seed = seed.clone();

            int[] seedInts = BinaryUtils.convertBytesToInts(this.seed);

            // This section is translated from the init_genrand code in the C version.
            mt[0] = BOOTSTRAP_SEED;
            for (mtIndex = 1; mtIndex < N; mtIndex++)
            {
                mt[mtIndex] = (BOOTSTRAP_FACTOR
                        * (mt[mtIndex - 1] ^ (mt[mtIndex - 1] >>> 30))
                        + mtIndex);
            }

            // This section is translated from the init_by_array code in the C version.
            int i = 1;
            int j = 0;
            for (int k = Math.max(N, seedInts.length); k > 0; k--)
            {
                mt[i] = (mt[i] ^ ((mt[i - 1] ^ (mt[i - 1] >>> 30)) * SEED_FACTOR1)) + seedInts[j] + j;
                i++;
                j++;
                if (i >= N)
                {
                    mt[0] = mt[N - 1];
                    i = 1;
                }
                if (j >= seedInts.length)
                {
                    j = 0;
                }
            }
            for (int k = N - 1; k > 0; k--)
            {
                mt[i] = (mt[i] ^ ((mt[i - 1] ^ (mt[i - 1] >>> 30)) * SEED_FACTOR2)) - i;
                i++;
                if (i >= N)
                {
                    mt[0] = mt[N - 1];
                    i = 1;
                }
            }
            mt[0] = UPPER_MASK; // Most significant bit is 1 - guarantees non-zero initial array.
        }

        public byte[] getSeed()
        {
            return seed.clone();
        }

        @Override
        protected final int next(int bits)
        {
            int y;
            synchronized (lock)
            {
                if (mtIndex >= N) // Generate N ints at a time.
                {
                    int kk;
                    for (kk = 0; kk < N - M; kk++)
                    {
                        y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);
                        mt[kk] = mt[kk + M] ^ (y >>> 1) ^ MAG01[y & 0x1];
                    }
                    for (; kk < N - 1; kk++)
                    {
                        y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);
                        mt[kk] = mt[kk + (M - N)] ^ (y >>> 1) ^ MAG01[y & 0x1];
                    }
                    y = (mt[N - 1] & UPPER_MASK) | (mt[0] & LOWER_MASK);
                    mt[N - 1] = mt[M - 1] ^ (y >>> 1) ^ MAG01[y & 0x1];

                    mtIndex = 0;
                }

                y = mt[mtIndex++];
            }
            // Tempering
            y ^= (y >>> 11);
            y ^= (y << 7) & GENERATE_MASK1;
            y ^= (y << 15) & GENERATE_MASK2;
            y ^= (y >>> 18);

            return y >>> (32 - bits);
        }
    }
    public final static class RandomWrapper extends Random {

        private static final byte[] STANDARD_SEED = "Mahout=Hadoop+ML".getBytes(Charset.forName("US-ASCII"));

        private static boolean testSeed;

        private Random random;
        private final Long fixedSeed;

        RandomWrapper() throws IOException {
            this.fixedSeed = null;
            random = buildRandom();
        }

        RandomWrapper(long fixedSeed) throws IOException {
            this.fixedSeed = fixedSeed;
            random = buildRandom();
        }

        static void useTestSeed() {
            testSeed = true;
        }

        private Random buildRandom() throws IOException {
            if (testSeed) {
                return new MersenneTwisterRNG(STANDARD_SEED);
            } else if (fixedSeed == null) {
                return new MersenneTwisterRNG();
            } else {
                return new MersenneTwisterRNG(RandomUtils.longSeedtoBytes(fixedSeed));
            }
        }

        public Random getRandom() {
            return random;
        }

        void reset() throws IOException {
            random = buildRandom();
        }

        public long getSeed() {
            return RandomUtils.seedBytesToLong(((RepeatableRNG) random).getSeed());
        }

        @Override
        public void setSeed(long seed) {
            // Since this will be called by the java.util.Random() constructor before we construct
            // the delegate... and because we don't actually care about the result of this for our
            // purpose:
            if (random != null) {
                random.setSeed(seed);
            }
        }

        @Override
        protected int next(int bits) {
            // Ugh, can't delegate this method -- it's protected
            // Callers can't use it and other methods are delegated, so shouldn't matter
            throw new UnsupportedOperationException();
        }

        @Override
        public void nextBytes(byte[] bytes) {
            random.nextBytes(bytes);
        }

        @Override
        public int nextInt() {
            return random.nextInt();
        }

        @Override
        public int nextInt(int n) {
            return random.nextInt(n);
        }

        @Override
        public long nextLong() {
            return random.nextLong();
        }

        @Override
        public boolean nextBoolean() {
            return random.nextBoolean();
        }

        @Override
        public float nextFloat() {
            return random.nextFloat();
        }

        @Override
        public double nextDouble() {
            return random.nextDouble();
        }

        @Override
        public double nextGaussian() {
            return random.nextGaussian();
        }
    }

    public final static class RandomUtils {

        public static final int MAX_INT_SMALLER_TWIN_PRIME = 2147482949;

        private static final Map<RandomWrapper,Boolean> instances =
                Collections.synchronizedMap(new WeakHashMap<RandomWrapper,Boolean>());

        private RandomUtils() { }

        public static void useTestSeed() throws IOException {
            RandomWrapper.useTestSeed();
            synchronized (instances) {
                for (RandomWrapper rng : instances.keySet()) {
                    rng.reset();
                }
            }
        }

        public static Random getRandom() throws IOException {
            RandomWrapper random = new RandomWrapper();
            instances.put(random, Boolean.TRUE);
            return random;
        }

        public static Random getRandom(long seed) throws IOException {
            RandomWrapper random = new RandomWrapper(seed);
            instances.put(random, Boolean.TRUE);
            return random;
        }

        public static byte[] longSeedtoBytes(long seed) {
            byte[] seedBytes = new byte[16];
            seedBytes[0] = (byte) (seed >>> 56);
            seedBytes[1] = (byte) (seed >>> 48);
            seedBytes[2] = (byte) (seed >>> 40);
            seedBytes[3] = (byte) (seed >>> 32);
            seedBytes[4] = (byte) (seed >>> 24);
            seedBytes[5] = (byte) (seed >>> 16);
            seedBytes[6] = (byte) (seed >>> 8);
            seedBytes[7] = (byte) seed;
            System.arraycopy(seedBytes, 0, seedBytes, 8, 8);
            return seedBytes;
        }

        public static long seedBytesToLong(byte[] seed) {
            return (seed[0] & 0xFFL) << 56 | (seed[1] & 0xFFL) << 48 | (seed[2] & 0xFFL) << 40
                    | (seed[3] & 0xFFL) << 32 | (seed[4] & 0xFFL) << 24 | (seed[5] & 0xFFL) << 16
                    | (seed[6] & 0xFFL) << 8 | seed[7] & 0xFFL;
        }

        public static int hashDouble(double value) {
            long bits = Double.doubleToLongBits(value);
            return (int) (bits ^ bits >>> 32);
        }

        public static int hashFloat(float value) {
            return Float.floatToIntBits(value);
        }

        public static int hashLong(long value) {
            return (int) (value ^ value >>> 32);
        }

        public static int nextTwinPrime(int n) {
            if (n > MAX_INT_SMALLER_TWIN_PRIME) {
                throw new IllegalArgumentException();
            }
            if (n <= 3) {
                return 3;
            }
            int next = nextPrime(n);
            while (isNotPrime(next + 2)) {
                next = nextPrime(next + 4);
            }
            return next + 2;
        }

        public static int nextPrime(int n) {
            if (n < 2) {
                return 2;
            }
            // Make sure the number is odd. Is this too clever?
            n |= 0x1;
            // There is no problem with overflow since Integer.MAX_INT is prime, as it happens
            while (isNotPrime(n)) {
                n += 2;
            }
            return n;
        }

        public static boolean isNotPrime(int n) {
            if (n < 2 || (n & 0x1) == 0) { // < 2 or even
                return true;
            }
            int max = 1 + (int) Math.sqrt(n);
            for (int d = 3; d <= max; d += 2) {
                if (n % d == 0) {
                    return true;
                }
            }
            return false;
        }

    }
    public static final class FastIDSet implements Serializable, Cloneable, Iterable<Long> {

        private static final float DEFAULT_LOAD_FACTOR = 1.5f;

        private static final long REMOVED = Long.MAX_VALUE;
        private static final long NULL = Long.MIN_VALUE;

        private long[] keys;
        private float loadFactor;
        private int numEntries;
        private int numSlotsUsed;

        public FastIDSet() {
            this(2);
        }

        public FastIDSet(long[] initialKeys) {
            this(initialKeys.length);
            addAll(initialKeys);
        }

        public FastIDSet(int size) {
            this(size, DEFAULT_LOAD_FACTOR);
        }

        public FastIDSet(int size, float loadFactor) {
            checkArgument(size >= 0, "size must be at least 0");
            checkArgument(loadFactor >= 1.0f, "loadFactor must be at least 1.0");
            this.loadFactor = loadFactor;
            int max = (int) (RandomUtils.MAX_INT_SMALLER_TWIN_PRIME / loadFactor);
            checkArgument(size < max, "size must be less than %d", max);
            int hashSize = RandomUtils.nextTwinPrime((int) (loadFactor * size));
            keys = new long[hashSize];
            Arrays.fill(keys, NULL);  }

        private int find(long key) {
            int theHashCode = (int) key & 0x7FFFFFFF; // make sure it's positive
            long[] keys = this.keys;
            int hashSize = keys.length;
            int jump = 1 + theHashCode % (hashSize - 2);
            int index = theHashCode % hashSize;
            long currentKey = keys[index];
            while (currentKey != NULL && key != currentKey) { // note: true when currentKey == REMOVED
                if (index < jump) {
                    index += hashSize - jump;
                } else {
                    index -= jump;
                }
                currentKey = keys[index];
            }
            return index;
        }

        /**
         * @see #find(long)
         */
        private int findForAdd(long key) {
            int theHashCode = (int) key & 0x7FFFFFFF; // make sure it's positive
            long[] keys = this.keys;
            int hashSize = keys.length;
            int jump = 1 + theHashCode % (hashSize - 2);
            int index = theHashCode % hashSize;
            long currentKey = keys[index];
            while (currentKey != NULL && currentKey != REMOVED && key != currentKey) { // Different here
                if (index < jump) {
                    index += hashSize - jump;
                } else {
                    index -= jump;
                }
                currentKey = keys[index];
            }
            return index;
        }

        public int size() {
            return numEntries;
        }

        public boolean isEmpty() {
            return numEntries == 0;
        }

        public boolean contains(long key) {
            return key != NULL && key != REMOVED && keys[find(key)] != NULL;
        }

        public boolean add(long key) {
            checkArgument(key != NULL && key != REMOVED);

            // If less than half the slots are open, let's clear it up
            if (numSlotsUsed * loadFactor >= keys.length) {
                // If over half the slots used are actual entries, let's grow
                if (numEntries * loadFactor >= numSlotsUsed) {
                    growAndRehash();
                } else {
                    // Otherwise just rehash to clear REMOVED entries and don't grow
                    rehash();
                }
            }
            // Here we may later consider implementing Brent's variation described on page 532
            int index = findForAdd(key);
            long keyIndex = keys[index];
            if (keyIndex != key) {
                keys[index] = key;
                numEntries++;
                if (keyIndex == NULL) {
                    numSlotsUsed++;
                }
                return true;
            }
            return false;
        }

        @Override
        public LongPrimitiveIterator iterator() {
            return new KeyIterator();
        }

        public long[] toArray() {
            long[] result = new long[numEntries];
            for (int i = 0, position = 0; i < result.length; i++) {
                while (keys[position] == NULL || keys[position] == REMOVED) {
                    position++;
                }
                result[i] = keys[position++];
            }
            return result;
        }

        public boolean remove(long key) {
            if (key == NULL || key == REMOVED) {
                return false;
            }
            int index = find(key);
            if (keys[index] == NULL) {
                return false;
            } else {
                keys[index] = REMOVED;
                numEntries--;
                return true;
            }
        }

        public boolean addAll(long[] c) {
            boolean changed = false;
            for (long k : c) {
                if (add(k)) {
                    changed = true;
                }
            }
            return changed;
        }

        public boolean addAll(FastIDSet c) {
            boolean changed = false;
            for (long k : c.keys) {
                if (k != NULL && k != REMOVED && add(k)) {
                    changed = true;
                }
            }
            return changed;
        }

        public boolean removeAll(long[] c) {
            boolean changed = false;
            for (long o : c) {
                if (remove(o)) {
                    changed = true;
                }
            }
            return changed;
        }

        public boolean removeAll(FastIDSet c) {
            boolean changed = false;
            for (long k : c.keys) {
                if (k != NULL && k != REMOVED && remove(k)) {
                    changed = true;
                }
            }
            return changed;
        }

        public boolean retainAll(FastIDSet c) {
            boolean changed = false;
            for (int i = 0; i < keys.length; i++) {
                long k = keys[i];
                if (k != NULL && k != REMOVED && !c.contains(k)) {
                    keys[i] = REMOVED;
                    numEntries--;
                    changed = true;
                }
            }
            return changed;
        }

        public void clear() {
            numEntries = 0;
            numSlotsUsed = 0;
            Arrays.fill(keys, NULL);
        }

        private void growAndRehash() {
            if (keys.length * loadFactor >= RandomUtils.MAX_INT_SMALLER_TWIN_PRIME) {
                throw new IllegalStateException("Can't grow any more");
            }
            rehash(RandomUtils.nextTwinPrime((int) (loadFactor * keys.length)));
        }

        public void rehash() {
            rehash(RandomUtils.nextTwinPrime((int) (loadFactor * numEntries)));
        }

        private void rehash(int newHashSize) {
            long[] oldKeys = keys;
            numEntries = 0;
            numSlotsUsed = 0;
            keys = new long[newHashSize];
            Arrays.fill(keys, NULL);
            int length = oldKeys.length;
            for (int i = 0; i < length; i++) {
                long key = oldKeys[i];
                if (key != NULL && key != REMOVED) {
                    add(key);
                }
            }
        }


        public int intersectionSize(FastIDSet other) {
            int count = 0;
            for (long key : other.keys) {
                if (key != NULL && key != REMOVED && keys[find(key)] != NULL) {
                    count++;
                }
            }
            return count;
        }

        @Override
        public FastIDSet clone() {
            FastIDSet clone;
            try {
                clone = (FastIDSet) super.clone();
            } catch (CloneNotSupportedException cnse) {
                throw new AssertionError();
            }
            clone.keys = keys.clone();
            return clone;
        }

        @Override
        public int hashCode() {
            int hash = 0;
            long[] keys = this.keys;
            int max = keys.length;
            for (int i = 0; i < max; i++) {
                long key = keys[i];
                if (key != NULL && key != REMOVED) {
                    hash = 31 * hash + ((int) (key >> 32) ^ (int) key);
                }
            }
            return hash;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof FastIDSet)) {
                return false;
            }
            FastIDSet otherMap = (FastIDSet) other;
            long[] otherKeys = otherMap.keys;
            int length = keys.length;
            int otherLength = otherKeys.length;
            int max = Math.min(length, otherLength);

            int i = 0;
            while (i < max) {
                long key = keys[i];
                long otherKey = otherKeys[i];
                if (key == NULL || key == REMOVED) {
                    if (otherKey != NULL && otherKey != REMOVED) {
                        return false;
                    }
                } else {
                    if (key != otherKey) {
                        return false;
                    }
                }
                i++;
            }
            while (i < length) {
                long key = keys[i];
                if (key != NULL && key != REMOVED) {
                    return false;
                }
                i++;
            }
            while (i < otherLength) {
                long key = otherKeys[i];
                if (key != NULL && key != REMOVED) {
                    return false;
                }
                i++;
            }
            return true;
        }

        @Override
        public String toString() {
            if (isEmpty()) {
                return "[]";
            }
            StringBuilder result = new StringBuilder();
            result.append('[');
            for (long key : keys) {
                if (key != NULL && key != REMOVED) {
                    result.append(key).append(',');
                }
            }
            result.setCharAt(result.length() - 1, ']');
            return result.toString();
        }

        private final class KeyIterator extends AbstractLongPrimitiveIterator {

            private int position;
            private int lastNext = -1;

            @Override
            public boolean hasNext() {
                goToNext();
                return position < keys.length;
            }

            @Override
            public long nextLong() {
                goToNext();
                lastNext = position;
                if (position >= keys.length) {
                    throw new NoSuchElementException();
                }
                return keys[position++];
            }

            @Override
            public long peek() {
                goToNext();
                if (position >= keys.length) {
                    throw new NoSuchElementException();
                }
                return keys[position];
            }

            private void goToNext() {
                int length = keys.length;
                while (position < length
                        && (keys[position] == NULL || keys[position] == REMOVED)) {
                    position++;
                }
            }

            @Override
            public void remove() {
                if (lastNext >= keys.length) {
                    throw new NoSuchElementException();
                }
                if (lastNext < 0) {
                    throw new IllegalStateException();
                }
                keys[lastNext] = REMOVED;
                numEntries--;
            }

            public Iterator<Long> iterator() {
                return new KeyIterator();
            }

            @Override
            public void skip(int n) {
                position += n;
            }

        }

    }

    public interface Logger {

        final public String ROOT_LOGGER_NAME = "ROOT";

        public String getName();

        public boolean isTraceEnabled();

        public void trace(String msg);

        public void trace(String format, Object arg);

        public void trace(String format, Object arg1, Object arg2);

        public void trace(String format, Object[] argArray);

        public void trace(String msg, Throwable t);

        public boolean isTraceEnabled(Marker marker);

        public void trace(Marker marker, String msg);

        public void trace(Marker marker, String format, Object arg);

        public void trace(Marker marker, String format, Object arg1, Object arg2);

        public void trace(Marker marker, String format, Object[] argArray);

        public void trace(Marker marker, String msg, Throwable t);

        public boolean isDebugEnabled();

        public void debug(String msg);

        public void debug(String format, Object arg);

        public void debug(String format, Object arg1, Object arg2);

        public void debug(String format, Object[] argArray);

        public void debug(String msg, Throwable t);

        public boolean isDebugEnabled(Marker marker);

        public void debug(Marker marker, String msg);

        public void debug(Marker marker, String format, Object arg);

        public void debug(Marker marker, String format, Object arg1, Object arg2);

        public void debug(Marker marker, String format, Object[] argArray);

        public void debug(Marker marker, String msg, Throwable t);

        public boolean isInfoEnabled();

        public void info(String msg);

        public void info(String format, Object arg);

        public void info(String format, Object arg1, Object arg2);

        public void info(String format, Object[] argArray);

        public void info(String msg, Throwable t);

        public boolean isInfoEnabled(Marker marker);

        public void info(Marker marker, String msg);

        public void info(Marker marker, String format, Object arg);

        public void info(Marker marker, String format, Object arg1, Object arg2);

        public void info(Marker marker, String format, Object[] argArray);

        public void info(Marker marker, String msg, Throwable t);

        public boolean isWarnEnabled();

        public void warn(String msg);

        public void warn(String format, Object arg);

        public void warn(String format, Object[] argArray);

        public void warn(String format, Object arg1, Object arg2);

        public void warn(String msg, Throwable t);

        public boolean isWarnEnabled(Marker marker);

        public void warn(Marker marker, String msg);

        public void warn(Marker marker, String format, Object arg);

        public void warn(Marker marker, String format, Object arg1, Object arg2);

        public void warn(Marker marker, String format, Object[] argArray);

        public void warn(Marker marker, String msg, Throwable t);

        public boolean isErrorEnabled();

        public void error(String msg);

        public void error(String format, Object arg);

        public void error(String format, Object arg1, Object arg2);

        public void error(String format, Object[] argArray);

        public void error(String msg, Throwable t);

        public boolean isErrorEnabled(Marker marker);

        public void error(Marker marker, String msg);

        public void error(Marker marker, String format, Object arg);

        public void error(Marker marker, String format, Object arg1, Object arg2);

        public void error(Marker marker, String format, Object[] argArray);

        public void error(Marker marker, String msg, Throwable t);

    }

    public interface Marker extends Serializable {

        public final String ANY_MARKER = "*";

        public final String ANY_NON_NULL_MARKER = "+";

        public String getName();

        public void add(Marker child);

        public boolean remove(Marker child);

        public boolean hasChildren();

        public Iterator iterator();

        public boolean contains(Marker other);

        public boolean contains(String name);

        public boolean equals(Object o);

        public int hashCode();

    }

    public static final class LoggerFactory {

        static ILoggerFactory loggerFactory;

        static final String NO_STATICLOGGERBINDER_URL = "http://www.slf4j.org/codes.html#StaticLoggerBinder";
        static final String NULL_LF_URL = "http://www.slf4j.org/codes.html#null_LF";

        // private constructor prevents instantiation
        private LoggerFactory() {
        }


        static {
            try {
                loggerFactory = StaticLoggerBinder.SINGLETON.getLoggerFactory();
            } catch(NoClassDefFoundError ncde) {
                String msg = ncde.getMessage();
                if(msg != null && msg.indexOf("org/slf4j/impl/StaticLoggerBinder") != -1) {
                    Util.reportFailure("Failed to load class \"org.slf4j.impl.StaticLoggerBinder\".");
                    Util.reportFailure("See "+NO_STATICLOGGERBINDER_URL+" for further details.");

                }
                throw ncde;
            } catch (Exception e) {
                // we should never get here
                Util.reportFailure("Failed to instantiate logger ["
                        + StaticLoggerBinder.SINGLETON.getLoggerFactoryClassStr() + "]", e);
            }
        }

        public static Logger getLogger(String name) {
            if(loggerFactory == null) {
                throw new IllegalStateException("Logging factory implementation cannot be null. See also "+NULL_LF_URL);
            }
            return loggerFactory.getLogger(name);
        }

        public static Logger getLogger(Class clazz) {
            if(loggerFactory == null) {
                throw new IllegalStateException("Logging factory implementation cannot be null. See also "+NULL_LF_URL);
            }
            return loggerFactory.getLogger(clazz.getName());
        }

        public static ILoggerFactory getILoggerFactory() {
            return loggerFactory;
        }
    }

    public static class Util {

        static final public void reportFailure(String msg, Throwable t) {
            System.err.println(msg);
            System.err.println("Reported exception:");
            t.printStackTrace();
        }

        static final public void reportFailure(String msg) {
            System.err.println("SLF4J: " +msg);
        }
    }
    public interface ILoggerFactory {

        public Logger getLogger(String name);
    }
    public static class StaticLoggerBinder {


        public static final StaticLoggerBinder SINGLETON = new StaticLoggerBinder();

        private StaticLoggerBinder() {
            throw new UnsupportedOperationException("This code should never make it into the jar");
        }

        public ILoggerFactory getLoggerFactory() {
            throw new UnsupportedOperationException("This code should never make it into the jar");
        }

        public String getLoggerFactoryClassStr() {
            throw new UnsupportedOperationException("This code should never make it into the jar");
        }
    }

    public interface CandidateItemsStrategy {

        FastIDSet getCandidateItems(long userID, PreferenceArray preferencesFromUser, DataModel dataModel)
                throws TasteException;

    }

    public interface MostSimilarItemsCandidateItemsStrategy {

        FastIDSet getCandidateItems(long[] itemIDs, DataModel dataModel) throws TasteException;
    }

    public static abstract class AbstractCandidateItemsStrategy implements CandidateItemsStrategy,
            MostSimilarItemsCandidateItemsStrategy {

        @Override
        public FastIDSet getCandidateItems(long userID, PreferenceArray preferencesFromUser, DataModel dataModel)
                throws TasteException {
            return doGetCandidateItems(preferencesFromUser.getIDs(), dataModel);
        }

        @Override
        public FastIDSet getCandidateItems(long[] itemIDs, DataModel dataModel) throws TasteException {
            return doGetCandidateItems(itemIDs, dataModel);
        }

        abstract FastIDSet doGetCandidateItems(long[] preferredItemIDs, DataModel dataModel) throws TasteException;
    }


    public static final class PreferredItemsNeighborhoodCandidateItemsStrategy extends AbstractCandidateItemsStrategy {

        @Override
        protected FastIDSet doGetCandidateItems(long[] preferredItemIDs, DataModel dataModel) throws TasteException {
            FastIDSet possibleItemsIDs = new FastIDSet();
            for (long itemID : preferredItemIDs) {
                PreferenceArray itemPreferences = dataModel.getPreferencesForItem(itemID);
                int numUsersPreferringItem = itemPreferences.length();
                for (int index = 0; index < numUsersPreferringItem; index++) {
                    possibleItemsIDs.addAll(dataModel.getItemIDsFromUser(itemPreferences.getUserID(index)));
                }
            }
            possibleItemsIDs.removeAll(preferredItemIDs);
            return possibleItemsIDs;
        }

    }

    public abstract static class AbstractRecommender implements Recommender {

        private static final Logger log = LoggerFactory.getLogger(AbstractRecommender.class);

        private final DataModel dataModel;
        private final CandidateItemsStrategy candidateItemsStrategy;

        protected AbstractRecommender(DataModel dataModel, CandidateItemsStrategy candidateItemsStrategy) {
            this.dataModel = checkNotNull(dataModel);
            this.candidateItemsStrategy = checkNotNull(candidateItemsStrategy);
        }

        protected AbstractRecommender(DataModel dataModel) {
            this(dataModel, getDefaultCandidateItemsStrategy());
        }

        protected static CandidateItemsStrategy getDefaultCandidateItemsStrategy() {
            return new PreferredItemsNeighborhoodCandidateItemsStrategy();
        }

        @Override
        public List<RecommendedItem> recommend(long userID, int howMany) throws TasteException {
            return recommend(userID, howMany, null);
        }

        @Override
        public void setPreference(long userID, long itemID, float value) throws TasteException {
            checkArgument(!Float.isNaN(value), "NaN value");
            log.debug("Setting preference for user {}, item {}", userID, itemID);
            dataModel.setPreference(userID, itemID, value);
        }

        @Override
        public void removePreference(long userID, long itemID) throws TasteException {
            log.debug("Remove preference for user '{}', item '{}'", userID, itemID);
            dataModel.removePreference(userID, itemID);
        }

        @Override
        public DataModel getDataModel() {
            return dataModel;
        }

        protected FastIDSet getAllOtherItems(long userID, PreferenceArray preferencesFromUser) throws TasteException {
            return candidateItemsStrategy.getCandidateItems(userID, preferencesFromUser, dataModel);
        }

    }

    public interface UserNeighborhood extends Refreshable {
        long[] getUserNeighborhood(long userID) throws TasteException;
    }

    public interface UserBasedRecommender extends Recommender {

        long[] mostSimilarUserIDs(long userID, int howMany) throws TasteException;
        long[] mostSimilarUserIDs(long userID, int howMany, Rescorer<LongPair> rescorer) throws TasteException;

    }

    public interface Rescorer<T> {

        double rescore(T thing, double originalScore);
        boolean isFiltered(T thing);
    }

    public final class LongPair implements Comparable<LongPair>, Serializable {

        private final long first;
        private final long second;

        public LongPair(long first, long second) {
            this.first = first;
            this.second = second;
        }

        public long getFirst() {
            return first;
        }

        public long getSecond() {
            return second;
        }

        public LongPair swap() {
            return new LongPair(second, first);
        }

        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof LongPair)) {
                return false;
            }
            LongPair otherPair = (LongPair) obj;
            return first == otherPair.getFirst() && second == otherPair.getSecond();
        }

        @Override
        public int hashCode() {
            int firstHash = Longs.hashCode(first);
            // Flip top and bottom 16 bits; this makes the hash function probably different
            // for (a,b) versus (b,a)
            return (firstHash >>> 16 | firstHash << 16) ^ Longs.hashCode(second);
        }

        @Override
        public String toString() {
            return '(' + String.valueOf(first) + ',' + second + ')';
        }

        @Override
        public int compareTo(LongPair o) {
            if (first < o.getFirst()) {
                return -1;
            } else if (first > o.getFirst()) {
                return 1;
            } else {
                return second < o.getSecond() ? -1 : second > o.getSecond() ? 1 : 0;
            }
        }

    }

    public static final class Longs {
        private Longs() {}

        public static final int BYTES = Long.SIZE / Byte.SIZE;

        public static int hashCode(long value) {
            return (int) (value ^ (value >>> 32));
        }

        public static int compare(long a, long b) {
            return (a < b) ? -1 : ((a > b) ? 1 : 0);
        }

        public static boolean contains(long[] array, long target) {
            for (long value : array) {
                if (value == target) {
                    return true;
                }
            }
            return false;
        }

        public static int indexOf(long[] array, long target) {
            return indexOf(array, target, 0, array.length);
        }

        // TODO(kevinb): consider making this public
        private static int indexOf(
                long[] array, long target, int start, int end) {
            for (int i = start; i < end; i++) {
                if (array[i] == target) {
                    return i;
                }
            }
            return -1;
        }

        public static int indexOf(long[] array, long[] target) {
            checkNotNull(array, "array");
            checkNotNull(target, "target");
            if (target.length == 0) {
                return 0;
            }

            outer:
            for (int i = 0; i < array.length - target.length + 1; i++) {
                for (int j = 0; j < target.length; j++) {
                    if (array[i + j] != target[j]) {
                        continue outer;
                    }
                }
                return i;
            }
            return -1;
        }

        public static int lastIndexOf(long[] array, long target) {
            return lastIndexOf(array, target, 0, array.length);
        }

        // TODO(kevinb): consider making this public
        private static int lastIndexOf(
                long[] array, long target, int start, int end) {
            for (int i = end - 1; i >= start; i--) {
                if (array[i] == target) {
                    return i;
                }
            }
            return -1;
        }

        public static long min(long... array) {
            checkArgument(array.length > 0);
            long min = array[0];
            for (int i = 1; i < array.length; i++) {
                if (array[i] < min) {
                    min = array[i];
                }
            }
            return min;
        }

        public static long max(long... array) {
            checkArgument(array.length > 0);
            long max = array[0];
            for (int i = 1; i < array.length; i++) {
                if (array[i] > max) {
                    max = array[i];
                }
            }
            return max;
        }

        public static long[] concat(long[]... arrays) {
            int length = 0;
            for (long[] array : arrays) {
                length += array.length;
            }
            long[] result = new long[length];
            int pos = 0;
            for (long[] array : arrays) {
                System.arraycopy(array, 0, result, pos, array.length);
                pos += array.length;
            }
            return result;
        }


        public static byte[] toByteArray(long value) {
            return new byte[] {
                    (byte) (value >> 56),
                    (byte) (value >> 48),
                    (byte) (value >> 40),
                    (byte) (value >> 32),
                    (byte) (value >> 24),
                    (byte) (value >> 16),
                    (byte) (value >> 8),
                    (byte) value};
        }


        public static long fromByteArray(byte[] bytes) {
            checkArgument(bytes.length >= BYTES,
                    "array too small: %s < %s", bytes.length, BYTES);
            return fromBytes(bytes[0], bytes[1], bytes[2], bytes[3],
                    bytes[4], bytes[5], bytes[6], bytes[7]) ;
        }


        public static long fromBytes(byte b1, byte b2, byte b3, byte b4,
                                     byte b5, byte b6, byte b7, byte b8) {
            return (b1 & 0xFFL) << 56
                    | (b2 & 0xFFL) << 48
                    | (b3 & 0xFFL) << 40
                    | (b4 & 0xFFL) << 32
                    | (b5 & 0xFFL) << 24
                    | (b6 & 0xFFL) << 16
                    | (b7 & 0xFFL) << 8
                    | (b8 & 0xFFL);
        }

        public static long[] ensureCapacity(
                long[] array, int minLength, int padding) {
            checkArgument(minLength >= 0, "Invalid minLength: %s", minLength);
            checkArgument(padding >= 0, "Invalid padding: %s", padding);
            return (array.length < minLength)
                    ? copyOf(array, minLength + padding)
                    : array;
        }

        // Arrays.copyOf() requires Java 6
        private static long[] copyOf(long[] original, int length) {
            long[] copy = new long[length];
            System.arraycopy(original, 0, copy, 0, Math.min(original.length, length));
            return copy;
        }

        public static String join(String separator, long... array) {
            checkNotNull(separator);
            if (array.length == 0) {
                return "";
            }

            // For pre-sizing a builder, just get the right order of magnitude
            StringBuilder builder = new StringBuilder(array.length * 10);
            builder.append(array[0]);
            for (int i = 1; i < array.length; i++) {
                builder.append(separator).append(array[i]);
            }
            return builder.toString();
        }

        public static Comparator<long[]> lexicographicalComparator() {
            return LexicographicalComparator.INSTANCE;
        }

        private enum LexicographicalComparator implements Comparator<long[]> {
            INSTANCE;

            @Override
            public int compare(long[] left, long[] right) {
                int minLength = Math.min(left.length, right.length);
                for (int i = 0; i < minLength; i++) {
                    int result = Longs.compare(left[i], right[i]);
                    if (result != 0) {
                        return result;
                    }
                }
                return left.length - right.length;
            }
        }

        public static long[] toArray(Collection<Long> collection) {
            if (collection instanceof LongArrayAsList) {
                return ((LongArrayAsList) collection).toLongArray();
            }

            Object[] boxedArray = collection.toArray();
            int len = boxedArray.length;
            long[] array = new long[len];
            for (int i = 0; i < len; i++) {
                array[i] = (Long) boxedArray[i];
            }
            return array;
        }

        public static List<Long> asList(long... backingArray) {
            if (backingArray.length == 0) {
                return Collections.emptyList();
            }
            return new LongArrayAsList(backingArray);
        }


        private static class LongArrayAsList extends AbstractList<Long>
                implements RandomAccess, Serializable {
            final long[] array;
            final int start;
            final int end;

            LongArrayAsList(long[] array) {
                this(array, 0, array.length);
            }

            LongArrayAsList(long[] array, int start, int end) {
                this.array = array;
                this.start = start;
                this.end = end;
            }

            @Override public int size() {
                return end - start;
            }

            @Override public boolean isEmpty() {
                return false;
            }

            @Override public Long get(int index) {
                checkElementIndex(index, size());
                return array[start + index];
            }

            @Override public boolean contains(Object target) {
                // Overridden to prevent a ton of boxing
                return (target instanceof Long)
                        && Longs.indexOf(array, (Long) target, start, end) != -1;
            }

            @Override public int indexOf(Object target) {
                // Overridden to prevent a ton of boxing
                if (target instanceof Long) {
                    int i = Longs.indexOf(array, (Long) target, start, end);
                    if (i >= 0) {
                        return i - start;
                    }
                }
                return -1;
            }

            @Override public int lastIndexOf(Object target) {
                // Overridden to prevent a ton of boxing
                if (target instanceof Long) {
                    int i = Longs.lastIndexOf(array, (Long) target, start, end);
                    if (i >= 0) {
                        return i - start;
                    }
                }
                return -1;
            }

            @Override public Long set(int index, Long element) {
                checkElementIndex(index, size());
                long oldValue = array[start + index];
                array[start + index] = element;
                return oldValue;
            }

            @Override public List<Long> subList(int fromIndex, int toIndex) {
                int size = size();
                checkPositionIndexes(fromIndex, toIndex, size);
                if (fromIndex == toIndex) {
                    return Collections.emptyList();
                }
                return new LongArrayAsList(array, start + fromIndex, start + toIndex);
            }

            @Override public boolean equals(Object object) {
                if (object == this) {
                    return true;
                }
                if (object instanceof LongArrayAsList) {
                    LongArrayAsList that = (LongArrayAsList) object;
                    int size = size();
                    if (that.size() != size) {
                        return false;
                    }
                    for (int i = 0; i < size; i++) {
                        if (array[start + i] != that.array[that.start + i]) {
                            return false;
                        }
                    }
                    return true;
                }
                return super.equals(object);
            }

            @Override public int hashCode() {
                int result = 1;
                for (int i = start; i < end; i++) {
                    result = 31 * result + Longs.hashCode(array[i]);
                }
                return result;
            }

            @Override public String toString() {
                StringBuilder builder = new StringBuilder(size() * 10);
                builder.append('[').append(array[start]);
                for (int i = start + 1; i < end; i++) {
                    builder.append(", ").append(array[i]);
                }
                return builder.append(']').toString();
            }

            long[] toLongArray() {
                // Arrays.copyOfRange() requires Java 6
                int size = size();
                long[] result = new long[size];
                System.arraycopy(array, start, result, 0, size);
                return result;
            }

            private static final long serialVersionUID = 0;
        }
    }

    public interface UserSimilarity extends Refreshable {

        double userSimilarity(long userID1, long userID2) throws TasteException;
        void setPreferenceInferrer(PreferenceInferrer inferrer);

    }
    public interface PreferenceInferrer extends Refreshable {

        float inferPreference(long userID, long itemID) throws TasteException;
    }
    public interface ItemSimilarity extends Refreshable {

        double itemSimilarity(long itemID1, long itemID2) throws TasteException;

        double[] itemSimilarities(long itemID1, long[] itemID2s) throws TasteException;

        long[] allSimilarItemIDs(long itemID) throws TasteException;
    }

    public @interface GwtCompatible {

        boolean serializable() default false;

        boolean emulated() default false;
    }

    @GwtCompatible
    public @interface GwtIncompatible {

        String value();

    }

    public final static class Ints {
        private Ints() {}


        public static final int BYTES = Integer.SIZE / Byte.SIZE;


        public static int hashCode(int value) {
            return value;
        }

        public static int checkedCast(long value) {
            int result = (int) value;
            checkArgument(result == value, "Out of range: %s", value);
            return result;
        }


        public static int saturatedCast(long value) {
            if (value > Integer.MAX_VALUE) {
                return Integer.MAX_VALUE;
            }
            if (value < Integer.MIN_VALUE) {
                return Integer.MIN_VALUE;
            }
            return (int) value;
        }


        public static int compare(int a, int b) {
            return (a < b) ? -1 : ((a > b) ? 1 : 0);
        }


        public static boolean contains(int[] array, int target) {
            for (int value : array) {
                if (value == target) {
                    return true;
                }
            }
            return false;
        }

        public static int indexOf(int[] array, int target) {
            return indexOf(array, target, 0, array.length);
        }

        // TODO(kevinb): consider making this public
        private static int indexOf(
                int[] array, int target, int start, int end) {
            for (int i = start; i < end; i++) {
                if (array[i] == target) {
                    return i;
                }
            }
            return -1;
        }


        public static int indexOf(int[] array, int[] target) {
            checkNotNull(array, "array");
            checkNotNull(target, "target");
            if (target.length == 0) {
                return 0;
            }

            outer:
            for (int i = 0; i < array.length - target.length + 1; i++) {
                for (int j = 0; j < target.length; j++) {
                    if (array[i + j] != target[j]) {
                        continue outer;
                    }
                }
                return i;
            }
            return -1;
        }

        public static int lastIndexOf(int[] array, int target) {
            return lastIndexOf(array, target, 0, array.length);
        }

        // TODO(kevinb): consider making this public
        private static int lastIndexOf(
                int[] array, int target, int start, int end) {
            for (int i = end - 1; i >= start; i--) {
                if (array[i] == target) {
                    return i;
                }
            }
            return -1;
        }

        public static int min(int... array) {
            checkArgument(array.length > 0);
            int min = array[0];
            for (int i = 1; i < array.length; i++) {
                if (array[i] < min) {
                    min = array[i];
                }
            }
            return min;
        }


        public static int max(int... array) {
            checkArgument(array.length > 0);
            int max = array[0];
            for (int i = 1; i < array.length; i++) {
                if (array[i] > max) {
                    max = array[i];
                }
            }
            return max;
        }

        public static int[] concat(int[]... arrays) {
            int length = 0;
            for (int[] array : arrays) {
                length += array.length;
            }
            int[] result = new int[length];
            int pos = 0;
            for (int[] array : arrays) {
                System.arraycopy(array, 0, result, pos, array.length);
                pos += array.length;
            }
            return result;
        }


        @GwtIncompatible("doesn't work")
        public static byte[] toByteArray(int value) {
            return new byte[] {
                    (byte) (value >> 24),
                    (byte) (value >> 16),
                    (byte) (value >> 8),
                    (byte) value};
        }

        @GwtIncompatible("doesn't work")
        public static int fromByteArray(byte[] bytes) {
            checkArgument(bytes.length >= BYTES,
                    "array too small: %s < %s", bytes.length, BYTES);
            return fromBytes(bytes[0], bytes[1], bytes[2], bytes[3]);
        }


        @GwtIncompatible("doesn't work")
        public static int fromBytes(byte b1, byte b2, byte b3, byte b4) {
            return b1 << 24 | (b2 & 0xFF) << 16 | (b3 & 0xFF) << 8 | (b4 & 0xFF);
        }

        public static int[] ensureCapacity(
                int[] array, int minLength, int padding) {
            checkArgument(minLength >= 0, "Invalid minLength: %s", minLength);
            checkArgument(padding >= 0, "Invalid padding: %s", padding);
            return (array.length < minLength)
                    ? copyOf(array, minLength + padding)
                    : array;
        }

        // Arrays.copyOf() requires Java 6
        private static int[] copyOf(int[] original, int length) {
            int[] copy = new int[length];
            System.arraycopy(original, 0, copy, 0, Math.min(original.length, length));
            return copy;
        }

        public static String join(String separator, int... array) {
            checkNotNull(separator);
            if (array.length == 0) {
                return "";
            }

            // For pre-sizing a builder, just get the right order of magnitude
            StringBuilder builder = new StringBuilder(array.length * 5);
            builder.append(array[0]);
            for (int i = 1; i < array.length; i++) {
                builder.append(separator).append(array[i]);
            }
            return builder.toString();
        }


        public static Comparator<int[]> lexicographicalComparator() {
            return LexicographicalComparator.INSTANCE;
        }

        private enum LexicographicalComparator implements Comparator<int[]> {
            INSTANCE;

            public int compare(int[] left, int[] right) {
                int minLength = Math.min(left.length, right.length);
                for (int i = 0; i < minLength; i++) {
                    int result = Ints.compare(left[i], right[i]);
                    if (result != 0) {
                        return result;
                    }
                }
                return left.length - right.length;
            }
        }

        public static int[] toArray(Collection<Integer> collection) {
            if (collection instanceof IntArrayAsList) {
                return ((IntArrayAsList) collection).toIntArray();
            }

            Object[] boxedArray = collection.toArray();
            int len = boxedArray.length;
            int[] array = new int[len];
            for (int i = 0; i < len; i++) {
                array[i] = (Integer) boxedArray[i];
            }
            return array;
        }

        public static List<Integer> asList(int... backingArray) {
            if (backingArray.length == 0) {
                return Collections.emptyList();
            }
            return new IntArrayAsList(backingArray);
        }

        @GwtCompatible
        private static class IntArrayAsList extends AbstractList<Integer>
                implements RandomAccess, Serializable {
            final int[] array;
            final int start;
            final int end;

            IntArrayAsList(int[] array) {
                this(array, 0, array.length);
            }

            IntArrayAsList(int[] array, int start, int end) {
                this.array = array;
                this.start = start;
                this.end = end;
            }

            @Override public int size() {
                return end - start;
            }

            @Override public boolean isEmpty() {
                return false;
            }

            @Override public Integer get(int index) {
                checkElementIndex(index, size());
                return array[start + index];
            }

            @Override public boolean contains(Object target) {
                // Overridden to prevent a ton of boxing
                return (target instanceof Integer)
                        && Ints.indexOf(array, (Integer) target, start, end) != -1;
            }

            @Override public int indexOf(Object target) {
                // Overridden to prevent a ton of boxing
                if (target instanceof Integer) {
                    int i = Ints.indexOf(array, (Integer) target, start, end);
                    if (i >= 0) {
                        return i - start;
                    }
                }
                return -1;
            }

            @Override public int lastIndexOf(Object target) {
                // Overridden to prevent a ton of boxing
                if (target instanceof Integer) {
                    int i = Ints.lastIndexOf(array, (Integer) target, start, end);
                    if (i >= 0) {
                        return i - start;
                    }
                }
                return -1;
            }

            @Override public Integer set(int index, Integer element) {
                checkElementIndex(index, size());
                int oldValue = array[start + index];
                array[start + index] = element;
                return oldValue;
            }

            @Override public List<Integer> subList(int fromIndex, int toIndex) {
                int size = size();
                checkPositionIndexes(fromIndex, toIndex, size);
                if (fromIndex == toIndex) {
                    return Collections.emptyList();
                }
                return new IntArrayAsList(array, start + fromIndex, start + toIndex);
            }

            @Override public boolean equals(Object object) {
                if (object == this) {
                    return true;
                }
                if (object instanceof IntArrayAsList) {
                    IntArrayAsList that = (IntArrayAsList) object;
                    int size = size();
                    if (that.size() != size) {
                        return false;
                    }
                    for (int i = 0; i < size; i++) {
                        if (array[start + i] != that.array[that.start + i]) {
                            return false;
                        }
                    }
                    return true;
                }
                return super.equals(object);
            }

            @Override public int hashCode() {
                int result = 1;
                for (int i = start; i < end; i++) {
                    result = 31 * result + Ints.hashCode(array[i]);
                }
                return result;
            }

            @Override public String toString() {
                StringBuilder builder = new StringBuilder(size() * 5);
                builder.append('[').append(array[start]);
                for (int i = start + 1; i < end; i++) {
                    builder.append(", ").append(array[i]);
                }
                return builder.append(']').toString();
            }

            int[] toIntArray() {
                // Arrays.copyOfRange() requires Java 6
                int size = size();
                int[] result = new int[size];
                System.arraycopy(array, start, result, 0, size);
                return result;
            }

            private static final long serialVersionUID = 0;
        }
    }


    public interface Predicate<T> {

        boolean apply(@Nullable T input);

        boolean equals(@Nullable Object object);
    }

    static class Platform {
        private static final Logger logger =
                LoggerFactory.getLogger(Platform.class.getCanonicalName());


        static <T> T[] clone(T[] array) {
            return array.clone();
        }

        static boolean isInstance(Class<?> clazz, @Nullable Object obj) {
            return clazz.isInstance(obj);
        }

        static void unsafeArrayCopy(
                Object[] src, int srcPos, Object[] dest, int destPos, int length) {
            System.arraycopy(src, srcPos, dest, destPos, length);
        }


        @GwtIncompatible("Array.newInstance(Class, int)")
        @SuppressWarnings("unchecked")
        static <T> T[] newArray(Class<T> type, int length) {
            return (T[]) Array.newInstance(type, length);
        }


        static <T> T[] newArray(T[] reference, int length) {
            Class<?> type = reference.getClass().getComponentType();

            // the cast is safe because
            // result.getClass() == reference.getClass().getComponentType()
            @SuppressWarnings("unchecked")
            T[] result = (T[]) Array.newInstance(type, length);
            return result;
        }

        static MapMaker tryWeakKeys(MapMaker mapMaker) {
            return mapMaker.weakKeys();
        }

        private Platform() {}
        static CharMatcher precomputeCharMatcher(CharMatcher matcher) {
            return matcher.precomputedInternal();
        }
    }


    public interface MapEvictionListener<K, V> {

        void onEviction(@Nullable K key, @Nullable V value);
    }

    public static abstract class GenericMapMaker<K0, V0> {
        // Set by MapMaker, but sits in this class to preserve the type relationship
        @GwtIncompatible("To be supported")
        MapEvictionListener<K0, V0> evictionListener;

        // No subclasses but our own
        GenericMapMaker() {}


        public abstract GenericMapMaker<K0, V0> initialCapacity(int initialCapacity);


        public abstract GenericMapMaker<K0, V0> maximumSize(int maximumSize);


        @GwtIncompatible("java.util.concurrent.ConcurrentHashMap concurrencyLevel")
        public abstract GenericMapMaker<K0, V0> concurrencyLevel(
                int concurrencyLevel);

        @GwtIncompatible("java.lang.ref.WeakReference")
        public abstract GenericMapMaker<K0, V0> weakKeys();

        @GwtIncompatible("java.lang.ref.SoftReference")
        public abstract GenericMapMaker<K0, V0> softKeys();


        @GwtIncompatible("java.lang.ref.WeakReference")
        public abstract GenericMapMaker<K0, V0> weakValues();


        @GwtIncompatible("java.lang.ref.SoftReference")
        public abstract GenericMapMaker<K0, V0> softValues();


        public abstract GenericMapMaker<K0, V0> expiration(
                long duration, TimeUnit unit);


        public abstract GenericMapMaker<K0, V0> expireAfterWrite(
                long duration, TimeUnit unit);


        @GwtIncompatible("To be supported")
        public abstract GenericMapMaker<K0, V0> expireAfterAccess(
                long duration, TimeUnit unit);


        public abstract <K extends K0, V extends V0> ConcurrentMap<K, V> makeMap();

        public abstract <K extends K0, V extends V0> ConcurrentMap<K, V>
        makeComputingMap(Function<? super K, ? extends V> computingFunction);
    }

    public interface Ticker {
        long read();
    }

    public interface Equivalence<T> {

        boolean equivalent(@Nullable T a, @Nullable T b);

        int hash(@Nullable T t);
    }

    public static final class Equivalences {
        private Equivalences() {}

        public static Equivalence<Object> equals() {
            return Impl.EQUALS;
        }


        public static Equivalence<Object> identity() {
            return Impl.IDENTITY;
        }

        private enum Impl implements Equivalence<Object> {
            EQUALS {
                @Override
                public boolean equivalent(@Nullable Object a, @Nullable Object b) {
                    // TODO(kevinb): use Objects.equal() after testing issue is worked out.
                    return (a == null) ? (b == null) : a.equals(b);
                }

                @Override
                public int hash(@Nullable Object o) {
                    return (o == null) ? 0 : o.hashCode();
                }
            },
            IDENTITY {
                @Override
                public boolean equivalent(@Nullable Object a, @Nullable Object b) {
                    return a == b;
                }

                @Override
                public int hash(@Nullable Object o) {
                    return System.identityHashCode(o);
                }
            },
        }

        @GwtCompatible(serializable = true)
        public static <T> Equivalence<Iterable<T>> pairwise(Equivalence<? super T> elementEquivalence) {

            return new PairwiseEquivalence<T>(elementEquivalence);
        }
    }

    public static abstract class AbstractLinkedIterator<T>
            extends UnmodifiableIterator<T> {
        private T nextOrNull;


        protected AbstractLinkedIterator(@Nullable T firstOrNull) {
            this.nextOrNull = firstOrNull;
        }


        protected abstract T computeNext(T previous);

        @Override
        public final boolean hasNext() {
            return nextOrNull != null;
        }

        @Override
        public final T next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            try {
                return nextOrNull;
            } finally {
                nextOrNull = computeNext(nextOrNull);
            }
        }
    }

    static final class PairwiseEquivalence<T> implements Equivalence<Iterable<T>>, Serializable {

        final Equivalence<? super T> elementEquivalence;

        PairwiseEquivalence(Equivalence<? super T> elementEquivalence) {
            this.elementEquivalence = Preconditions.checkNotNull(elementEquivalence);
        }

        @Override
        public boolean equivalent(@Nullable Iterable<T> iterableA, @Nullable Iterable<T> iterableB) {
            if (iterableA == null) {
                return iterableB == null;
            } else if (iterableB == null) {
                return false;
            }

            Iterator<T> iteratorA = iterableA.iterator();
            Iterator<T> iteratorB = iterableB.iterator();

            while (iteratorA.hasNext() && iteratorB.hasNext()) {
                if (!elementEquivalence.equivalent(iteratorA.next(), iteratorB.next())) {
                    return false;
                }
            }

            return !iteratorA.hasNext() && !iteratorB.hasNext();
        }

        @Override
        public int hash(@Nullable Iterable<T> iterable) {
            if (iterable == null) {
                return 0;
            }

            int hash = 78721;
            for (T element : iterable) {
                hash = hash * 24943 + elementEquivalence.hash(element);
            }
            return hash;
        }

        @Override
        public boolean equals(@Nullable Object object) {
            if (object instanceof PairwiseEquivalence) {
                PairwiseEquivalence<?> that = (PairwiseEquivalence<?>) object;
                return this.elementEquivalence.equals(that.elementEquivalence);
            }

            return false;
        }

        @Override
        public int hashCode() {
            return elementEquivalence.hashCode() ^ 0x46a3eb07;
        }

        @Override
        public String toString() {
            return "Equivalences.pairwise(" + elementEquivalence + ")";
        }

        private static final long serialVersionUID = 0;
    }

    public interface FinalizableReference {
        void finalizeReferent();
    }

    public static class FinalizableReferenceQueue {


        private static final Logger logger = LoggerFactory.getLogger(FinalizableReferenceQueue.class.getName());

        private static final String FINALIZER_CLASS_NAME = "com.google.common.base.internal.Finalizer";


        private static final Method startFinalizer;
        static {
            Class<?> finalizer = loadFinalizer(
                    new SystemLoader(), new DecoupledLoader(), new DirectLoader());
            startFinalizer = getStartFinalizer(finalizer);
        }


        final ReferenceQueue<Object> queue;

        final boolean threadStarted;

        @SuppressWarnings("unchecked")
        public FinalizableReferenceQueue() {
            // We could start the finalizer lazily, but I'd rather it blow up early.
            ReferenceQueue<Object> queue;
            boolean threadStarted = false;
            try {
                queue = (ReferenceQueue<Object>)
                        startFinalizer.invoke(null, FinalizableReference.class, this);
                threadStarted = true;
            } catch (IllegalAccessException impossible) {
                throw new AssertionError(impossible); // startFinalizer() is public
            } catch (Throwable t) {
                //logger.log(Level.INFO, "Failed to start reference finalizer thread."
                  //      + " Reference cleanup will only occur when new references are created.", t);
                queue = new ReferenceQueue<Object>();
            }

            this.queue = queue;
            this.threadStarted = threadStarted;
        }

        void cleanUp() {
            if (threadStarted) {
                return;
            }

            Reference<?> reference;
            while ((reference = queue.poll()) != null) {

                reference.clear();
                try {
                    ((FinalizableReference) reference).finalizeReferent();
                } catch (Throwable t) {
                    //logger.log(Level.SEVERE, "Error cleaning up after reference.", t);
                }
            }
        }


        private static Class<?> loadFinalizer(FinalizerLoader... loaders) {
            for (FinalizerLoader loader : loaders) {
                Class<?> finalizer = loader.loadFinalizer();
                if (finalizer != null) {
                    return finalizer;
                }
            }

            throw new AssertionError();
        }


        interface FinalizerLoader {


            Class<?> loadFinalizer();
        }

        static class SystemLoader implements FinalizerLoader {
            @Override
            public Class<?> loadFinalizer() {
                ClassLoader systemLoader;
                try {
                    systemLoader = ClassLoader.getSystemClassLoader();
                } catch (SecurityException e) {
                    logger.info("Not allowed to access system class loader.");
                    return null;
                }
                if (systemLoader != null) {
                    try {
                        return systemLoader.loadClass(FINALIZER_CLASS_NAME);
                    } catch (ClassNotFoundException e) {
                        // Ignore. Finalizer is simply in a child class loader.
                        return null;
                    }
                } else {
                    return null;
                }
            }
        }

        static class DecoupledLoader implements FinalizerLoader {
            private static final String LOADING_ERROR = "Could not load Finalizer in its own class loader."
                    + "Loading Finalizer in the current class loader instead. As a result, you will not be able"
                    + "to garbage collect this class loader. To support reclaiming this class loader, either"
                    + "resolve the underlying issue, or move Google Collections to your system class path.";

            @Override
            public Class<?> loadFinalizer() {
                try {

                    ClassLoader finalizerLoader = newLoader(getBaseUrl());
                    return finalizerLoader.loadClass(FINALIZER_CLASS_NAME);
                } catch (Exception e) {
                    //logger.log(Level.WARNING, LOADING_ERROR, e);
                    return null;
                }
            }


            URL getBaseUrl() throws IOException {
                // Find URL pointing to Finalizer.class file.
                String finalizerPath = FINALIZER_CLASS_NAME.replace('.', '/') + ".class";
                URL finalizerUrl = getClass().getClassLoader().getResource(finalizerPath);
                if (finalizerUrl == null) {
                    throw new FileNotFoundException(finalizerPath);
                }

                // Find URL pointing to base of class path.
                String urlString = finalizerUrl.toString();
                if (!urlString.endsWith(finalizerPath)) {
                    throw new IOException("Unsupported path style: " + urlString);
                }
                urlString = urlString.substring(0, urlString.length() - finalizerPath.length());
                return new URL(finalizerUrl, urlString);
            }


            URLClassLoader newLoader(URL base) {
                return new URLClassLoader(new URL[] {base});
            }
        }

        static class DirectLoader implements FinalizerLoader {
            @Override
            public Class<?> loadFinalizer() {
                try {
                    return Class.forName(FINALIZER_CLASS_NAME);
                } catch (ClassNotFoundException e) {
                    throw new AssertionError(e);
                }
            }
        }

        static Method getStartFinalizer(Class<?> finalizer) {
            try {
                return finalizer.getMethod("startFinalizer", Class.class, Object.class);
            } catch (NoSuchMethodException e) {
                throw new AssertionError(e);
            }
        }
    }



    public static abstract class FinalizableWeakReference<T> extends WeakReference<T>
            implements FinalizableReference {

        protected FinalizableWeakReference(T referent, FinalizableReferenceQueue queue) {
            super(referent, queue.queue);
            queue.cleanUp();
        }
    }
    public static abstract class FinalizableSoftReference<T> extends SoftReference<T>
            implements FinalizableReference {

        protected FinalizableSoftReference(T referent, FinalizableReferenceQueue queue) {
            super(referent, queue.queue);
            queue.cleanUp();
        }
    }
    abstract static class AbstractMapEntry<K, V> implements Map.Entry<K, V> {

        @Override
        public abstract K getKey();

        @Override
        public abstract V getValue();

        @Override
        public V setValue(V value) {
            throw new UnsupportedOperationException();
        }

        @Override public boolean equals(@Nullable Object object) {
            if (object instanceof Map.Entry) {
                Map.Entry<?, ?> that = (Map.Entry<?, ?>) object;
                return Objects.equal(this.getKey(), that.getKey())
                        && Objects.equal(this.getValue(), that.getValue());
            }
            return false;
        }

        @Override public int hashCode() {
            K k = getKey();
            V v = getValue();
            return ((k == null) ? 0 : k.hashCode()) ^ ((v == null) ? 0 : v.hashCode());
        }


        @Override public String toString() {
            return getKey() + "=" + getValue();
        }
    }
    final static class Serialization {
        private Serialization() {}


        static int readCount(ObjectInputStream stream) throws IOException {
            return stream.readInt();
        }


        static <K, V> void writeMap(Map<K, V> map, ObjectOutputStream stream)
                throws IOException {
            stream.writeInt(map.size());
            for (Map.Entry<K, V> entry : map.entrySet()) {
                stream.writeObject(entry.getKey());
                stream.writeObject(entry.getValue());
            }
        }


        static <K, V> void populateMap(Map<K, V> map, ObjectInputStream stream)
                throws IOException, ClassNotFoundException {
            int size = stream.readInt();
            populateMap(map, stream, size);
        }


        static <K, V> void populateMap(Map<K, V> map, ObjectInputStream stream,
                                       int size) throws IOException, ClassNotFoundException {
            for (int i = 0; i < size; i++) {
                @SuppressWarnings("unchecked") // reading data stored by writeMap
                        K key = (K) stream.readObject();
                @SuppressWarnings("unchecked") // reading data stored by writeMap
                        V value = (V) stream.readObject();
                map.put(key, value);
            }
        }


        static <E> void writeMultiset(
                Multiset<E> multiset, ObjectOutputStream stream) throws IOException {
            int entryCount = multiset.entrySet().size();
            stream.writeInt(entryCount);
            for (Multiset.Entry<E> entry : multiset.entrySet()) {
                stream.writeObject(entry.getElement());
                stream.writeInt(entry.getCount());
            }
        }


        static <E> void populateMultiset(
                Multiset<E> multiset, ObjectInputStream stream)
                throws IOException, ClassNotFoundException {
            int distinctElements = stream.readInt();
            populateMultiset(multiset, stream, distinctElements);
        }


        static <E> void populateMultiset(
                Multiset<E> multiset, ObjectInputStream stream, int distinctElements)
                throws IOException, ClassNotFoundException {
            for (int i = 0; i < distinctElements; i++) {
                @SuppressWarnings("unchecked") // reading data stored by writeMultiset
                        E element = (E) stream.readObject();
                int count = stream.readInt();
                multiset.add(element, count);
            }
        }


        static <K, V> void writeMultimap(
                Multimap<K, V> multimap, ObjectOutputStream stream) throws IOException {
            stream.writeInt(multimap.asMap().size());
            for (Map.Entry<K, Collection<V>> entry : multimap.asMap().entrySet()) {
                stream.writeObject(entry.getKey());
                stream.writeInt(entry.getValue().size());
                for (V value : entry.getValue()) {
                    stream.writeObject(value);
                }
            }
        }


        static <K, V> void populateMultimap(
                Multimap<K, V> multimap, ObjectInputStream stream)
                throws IOException, ClassNotFoundException {
            int distinctKeys = stream.readInt();
            populateMultimap(multimap, stream, distinctKeys);
        }


        static <K, V> void populateMultimap(
                Multimap<K, V> multimap, ObjectInputStream stream, int distinctKeys)
                throws IOException, ClassNotFoundException {
            for (int i = 0; i < distinctKeys; i++) {
                @SuppressWarnings("unchecked") // reading data stored by writeMultimap
                        K key = (K) stream.readObject();
                Collection<V> values = multimap.get(key);
                int valueCount = stream.readInt();
                for (int j = 0; j < valueCount; j++) {
                    @SuppressWarnings("unchecked") // reading data stored by writeMultimap
                            V value = (V) stream.readObject();
                    values.add(value);
                }
            }
        }

        // Secret sauce for setting final fields; don't make it public.
        static <T> FieldSetter<T> getFieldSetter(
                final Class<T> clazz, String fieldName) {
            try {
                Field field = clazz.getDeclaredField(fieldName);
                return new FieldSetter<T>(field);
            } catch (NoSuchFieldException e) {
                throw new AssertionError(e); // programmer error
            }
        }

        // Secret sauce for setting final fields; don't make it public.
        static final class FieldSetter<T> {
            private final Field field;

            private FieldSetter(Field field) {
                this.field = field;
                field.setAccessible(true);
            }

            void set(T instance, Object value) {
                try {
                    field.set(instance, value);
                } catch (IllegalAccessException impossible) {
                    throw new AssertionError(impossible);
                }
            }

            void set(T instance, int value) {
                try {
                    field.set(instance, value);
                } catch (IllegalAccessException impossible) {
                    throw new AssertionError(impossible);
                }
            }
        }
    }
    static class CustomConcurrentHashMap<K, V> extends AbstractMap<K, V>
            implements ConcurrentMap<K, V>, Serializable {

        static final int MAXIMUM_CAPACITY = 1 << 30;

        static final int MAX_SEGMENTS = 1 << 16; // slightly conservative

        static final int DRAIN_THRESHOLD = 0x3F;

        static final int CLEANUP_MAX = 16;

        final transient int segmentMask;

        final transient int segmentShift;

        final transient Segment[] segments;

        final int concurrencyLevel;

        final Equivalence<Object> keyEquivalence;


        final Equivalence<Object> valueEquivalence;


        final Strength keyStrength;


        final Strength valueStrength;

        final int maximumSize;


        final long expireAfterAccessNanos;

        final long expireAfterWriteNanos;


        final Queue<ReferenceEntry<K, V>> evictionNotificationQueue;

        final MapEvictionListener<? super K, ? super V> evictionListener;


        final transient EntryFactory entryFactory;


        final Executor cleanupExecutor;


        final Ticker ticker;


        CustomConcurrentHashMap(MapMaker builder) {
            concurrencyLevel = Math.min(builder.getConcurrencyLevel(), MAX_SEGMENTS);

            keyStrength = builder.getKeyStrength();
            valueStrength = builder.getValueStrength();

            keyEquivalence = builder.getKeyEquivalence();
            valueEquivalence = builder.getValueEquivalence();

            maximumSize = builder.maximumSize;
            expireAfterAccessNanos = builder.getExpireAfterAccessNanos();
            expireAfterWriteNanos = builder.getExpireAfterWriteNanos();

            entryFactory =
                    EntryFactory.getFactory(keyStrength, expires(), evictsBySize());
            cleanupExecutor = builder.getCleanupExecutor();
            ticker = builder.getTicker();

            evictionListener = builder.getEvictionListener();
            evictionNotificationQueue = (evictionListener == MahoutRecommender.MapMaker.NullListener.INSTANCE)
                    ? CustomConcurrentHashMap.<ReferenceEntry<K, V>>discardingQueue()
                    : new ConcurrentLinkedQueue<ReferenceEntry<K, V>>();

            int initialCapacity =
                    Math.min(builder.getInitialCapacity(), MAXIMUM_CAPACITY);
            if (evictsBySize()) {
                initialCapacity = Math.min(initialCapacity, maximumSize);
            }

            // Find power-of-two sizes best matching arguments. Constraints:
            // (segmentCount <= maximumSize)
            // && (concurrencyLevel > maximumSize || segmentCount > concurrencyLevel)
            int segmentShift = 0;
            int segmentCount = 1;
            while (segmentCount < concurrencyLevel
                    && (!evictsBySize() || segmentCount * 2 <= maximumSize)) {
                ++segmentShift;
                segmentCount <<= 1;
            }
            this.segmentShift = 32 - segmentShift;
            segmentMask = segmentCount - 1;

            this.segments = newSegmentArray(segmentCount);

            int segmentCapacity = initialCapacity / segmentCount;
            if (segmentCapacity * segmentCount < initialCapacity) {
                ++segmentCapacity;
            }

            int segmentSize = 1;
            while (segmentSize < segmentCapacity) {
                segmentSize <<= 1;
            }

            if (evictsBySize()) {
                // Ensure sum of segment max sizes = overall max size
                int maximumSegmentSize = maximumSize / segmentCount + 1;
                int remainder = maximumSize % segmentCount;
                for (int i = 0; i < this.segments.length; ++i) {
                    if (i == remainder) {
                        maximumSegmentSize--;
                    }
                    this.segments[i] = createSegment(segmentSize, maximumSegmentSize);
                }
            } else {
                for (int i = 0; i < this.segments.length; ++i) {
                    this.segments[i] = createSegment(segmentSize,
                            MapMaker.UNSET_INT);
                }
            }
        }

        boolean evictsBySize() {
            return maximumSize != MapMaker.UNSET_INT;
        }

        boolean expires() {
            return expiresAfterWrite() || expiresAfterAccess();
        }

        boolean expiresAfterWrite() {
            return expireAfterWriteNanos > 0;
        }

        boolean expiresAfterAccess() {
            return expireAfterAccessNanos > 0;
        }

        boolean isInlineCleanup() {
            return cleanupExecutor == MapMaker.DEFAULT_CLEANUP_EXECUTOR;
        }

        enum Strength {

            STRONG {
                @Override <K, V> ValueReference<K, V> referenceValue(
                        ReferenceEntry<K, V> entry, V value) {
                    return new StrongValueReference<K, V>(value);
                }
                @Override Equivalence<Object> defaultEquivalence() {
                    return Equivalences.equals();
                }
            },

            SOFT {
                @Override <K, V> ValueReference<K, V> referenceValue(
                        ReferenceEntry<K, V> entry, V value) {
                    return new SoftValueReference<K, V>(value, entry);
                }
                @Override Equivalence<Object> defaultEquivalence() {
                    return Equivalences.identity();
                }
            },

            WEAK {
                @Override <K, V> ValueReference<K, V> referenceValue(
                        ReferenceEntry<K, V> entry, V value) {
                    return new WeakValueReference<K, V>(value, entry);
                }
                @Override Equivalence<Object> defaultEquivalence() {
                    return Equivalences.identity();
                }
            };


            abstract <K, V> ValueReference<K, V> referenceValue(
                    ReferenceEntry<K, V> entry, V value);


            abstract Equivalence<Object> defaultEquivalence();
        }

        enum EntryFactory {
            STRONG {
                @Override <K, V> ReferenceEntry<K, V> newEntry(
                        CustomConcurrentHashMap<K, V> map, K key, int hash,
                        @Nullable ReferenceEntry<K, V> next) {
                    return new StrongEntry<K, V>(map, key, hash, next);
                }
            },
            STRONG_EXPIRABLE {
                @Override <K, V> ReferenceEntry<K, V> newEntry(
                        CustomConcurrentHashMap<K, V> map, K key, int hash,
                        @Nullable ReferenceEntry<K, V> next) {
                    return new StrongExpirableEntry<K, V>(map, key, hash, next);
                }
                @Override <K, V> ReferenceEntry<K, V> copyEntry(
                        CustomConcurrentHashMap<K, V> map,
                        ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
                    ReferenceEntry<K, V> newEntry = super.copyEntry(map, original, newNext);
                    copyExpirableEntry(original, newEntry);
                    return newEntry;
                }
            },
            STRONG_EVICTABLE {
                @Override <K, V> ReferenceEntry<K, V> newEntry(
                        CustomConcurrentHashMap<K, V> map, K key, int hash,
                        @Nullable ReferenceEntry<K, V> next) {
                    return new StrongEvictableEntry<K, V>(map, key, hash, next);
                }
                @Override <K, V> ReferenceEntry<K, V> copyEntry(
                        CustomConcurrentHashMap<K, V> map,
                        ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
                    ReferenceEntry<K, V> newEntry = super.copyEntry(map, original, newNext);
                    copyEvictableEntry(original, newEntry);
                    return newEntry;
                }
            },
            STRONG_EXPIRABLE_EVICTABLE {
                @Override <K, V> ReferenceEntry<K, V> newEntry(
                        CustomConcurrentHashMap<K, V> map, K key, int hash,
                        @Nullable ReferenceEntry<K, V> next) {
                    return new StrongExpirableEvictableEntry<K, V>(map, key, hash, next);
                }
                @Override <K, V> ReferenceEntry<K, V> copyEntry(
                        CustomConcurrentHashMap<K, V> map,
                        ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
                    ReferenceEntry<K, V> newEntry = super.copyEntry(map, original, newNext);
                    copyExpirableEntry(original, newEntry);
                    copyEvictableEntry(original, newEntry);
                    return newEntry;
                }
            },

            SOFT {
                @Override <K, V> ReferenceEntry<K, V> newEntry(
                        CustomConcurrentHashMap<K, V> map, K key, int hash,
                        @Nullable ReferenceEntry<K, V> next) {
                    return new SoftEntry<K, V>(map, key, hash, next);
                }
            },
            SOFT_EXPIRABLE {
                @Override <K, V> ReferenceEntry<K, V> newEntry(
                        CustomConcurrentHashMap<K, V> map, K key, int hash,
                        @Nullable ReferenceEntry<K, V> next) {
                    return new SoftExpirableEntry<K, V>(map, key, hash, next);
                }
                @Override <K, V> ReferenceEntry<K, V> copyEntry(
                        CustomConcurrentHashMap<K, V> map,
                        ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
                    ReferenceEntry<K, V> newEntry = super.copyEntry(map, original, newNext);
                    copyExpirableEntry(original, newEntry);
                    return newEntry;
                }
            },
            SOFT_EVICTABLE {
                @Override <K, V> ReferenceEntry<K, V> newEntry(
                        CustomConcurrentHashMap<K, V> map, K key, int hash,
                        @Nullable ReferenceEntry<K, V> next) {
                    return new SoftEvictableEntry<K, V>(map, key, hash, next);
                }
                @Override <K, V> ReferenceEntry<K, V> copyEntry(
                        CustomConcurrentHashMap<K, V> map,
                        ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
                    ReferenceEntry<K, V> newEntry = super.copyEntry(map, original, newNext);
                    copyEvictableEntry(original, newEntry);
                    return newEntry;
                }
            },
            SOFT_EXPIRABLE_EVICTABLE {
                @Override <K, V> ReferenceEntry<K, V> newEntry(
                        CustomConcurrentHashMap<K, V> map, K key, int hash,
                        @Nullable ReferenceEntry<K, V> next) {
                    return new SoftExpirableEvictableEntry<K, V>(map, key, hash, next);
                }
                @Override <K, V> ReferenceEntry<K, V> copyEntry(
                        CustomConcurrentHashMap<K, V> map,
                        ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
                    ReferenceEntry<K, V> newEntry = super.copyEntry(map, original, newNext);
                    copyExpirableEntry(original, newEntry);
                    copyEvictableEntry(original, newEntry);
                    return newEntry;
                }
            },

            WEAK {
                @Override <K, V> ReferenceEntry<K, V> newEntry(
                        CustomConcurrentHashMap<K, V> map, K key, int hash,
                        @Nullable ReferenceEntry<K, V> next) {
                    return new WeakEntry<K, V>(map, key, hash, next);
                }
            },
            WEAK_EXPIRABLE {
                @Override <K, V> ReferenceEntry<K, V> newEntry(
                        CustomConcurrentHashMap<K, V> map, K key, int hash,
                        @Nullable ReferenceEntry<K, V> next) {
                    return new WeakExpirableEntry<K, V>(map, key, hash, next);
                }
                @Override <K, V> ReferenceEntry<K, V> copyEntry(
                        CustomConcurrentHashMap<K, V> map,
                        ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
                    ReferenceEntry<K, V> newEntry = super.copyEntry(map, original, newNext);
                    copyExpirableEntry(original, newEntry);
                    return newEntry;
                }
            },
            WEAK_EVICTABLE {
                @Override <K, V> ReferenceEntry<K, V> newEntry(
                        CustomConcurrentHashMap<K, V> map, K key, int hash,
                        @Nullable ReferenceEntry<K, V> next) {
                    return new WeakEvictableEntry<K, V>(map, key, hash, next);
                }
                @Override <K, V> ReferenceEntry<K, V> copyEntry(
                        CustomConcurrentHashMap<K, V> map,
                        ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
                    ReferenceEntry<K, V> newEntry = super.copyEntry(map, original, newNext);
                    copyEvictableEntry(original, newEntry);
                    return newEntry;
                }
            },
            WEAK_EXPIRABLE_EVICTABLE {
                @Override <K, V> ReferenceEntry<K, V> newEntry(
                        CustomConcurrentHashMap<K, V> map, K key, int hash,
                        @Nullable ReferenceEntry<K, V> next) {
                    return new WeakExpirableEvictableEntry<K, V>(map, key, hash, next);
                }
                @Override <K, V> ReferenceEntry<K, V> copyEntry(
                        CustomConcurrentHashMap<K, V> map,
                        ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
                    ReferenceEntry<K, V> newEntry = super.copyEntry(map, original, newNext);
                    copyExpirableEntry(original, newEntry);
                    copyEvictableEntry(original, newEntry);
                    return newEntry;
                }
            };


            static final int EXPIRABLE_MASK = 1;
            static final int EVICTABLE_MASK = 2;


            static final EntryFactory[][] factories = {
                    { STRONG, STRONG_EXPIRABLE, STRONG_EVICTABLE, STRONG_EXPIRABLE_EVICTABLE },
                    { SOFT,   SOFT_EXPIRABLE,   SOFT_EVICTABLE,   SOFT_EXPIRABLE_EVICTABLE   },
                    { WEAK,   WEAK_EXPIRABLE,   WEAK_EVICTABLE,   WEAK_EXPIRABLE_EVICTABLE   }
            };

            static EntryFactory getFactory(Strength keyStrength,
                                           boolean expireAfterWrite, boolean evictsBySize) {
                int flags = (expireAfterWrite ? EXPIRABLE_MASK : 0)
                        | (evictsBySize ? EVICTABLE_MASK : 0);
                return factories[keyStrength.ordinal()][flags];
            }


            abstract <K, V> ReferenceEntry<K, V> newEntry(
                    CustomConcurrentHashMap<K, V> map, K key, int hash,
                    @Nullable ReferenceEntry<K, V> next);



            <K, V> ReferenceEntry<K, V> copyEntry(
                    CustomConcurrentHashMap<K, V> map,
                    ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
                return newEntry(map, original.getKey(), original.getHash(), newNext);
            }


            <K, V> void copyExpirableEntry(
                    ReferenceEntry<K, V> original, ReferenceEntry<K, V> newEntry) {
                // TODO(user): when we link values instead of entries this method can go
                // away, as can connectExpirables, nullifyExpirable.
                newEntry.setExpirationTime(original.getExpirationTime());

                connectExpirables(original.getPreviousExpirable(), newEntry);
                connectExpirables(newEntry, original.getNextExpirable());

                nullifyExpirable(original);
            }


            <K, V> void copyEvictableEntry(
                    ReferenceEntry<K, V> original, ReferenceEntry<K, V> newEntry) {
                // TODO(user): when we link values instead of entries this method can go
                // away, as can connectEvictables, nullifyEvictable.
                connectEvictables(original.getPreviousEvictable(), newEntry);
                connectEvictables(newEntry, original.getNextEvictable());

                nullifyEvictable(original);
            }
        }


        interface ValueReference<K, V> {

            V get();


            ValueReference<K, V> copyFor(ReferenceEntry<K, V> entry);

            V waitForValue() throws InterruptedException;


            void clear();


            boolean isComputingReference();

            void notifyValueReclaimed();
        }

        static final ValueReference<Object, Object> UNSET
                = new ValueReference<Object, Object>() {
            @Override
            public Object get() {
                return null;
            }
            @Override
            public ValueReference<Object, Object> copyFor(
                    ReferenceEntry<Object, Object> entry) {
                return this;
            }
            @Override
            public boolean isComputingReference() {
                return false;
            }
            @Override
            public Object waitForValue() {
                return null;
            }
            @Override
            public void notifyValueReclaimed() {}
            @Override
            public void clear() {}
        };


        @SuppressWarnings("unchecked")
        // Safe because impl never uses a parameter or returns any non-null value
        static <K, V> ValueReference<K, V> unset() {
            return (ValueReference<K, V>) UNSET;
        }


        private static class QueueHolder {
            static final FinalizableReferenceQueue queue
                    = new FinalizableReferenceQueue();
        }

        interface ReferenceEntry<K, V> {

            ValueReference<K, V> getValueReference();


            void setValueReference(ValueReference<K, V> valueReference);


            void notifyKeyReclaimed();


            void notifyValueReclaimed(ValueReference<K, V> valueReference);

            ReferenceEntry<K, V> getNext();

            int getHash();

            K getKey();


            long getExpirationTime();

            void setExpirationTime(long time);

            ReferenceEntry<K, V> getNextExpirable();

            void setNextExpirable(ReferenceEntry<K, V> next);

            ReferenceEntry<K, V> getPreviousExpirable();

            void setPreviousExpirable(ReferenceEntry<K, V> previous);


            ReferenceEntry<K, V> getNextEvictable();

            void setNextEvictable(ReferenceEntry<K, V> next);

            ReferenceEntry<K, V> getPreviousEvictable();

            void setPreviousEvictable(ReferenceEntry<K, V> previous);
        }

        private enum NullEntry implements ReferenceEntry<Object, Object> {
            INSTANCE;

            @Override
            public ValueReference<Object, Object> getValueReference() {
                return null;
            }
            @Override
            public void setValueReference(
                    ValueReference<Object, Object> valueReference) {}
            @Override
            public void notifyKeyReclaimed() {}
            @Override
            public void notifyValueReclaimed(ValueReference<Object, Object> v) {}
            @Override
            public ReferenceEntry<Object, Object> getNext() {
                return null;
            }
            @Override
            public int getHash() {
                return 0;
            }
            @Override
            public Object getKey() {
                return null;
            }

            @Override
            public long getExpirationTime() {
                return 0;
            }
            @Override
            public void setExpirationTime(long time) {}
            @Override
            public ReferenceEntry<Object, Object> getNextExpirable() {
                return this;
            }
            @Override
            public void setNextExpirable(ReferenceEntry<Object, Object> next) {}

            @Override
            public ReferenceEntry<Object, Object> getPreviousExpirable() {
                return this;
            }
            @Override
            public void setPreviousExpirable(ReferenceEntry<Object, Object> previous) {}

            @Override
            public ReferenceEntry<Object, Object> getNextEvictable() {
                return this;
            }
            @Override
            public void setNextEvictable(ReferenceEntry<Object, Object> next) {}

            @Override
            public ReferenceEntry<Object, Object> getPreviousEvictable() {
                return this;
            }
            @Override
            public void setPreviousEvictable(ReferenceEntry<Object, Object> previous) {}
        }

        @SuppressWarnings("unchecked")
        // Safe because impl never uses a parameter or returns any non-null value
        static <K, V> ReferenceEntry<K, V> nullEntry() {
            return (ReferenceEntry<K, V>) NullEntry.INSTANCE;
        }

        static final Queue<? extends ReferenceEntry<?, ?>> DISCARDING_QUEUE =
                new AbstractQueue<ReferenceEntry<?, ?>>() {
                    @Override
                    public boolean offer(ReferenceEntry<?, ?> o) {
                        return true;
                    }

                    @Override
                    public ReferenceEntry<?, ?> peek() {
                        return null;
                    }

                    @Override
                    public ReferenceEntry<?, ?> poll() {
                        return null;
                    }

                    @Override
                    public int size() {
                        return 0;
                    }

                    @Override
                    public Iterator<ReferenceEntry<?, ?>> iterator() {
                        return Iterators.emptyIterator();
                    }
                };

        @SuppressWarnings("unchecked")
        // Safe because impl never uses a parameter or returns any non-null value
        static <E> Queue<E> discardingQueue() {
            return (Queue<E>) DISCARDING_QUEUE;
        }


        private static class StrongEntry<K, V> implements ReferenceEntry<K, V> {
            final K key;

            StrongEntry(CustomConcurrentHashMap<K, V> map, K key, int hash,
                        @Nullable ReferenceEntry<K, V> next) {
                this.map = map;
                this.key = key;
                this.hash = hash;
                this.next = next;
            }

            @Override
            public K getKey() {
                return this.key;
            }

            @Override
            public void notifyKeyReclaimed() {}

            // null expiration
            @Override
            public long getExpirationTime() {
                throw new UnsupportedOperationException();
            }
            @Override
            public void setExpirationTime(long time) {
                throw new UnsupportedOperationException();
            }

            @Override
            public ReferenceEntry<K, V> getNextExpirable() {
                throw new UnsupportedOperationException();
            }
            @Override
            public void setNextExpirable(ReferenceEntry<K, V> next) {
                throw new UnsupportedOperationException();
            }

            @Override
            public ReferenceEntry<K, V> getPreviousExpirable() {
                throw new UnsupportedOperationException();
            }
            @Override
            public void setPreviousExpirable(ReferenceEntry<K, V> previous) {
                throw new UnsupportedOperationException();
            }

            // null eviction
            @Override
            public ReferenceEntry<K, V> getNextEvictable() {
                throw new UnsupportedOperationException();
            }
            @Override
            public void setNextEvictable(ReferenceEntry<K, V> next) {
                throw new UnsupportedOperationException();
            }

            @Override
            public ReferenceEntry<K, V> getPreviousEvictable() {
                throw new UnsupportedOperationException();
            }
            @Override
            public void setPreviousEvictable(ReferenceEntry<K, V> previous) {
                throw new UnsupportedOperationException();
            }

            // The code below is exactly the same for each entry type.

            final CustomConcurrentHashMap<K, V> map;
            final int hash;
            final ReferenceEntry<K, V> next;
            volatile ValueReference<K, V> valueReference = unset();

            @Override
            public ValueReference<K, V> getValueReference() {
                return valueReference;
            }
            @Override
            public void setValueReference(ValueReference<K, V> valueReference) {
                ValueReference<K, V> previous = this.valueReference;
                this.valueReference = valueReference;
                previous.clear();
            }
            @Override
            public void notifyValueReclaimed(ValueReference<K, V> v) {
                map.reclaimValue(this, v);
            }
            @Override
            public int getHash() {
                return hash;
            }
            @Override
            public ReferenceEntry<K, V> getNext() {
                return next;
            }
        }

        private static class StrongExpirableEntry<K, V> extends StrongEntry<K, V>
                implements ReferenceEntry<K, V> {
            StrongExpirableEntry(CustomConcurrentHashMap<K, V> map, K key, int hash,
                                 @Nullable ReferenceEntry<K, V> next) {
                super(map, key, hash, next);
            }

            // The code below is exactly the same for each expirable entry type.

            volatile long time = Long.MAX_VALUE;
            @Override
            public long getExpirationTime() {
                return time;
            }
            @Override
            public void setExpirationTime(long time) {
                this.time = time;
            }

            ReferenceEntry<K, V> nextExpirable = nullEntry();
            @Override
            public ReferenceEntry<K, V> getNextExpirable() {
                return nextExpirable;
            }
            @Override
            public void setNextExpirable(ReferenceEntry<K, V> next) {
                this.nextExpirable = next;
            }

            ReferenceEntry<K, V> previousExpirable = nullEntry();
            @Override
            public ReferenceEntry<K, V> getPreviousExpirable() {
                return previousExpirable;
            }
            @Override
            public void setPreviousExpirable(ReferenceEntry<K, V> previous) {
                this.previousExpirable = previous;
            }
        }

        private static class StrongEvictableEntry<K, V> extends StrongEntry<K, V>
                implements ReferenceEntry<K, V> {
            StrongEvictableEntry(CustomConcurrentHashMap<K, V> map, K key, int hash,
                                 @Nullable ReferenceEntry<K, V> next) {
                super(map, key, hash, next);
            }

            ReferenceEntry<K, V> nextEvictable = nullEntry();
            @Override
            public ReferenceEntry<K, V> getNextEvictable() {
                return nextEvictable;
            }
            @Override
            public void setNextEvictable(ReferenceEntry<K, V> next) {
                this.nextEvictable = next;
            }

            ReferenceEntry<K, V> previousEvictable = nullEntry();
            @Override
            public ReferenceEntry<K, V> getPreviousEvictable() {
                return previousEvictable;
            }
            @Override
            public void setPreviousEvictable(ReferenceEntry<K, V> previous) {
                this.previousEvictable = previous;
            }
        }

        private static class StrongExpirableEvictableEntry<K, V>
                extends StrongEntry<K, V> implements ReferenceEntry<K, V> {
            StrongExpirableEvictableEntry(CustomConcurrentHashMap<K, V> map, K key,
                                          int hash, @Nullable ReferenceEntry<K, V> next) {
                super(map, key, hash, next);
            }

            // The code below is exactly the same for each expirable entry type.

            volatile long time = Long.MAX_VALUE;
            @Override
            public long getExpirationTime() {
                return time;
            }
            @Override
            public void setExpirationTime(long time) {
                this.time = time;
            }

            ReferenceEntry<K, V> nextExpirable = nullEntry();
            @Override
            public ReferenceEntry<K, V> getNextExpirable() {
                return nextExpirable;
            }
            @Override
            public void setNextExpirable(ReferenceEntry<K, V> next) {
                this.nextExpirable = next;
            }

            ReferenceEntry<K, V> previousExpirable = nullEntry();
            @Override
            public ReferenceEntry<K, V> getPreviousExpirable() {
                return previousExpirable;
            }
            @Override
            public void setPreviousExpirable(ReferenceEntry<K, V> previous) {
                this.previousExpirable = previous;
            }

            // The code below is exactly the same for each evictable entry type.

            ReferenceEntry<K, V> nextEvictable = nullEntry();
            @Override
            public ReferenceEntry<K, V> getNextEvictable() {
                return nextEvictable;
            }
            @Override
            public void setNextEvictable(ReferenceEntry<K, V> next) {
                this.nextEvictable = next;
            }

            ReferenceEntry<K, V> previousEvictable = nullEntry();
            @Override
            public ReferenceEntry<K, V> getPreviousEvictable() {
                return previousEvictable;
            }
            @Override
            public void setPreviousEvictable(ReferenceEntry<K, V> previous) {
                this.previousEvictable = previous;
            }
        }


        private static class SoftEntry<K, V> extends FinalizableSoftReference<K>
                implements ReferenceEntry<K, V> {
            SoftEntry(CustomConcurrentHashMap<K, V> map, K key, int hash,
                      @Nullable ReferenceEntry<K, V> next) {
                super(key, QueueHolder.queue);
                this.map = map;
                this.hash = hash;
                this.next = next;
            }

            @Override
            public K getKey() {
                return get();
            }

            @Override
            public void finalizeReferent() {
                notifyKeyReclaimed();
            }

            @Override
            public void notifyKeyReclaimed() {
                map.reclaimKey(this);
            }

            // null expiration
            @Override
            public long getExpirationTime() {
                throw new UnsupportedOperationException();
            }
            @Override
            public void setExpirationTime(long time) {
                throw new UnsupportedOperationException();
            }

            @Override
            public ReferenceEntry<K, V> getNextExpirable() {
                throw new UnsupportedOperationException();
            }
            @Override
            public void setNextExpirable(ReferenceEntry<K, V> next) {
                throw new UnsupportedOperationException();
            }

            @Override
            public ReferenceEntry<K, V> getPreviousExpirable() {
                throw new UnsupportedOperationException();
            }
            @Override
            public void setPreviousExpirable(ReferenceEntry<K, V> previous) {
                throw new UnsupportedOperationException();
            }

            // null eviction
            @Override
            public ReferenceEntry<K, V> getNextEvictable() {
                throw new UnsupportedOperationException();
            }
            @Override
            public void setNextEvictable(ReferenceEntry<K, V> next) {
                throw new UnsupportedOperationException();
            }

            @Override
            public ReferenceEntry<K, V> getPreviousEvictable() {
                throw new UnsupportedOperationException();
            }
            @Override
            public void setPreviousEvictable(ReferenceEntry<K, V> previous) {
                throw new UnsupportedOperationException();
            }

            // The code below is exactly the same for each entry type.

            final CustomConcurrentHashMap<K, V> map;
            final int hash;
            final ReferenceEntry<K, V> next;
            volatile ValueReference<K, V> valueReference = unset();

            @Override
            public ValueReference<K, V> getValueReference() {
                return valueReference;
            }
            @Override
            public void setValueReference(ValueReference<K, V> valueReference) {
                ValueReference<K, V> previous = this.valueReference;
                this.valueReference = valueReference;
                previous.clear();
            }
            @Override
            public void notifyValueReclaimed(ValueReference<K, V> v) {
                map.reclaimValue(this, v);
            }
            @Override
            public int getHash() {
                return hash;
            }
            @Override
            public ReferenceEntry<K, V> getNext() {
                return next;
            }
        }

        private static class SoftExpirableEntry<K, V> extends SoftEntry<K, V>
                implements ReferenceEntry<K, V> {
            SoftExpirableEntry(CustomConcurrentHashMap<K, V> map, K key, int hash,
                               @Nullable ReferenceEntry<K, V> next) {
                super(map, key, hash, next);
            }

            // The code below is exactly the same for each expirable entry type.

            volatile long time = Long.MAX_VALUE;
            @Override
            public long getExpirationTime() {
                return time;
            }
            @Override
            public void setExpirationTime(long time) {
                this.time = time;
            }

            ReferenceEntry<K, V> nextExpirable = nullEntry();
            @Override
            public ReferenceEntry<K, V> getNextExpirable() {
                return nextExpirable;
            }
            @Override
            public void setNextExpirable(ReferenceEntry<K, V> next) {
                this.nextExpirable = next;
            }


            ReferenceEntry<K, V> previousExpirable = nullEntry();
            @Override
            public ReferenceEntry<K, V> getPreviousExpirable() {
                return previousExpirable;
            }
            @Override
            public void setPreviousExpirable(ReferenceEntry<K, V> previous) {
                this.previousExpirable = previous;
            }
        }

        private static class SoftEvictableEntry<K, V> extends SoftEntry<K, V>
                implements ReferenceEntry<K, V> {
            SoftEvictableEntry(CustomConcurrentHashMap<K, V> map, K key, int hash,
                               @Nullable ReferenceEntry<K, V> next) {
                super(map, key, hash, next);
            }

            // The code below is exactly the same for each evictable entry type.

            ReferenceEntry<K, V> nextEvictable = nullEntry();
            @Override
            public ReferenceEntry<K, V> getNextEvictable() {
                return nextEvictable;
            }
            @Override
            public void setNextEvictable(ReferenceEntry<K, V> next) {
                this.nextEvictable = next;
            }

            ReferenceEntry<K, V> previousEvictable = nullEntry();
            @Override
            public ReferenceEntry<K, V> getPreviousEvictable() {
                return previousEvictable;
            }
            @Override
            public void setPreviousEvictable(ReferenceEntry<K, V> previous) {
                this.previousEvictable = previous;
            }
        }

        private static class SoftExpirableEvictableEntry<K, V>
                extends SoftEntry<K, V> implements ReferenceEntry<K, V> {
            SoftExpirableEvictableEntry(CustomConcurrentHashMap<K, V> map, K key,
                                        int hash, @Nullable ReferenceEntry<K, V> next) {
                super(map, key, hash, next);
            }

            // The code below is exactly the same for each expirable entry type.

            volatile long time = Long.MAX_VALUE;
            @Override
            public long getExpirationTime() {
                return time;
            }
            @Override
            public void setExpirationTime(long time) {
                this.time = time;
            }

            ReferenceEntry<K, V> nextExpirable = nullEntry();
            @Override
            public ReferenceEntry<K, V> getNextExpirable() {
                return nextExpirable;
            }
            @Override
            public void setNextExpirable(ReferenceEntry<K, V> next) {
                this.nextExpirable = next;
            }

            ReferenceEntry<K, V> previousExpirable = nullEntry();
            @Override
            public ReferenceEntry<K, V> getPreviousExpirable() {
                return previousExpirable;
            }
            @Override
            public void setPreviousExpirable(ReferenceEntry<K, V> previous) {
                this.previousExpirable = previous;
            }

            // The code below is exactly the same for each evictable entry type.

            ReferenceEntry<K, V> nextEvictable = nullEntry();
            @Override
            public ReferenceEntry<K, V> getNextEvictable() {
                return nextEvictable;
            }
            @Override
            public void setNextEvictable(ReferenceEntry<K, V> next) {
                this.nextEvictable = next;
            }


            ReferenceEntry<K, V> previousEvictable = nullEntry();
            @Override
            public ReferenceEntry<K, V> getPreviousEvictable() {
                return previousEvictable;
            }
            @Override
            public void setPreviousEvictable(ReferenceEntry<K, V> previous) {
                this.previousEvictable = previous;
            }
        }

        private static class WeakEntry<K, V> extends FinalizableWeakReference<K>
                implements ReferenceEntry<K, V> {
            WeakEntry(CustomConcurrentHashMap<K, V> map, K key, int hash,
                      @Nullable ReferenceEntry<K, V> next) {
                super(key, QueueHolder.queue);
                this.map = map;
                this.hash = hash;
                this.next = next;
            }

            @Override
            public K getKey() {
                return get();
            }

            @Override
            public void finalizeReferent() {
                notifyKeyReclaimed();
            }

            @Override
            public void notifyKeyReclaimed() {
                map.reclaimKey(this);
            }

            // null expiration
            @Override
            public long getExpirationTime() {
                throw new UnsupportedOperationException();
            }
            @Override
            public void setExpirationTime(long time) {
                throw new UnsupportedOperationException();
            }

            @Override
            public ReferenceEntry<K, V> getNextExpirable() {
                throw new UnsupportedOperationException();
            }
            @Override
            public void setNextExpirable(ReferenceEntry<K, V> next) {
                throw new UnsupportedOperationException();
            }

            @Override
            public ReferenceEntry<K, V> getPreviousExpirable() {
                throw new UnsupportedOperationException();
            }
            @Override
            public void setPreviousExpirable(ReferenceEntry<K, V> previous) {
                throw new UnsupportedOperationException();
            }

            // null eviction
            @Override
            public ReferenceEntry<K, V> getNextEvictable() {
                throw new UnsupportedOperationException();
            }
            @Override
            public void setNextEvictable(ReferenceEntry<K, V> next) {
                throw new UnsupportedOperationException();
            }

            @Override
            public ReferenceEntry<K, V> getPreviousEvictable() {
                throw new UnsupportedOperationException();
            }
            @Override
            public void setPreviousEvictable(ReferenceEntry<K, V> previous) {
                throw new UnsupportedOperationException();
            }

            // The code below is exactly the same for each entry type.

            final CustomConcurrentHashMap<K, V> map;
            final int hash;
            final ReferenceEntry<K, V> next;
            volatile ValueReference<K, V> valueReference = unset();

            @Override
            public ValueReference<K, V> getValueReference() {
                return valueReference;
            }
            @Override
            public void setValueReference(ValueReference<K, V> valueReference) {
                ValueReference<K, V> previous = this.valueReference;
                this.valueReference = valueReference;
                previous.clear();
            }
            @Override
            public void notifyValueReclaimed(ValueReference<K, V> v) {
                map.reclaimValue(this, v);
            }
            @Override
            public int getHash() {
                return hash;
            }
            @Override
            public ReferenceEntry<K, V> getNext() {
                return next;
            }
        }

        private static class WeakExpirableEntry<K, V> extends WeakEntry<K, V>
                implements ReferenceEntry<K, V> {
            WeakExpirableEntry(CustomConcurrentHashMap<K, V> map, K key, int hash,
                               @Nullable ReferenceEntry<K, V> next) {
                super(map, key, hash, next);
            }

            // The code below is exactly the same for each expirable entry type.

            volatile long time = Long.MAX_VALUE;
            @Override
            public long getExpirationTime() {
                return time;
            }
            @Override
            public void setExpirationTime(long time) {
                this.time = time;
            }


            ReferenceEntry<K, V> nextExpirable = nullEntry();
            @Override
            public ReferenceEntry<K, V> getNextExpirable() {
                return nextExpirable;
            }
            @Override
            public void setNextExpirable(ReferenceEntry<K, V> next) {
                this.nextExpirable = next;
            }

            ReferenceEntry<K, V> previousExpirable = nullEntry();
            @Override
            public ReferenceEntry<K, V> getPreviousExpirable() {
                return previousExpirable;
            }
            @Override
            public void setPreviousExpirable(ReferenceEntry<K, V> previous) {
                this.previousExpirable = previous;
            }
        }

        private static class WeakEvictableEntry<K, V> extends WeakEntry<K, V>
                implements ReferenceEntry<K, V> {
            WeakEvictableEntry(CustomConcurrentHashMap<K, V> map, K key, int hash,
                               @Nullable ReferenceEntry<K, V> next) {
                super(map, key, hash, next);
            }

            ReferenceEntry<K, V> nextEvictable = nullEntry();
            @Override
            public ReferenceEntry<K, V> getNextEvictable() {
                return nextEvictable;
            }
            @Override
            public void setNextEvictable(ReferenceEntry<K, V> next) {
                this.nextEvictable = next;
            }

            ReferenceEntry<K, V> previousEvictable = nullEntry();
            @Override
            public ReferenceEntry<K, V> getPreviousEvictable() {
                return previousEvictable;
            }
            @Override
            public void setPreviousEvictable(ReferenceEntry<K, V> previous) {
                this.previousEvictable = previous;
            }
        }

        private static class WeakExpirableEvictableEntry<K, V>
                extends WeakEntry<K, V> implements ReferenceEntry<K, V> {
            WeakExpirableEvictableEntry(CustomConcurrentHashMap<K, V> map, K key,
                                        int hash, @Nullable ReferenceEntry<K, V> next) {
                super(map, key, hash, next);
            }

            // The code below is exactly the same for each expirable entry type.

            volatile long time = Long.MAX_VALUE;
            @Override
            public long getExpirationTime() {
                return time;
            }
            @Override
            public void setExpirationTime(long time) {
                this.time = time;
            }

            ReferenceEntry<K, V> nextExpirable = nullEntry();
            @Override
            public ReferenceEntry<K, V> getNextExpirable() {
                return nextExpirable;
            }
            @Override
            public void setNextExpirable(ReferenceEntry<K, V> next) {
                this.nextExpirable = next;
            }

            ReferenceEntry<K, V> previousExpirable = nullEntry();
            @Override
            public ReferenceEntry<K, V> getPreviousExpirable() {
                return previousExpirable;
            }
            @Override
            public void setPreviousExpirable(ReferenceEntry<K, V> previous) {
                this.previousExpirable = previous;
            }


            ReferenceEntry<K, V> nextEvictable = nullEntry();
            @Override
            public ReferenceEntry<K, V> getNextEvictable() {
                return nextEvictable;
            }
            @Override
            public void setNextEvictable(ReferenceEntry<K, V> next) {
                this.nextEvictable = next;
            }

            ReferenceEntry<K, V> previousEvictable = nullEntry();
            @Override
            public ReferenceEntry<K, V> getPreviousEvictable() {
                return previousEvictable;
            }
            @Override
            public void setPreviousEvictable(ReferenceEntry<K, V> previous) {
                this.previousEvictable = previous;
            }
        }

        private static class WeakValueReference<K, V>
                extends FinalizableWeakReference<V>
                implements ValueReference<K, V> {
            final ReferenceEntry<K, V> entry;

            WeakValueReference(V referent, ReferenceEntry<K, V> entry) {
                super(referent, QueueHolder.queue);
                this.entry = entry;
            }

            @Override
            public void notifyValueReclaimed() {
                finalizeReferent();
            }

            @Override
            public void finalizeReferent() {
                entry.notifyValueReclaimed(this);
            }

            @Override
            public ValueReference<K, V> copyFor(ReferenceEntry<K, V> entry) {
                return new WeakValueReference<K, V>(get(), entry);
            }

            @Override
            public boolean isComputingReference() {
                return false;
            }

            @Override
            public V waitForValue() {
                return get();
            }
        }

        private static class SoftValueReference<K, V>
                extends FinalizableSoftReference<V>
                implements ValueReference<K, V> {
            final ReferenceEntry<K, V> entry;

            SoftValueReference(V referent, ReferenceEntry<K, V> entry) {
                super(referent, QueueHolder.queue);
                this.entry = entry;
            }

            @Override
            public void notifyValueReclaimed() {
                finalizeReferent();
            }

            @Override
            public void finalizeReferent() {
                entry.notifyValueReclaimed(this);
            }

            @Override
            public ValueReference<K, V> copyFor(ReferenceEntry<K, V> entry) {
                return new SoftValueReference<K, V>(get(), entry);
            }

            @Override
            public boolean isComputingReference() {
                return false;
            }

            @Override
            public V waitForValue() {
                return get();
            }
        }

        private static class StrongValueReference<K, V>
                implements ValueReference<K, V> {
            final V referent;

            StrongValueReference(V referent) {
                this.referent = referent;
            }

            @Override
            public V get() {
                return referent;
            }

            @Override
            public ValueReference<K, V> copyFor(ReferenceEntry<K, V> entry) {
                return this;
            }

            @Override
            public boolean isComputingReference() {
                return false;
            }

            @Override
            public V waitForValue() {
                return get();
            }

            @Override
            public void notifyValueReclaimed() {}

            @Override
            public void clear() {}
        }

        private static int rehash(int h) {
            // Spread bits to regularize both segment and index locations,
            // using variant of single-word Wang/Jenkins hash.
            // TODO(kevinb): use Hashing/move this to Hashing?
            h += (h << 15) ^ 0xffffcd7d;
            h ^= (h >>> 10);
            h += (h << 3);
            h ^= (h >>> 6);
            h += (h << 2) + (h << 14);
            return h ^ (h >>> 16);
        }


        ReferenceEntry<K, V> newEntry(
                K key, int hash, @Nullable ReferenceEntry<K, V> next) {
            return entryFactory.newEntry(this, key, hash, next);
        }


        ReferenceEntry<K, V> copyEntry(
                ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
            ValueReference<K, V> valueReference = original.getValueReference();
            ReferenceEntry<K, V> newEntry
                    = entryFactory.copyEntry(this, original, newNext);
            newEntry.setValueReference(valueReference.copyFor(newEntry));
            return newEntry;
        }


        ValueReference<K, V> newValueReference(ReferenceEntry<K, V> entry, V value) {
            return valueStrength.referenceValue(entry, value);
        }

        int hash(Object key) {
            int h = keyEquivalence.hash(checkNotNull(key));
            return rehash(h);
        }

        void reclaimValue(ReferenceEntry<K, V> entry,
                          ValueReference<K, V> valueReference) {
            int hash = entry.getHash();
            Segment segment = segmentFor(hash);
            segment.unsetValue(entry.getKey(), hash, valueReference);
            if (!segment.isHeldByCurrentThread()) { // don't cleanup inside of put
                segment.postWriteCleanup();
            }
        }

        void reclaimKey(ReferenceEntry<K, V> entry) {
            int hash = entry.getHash();
            segmentFor(hash).unsetKey(entry, hash);
        }

        // Entries in the map can be in the following states:
        // Valid:
        // - Live: valid key/value are set
        // - Computing: computation is pending
        // Invalid:
        // - Expired: time expired (key/value may still be set)
        // - Collected: key/value was partially collected, but not yet cleaned up
        // - Unset: marked as unset, awaiting cleanup or reuse

        boolean isLive(ReferenceEntry<K, V> entry) {
            return segmentFor(entry.getHash()).getLiveValue(entry) != null;
        }

        boolean isExpired(ReferenceEntry<K, V> entry) {
            return isExpired(entry, ticker.read());
        }

        boolean isExpired(ReferenceEntry<K, V> entry, long now) {
            // if the expiration time had overflowed, this "undoes" the overflow
            return now - entry.getExpirationTime() > 0;
        }


        boolean isCollected(ReferenceEntry<K, V> entry) {
            if (entry.getKey() == null) {
                return true;
            }
            ValueReference<K, V> valueReference = entry.getValueReference();
            if (valueReference.isComputingReference()) {
                return false;
            }
            return valueReference.get() == null;
        }

        boolean isUnset(ReferenceEntry<K, V> entry) {
            return isUnset(entry.getValueReference());
        }

        boolean isUnset(ValueReference<K, V> valueReference) {
            return valueReference == UNSET;
        }

        // expiration


        static <K, V> void connectExpirables(ReferenceEntry<K, V> previous,
                                             ReferenceEntry<K, V> next) {
            previous.setNextExpirable(next);
            next.setPreviousExpirable(previous);
        }


        static <K, V> void nullifyExpirable(ReferenceEntry<K, V> nulled) {
            ReferenceEntry<K, V> nullEntry = nullEntry();
            nulled.setNextExpirable(nullEntry);
            nulled.setPreviousExpirable(nullEntry);
        }

        // eviction

        void enqueueNotification(K key, int hash,
                                 ValueReference<K, V> valueReference) {
            if (evictionNotificationQueue == DISCARDING_QUEUE) {
                return;
            }

            ReferenceEntry<K, V> notifyEntry = newEntry(key, hash, null);
            notifyEntry.setValueReference(valueReference.copyFor(notifyEntry));
            evictionNotificationQueue.offer(notifyEntry);
        }


        void processPendingNotifications() {
            ReferenceEntry<K, V> entry;
            while ((entry = evictionNotificationQueue.poll()) != null) {
                evictionListener.onEviction(entry.getKey(),
                        entry.getValueReference().get());
            }
        }


        static <K, V> void connectEvictables(ReferenceEntry<K, V> previous,
                                             ReferenceEntry<K, V> next) {
            previous.setNextEvictable(next);
            next.setPreviousEvictable(previous);
        }

        static <K, V> void nullifyEvictable(ReferenceEntry<K, V> nulled) {
            ReferenceEntry<K, V> nullEntry = nullEntry();
            nulled.setNextEvictable(nullEntry);
            nulled.setPreviousEvictable(nullEntry);
        }

        @SuppressWarnings("unchecked")
        final Segment[] newSegmentArray(int ssize) {
            // Note: This is the only way I could figure out how to create
            // a segment array (the compiler has a tough time with arrays of
            // inner classes of generic types apparently). Safe because we're
            // restricting what can go in the array and no one has an
            // unrestricted reference.
            return (Segment[]) Array.newInstance(Segment.class, ssize);
        }


        Segment segmentFor(int hash) {
            // TODO(user): Lazily create segments?
            return segments[(hash >>> segmentShift) & segmentMask];
        }

        Segment createSegment(int initialCapacity, int maxSegmentSize) {
            return new Segment(initialCapacity, maxSegmentSize);
        }


        @SuppressWarnings("serial") // This class is never serialized.
        class Segment extends ReentrantLock {

            volatile int count;


            int modCount;

            int threshold;

            volatile AtomicReferenceArray<ReferenceEntry<K, V>> table;

            final int maxSegmentSize;

            final Queue<ReferenceEntry<K, V>> cleanupQueue =
                    new ConcurrentLinkedQueue<ReferenceEntry<K, V>>();

            final Queue<ReferenceEntry<K, V>> recencyQueue;


            final AtomicInteger readCount = new AtomicInteger();

            final Queue<ReferenceEntry<K, V>> evictionQueue;

            final Queue<ReferenceEntry<K, V>> expirationQueue;

            Segment(int initialCapacity, int maxSegmentSize) {
                this.maxSegmentSize = maxSegmentSize;
                initTable(newEntryArray(initialCapacity));

                recencyQueue = (evictsBySize() || expiresAfterAccess())
                        ? new ConcurrentLinkedQueue<ReferenceEntry<K, V>>()
                        : CustomConcurrentHashMap.<ReferenceEntry<K, V>>discardingQueue();

                evictionQueue = evictsBySize()
                        ? new EvictionQueue()
                        : CustomConcurrentHashMap.<ReferenceEntry<K, V>>discardingQueue();

                expirationQueue = expires()
                        ? new ExpirationQueue()
                        : CustomConcurrentHashMap.<ReferenceEntry<K, V>>discardingQueue();
            }

            AtomicReferenceArray<ReferenceEntry<K, V>> newEntryArray(int size) {
                return new AtomicReferenceArray<ReferenceEntry<K, V>>(size);
            }

            void initTable(AtomicReferenceArray<ReferenceEntry<K, V>> newTable) {
                this.threshold = newTable.length() * 3 / 4; // 0.75
                if (this.threshold == maxSegmentSize) {
                    // prevent spurious expansion before eviction
                    this.threshold++;
                }
                this.table = newTable;
            }


            void setValue(ReferenceEntry<K, V> entry, V value) {
                recordWrite(entry);
                ValueReference<K, V> valueReference = newValueReference(entry, value);
                entry.setValueReference(valueReference);
            }


            void recordRead(ReferenceEntry<K, V> entry) {
                if (expiresAfterAccess()) {
                    recordExpirationTime(entry, expireAfterAccessNanos);
                }
                recencyQueue.add(entry);
            }


            void recordLockedRead(ReferenceEntry<K, V> entry) {
                evictionQueue.add(entry);
                if (expiresAfterAccess()) {
                    recordExpirationTime(entry, expireAfterAccessNanos);
                    expirationQueue.add(entry);
                }
            }


            void recordWrite(ReferenceEntry<K, V> entry) {
                // we are already under lock, so drain the recency queue immediately
                drainRecencyQueue();
                evictionQueue.add(entry);
                if (expires()) {
                    // currently MapMaker ensures that expireAfterWrite and
                    // expireAfterAccess are mutually exclusive
                    long expiration = expiresAfterAccess()
                            ? expireAfterAccessNanos : expireAfterWriteNanos;
                    recordExpirationTime(entry, expiration);
                    expirationQueue.add(entry);
                }
            }


            void drainRecencyQueue() {
                ReferenceEntry<K, V> e;
                while ((e = recencyQueue.poll()) != null) {
                    // An entry may be in the recency queue despite it being removed from
                    // the map . This can occur when the entry was concurrently read while a
                    // writer is removing it from the segment or after a clear has removed
                    // all of the segment's entries.
                    if (evictionQueue.contains(e)) {
                        evictionQueue.add(e);
                    }
                    if (expiresAfterAccess() && expirationQueue.contains(e)) {
                        expirationQueue.add(e);
                    }
                }
            }

            // expiration

            void recordExpirationTime(ReferenceEntry<K, V> entry,
                                      long expirationNanos) {
                // might overflow, but that's okay (see isExpired())
                entry.setExpirationTime(ticker.read() + expirationNanos);
            }

            void tryExpireEntries() {
                if (tryLock()) {
                    try {
                        expireEntries();
                    } finally {
                        unlock();
                    }
                }
            }

            void expireEntries() {
                drainRecencyQueue();

                if (expirationQueue.isEmpty()) {
                    // There's no point in calling nanoTime() if we have no entries to
                    // expire.
                    return;
                }
                long now = ticker.read();
                ReferenceEntry<K, V> e;
                while ((e = expirationQueue.peek()) != null && isExpired(e, now)) {
                    if (!unsetEntry(e, e.getHash())) {
                        throw new AssertionError();
                    }
                }
            }


            boolean evictEntries() {
                if (evictsBySize() && count >= maxSegmentSize) {
                    drainRecencyQueue();

                    ReferenceEntry<K, V> e = evictionQueue.remove();
                    if (!unsetEntry(e, e.getHash())) {
                        throw new AssertionError();
                    }
                    return true;
                }
                return false;
            }

            ReferenceEntry<K, V> getFirst(int hash) {
                // read this volatile field only once
                AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
                return table.get(hash & (table.length() - 1));
            }

            ReferenceEntry<K, V> getEntry(Object key, int hash) {
                for (ReferenceEntry<K, V> e = getFirst(hash); e != null;
                     e = e.getNext()) {
                    if (e.getHash() != hash) {
                        continue;
                    }

                    K entryKey = e.getKey();
                    if (entryKey == null) {
                        continue;
                    }

                    if (keyEquivalence.equivalent(key, entryKey)) {
                        return e;
                    }
                }

                return null;
            }

            V get(Object key, int hash) {
                try {
                    if (count != 0) { // read-volatile
                        for (ReferenceEntry<K, V> e = getFirst(hash); e != null;
                             e = e.getNext()) {
                            if (e.getHash() != hash) {
                                continue;
                            }

                            K entryKey = e.getKey();
                            if (entryKey == null) {
                                continue;
                            }

                            if (keyEquivalence.equivalent(key, entryKey)) {
                                V value = getLiveValue(e);
                                if (value != null) {
                                    recordRead(e);
                                }
                                return value;
                            }
                        }
                    }

                    return null;
                } finally {
                    postReadCleanup();
                }
            }

            boolean containsKey(Object key, int hash) {
                if (count != 0) { // read-volatile
                    for (ReferenceEntry<K, V> e = getFirst(hash); e != null;
                         e = e.getNext()) {
                        if (e.getHash() != hash) {
                            continue;
                        }

                        K entryKey = e.getKey();
                        if (entryKey == null) {
                            continue;
                        }

                        if (keyEquivalence.equivalent(key, entryKey)) {
                            return getLiveValue(e) != null;
                        }
                    }
                }

                return false;
            }

            boolean containsValue(Object value) {
                if (count != 0) { // read-volatile
                    AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
                    int length = table.length();
                    for (int i = 0; i < length; ++i) {
                        for (ReferenceEntry<K, V> e = table.get(i); e != null;
                             e = e.getNext()) {
                            V entryValue = getLiveValue(e);
                            if (entryValue == null) {
                                continue;
                            }
                            if (valueEquivalence.equivalent(value, entryValue)) {
                                return true;
                            }
                        }
                    }
                }

                return false;
            }

            boolean replace(K key, int hash, V oldValue, V newValue) {
                checkNotNull(oldValue);
                checkNotNull(newValue);
                lock();
                try {
                    preWriteCleanup();

                    for (ReferenceEntry<K, V> e = getFirst(hash); e != null;
                         e = e.getNext()) {
                        K entryKey = e.getKey();
                        if (e.getHash() == hash && entryKey != null
                                && keyEquivalence.equivalent(key, entryKey)) {
                            // If the value disappeared, this entry is partially collected,
                            // and we should pretend like it doesn't exist.
                            V entryValue = e.getValueReference().get();
                            if (entryValue == null) {
                                unsetLiveEntry(e, hash);
                                return false;
                            }

                            if (valueEquivalence.equivalent(oldValue, entryValue)) {
                                setValue(e, newValue);
                                return true;
                            } else {
                                // Mimic
                                // "if (map.containsKey(key) && map.get(key).equals(oldValue))..."
                                recordLockedRead(e);
                                return false;
                            }
                        }
                    }

                    return false;
                } finally {
                    unlock();
                    postWriteCleanup();
                }
            }

            V replace(K key, int hash, V newValue) {
                checkNotNull(newValue);
                lock();
                try {
                    preWriteCleanup();

                    for (ReferenceEntry<K, V> e = getFirst(hash); e != null;
                         e = e.getNext()) {
                        K entryKey = e.getKey();
                        if (e.getHash() == hash && entryKey != null
                                && keyEquivalence.equivalent(key, entryKey)) {
                            // If the value disappeared, this entry is partially collected,
                            // and we should pretend like it doesn't exist.
                            V entryValue = e.getValueReference().get();
                            if (entryValue == null) {
                                unsetLiveEntry(e, hash);
                                return null;
                            }

                            setValue(e, newValue);
                            return entryValue;
                        }
                    }

                    return null;
                } finally {
                    unlock();
                    postWriteCleanup();
                }
            }

            V put(K key, int hash, V value, boolean onlyIfAbsent) {
                checkNotNull(value);
                lock();
                try {
                    preWriteCleanup();

                    int newCount = this.count + 1;
                    if (newCount > this.threshold) { // ensure capacity
                        expand();
                        newCount = this.count + 1;
                    }

                    // getFirst, but remember the index
                    AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
                    int index = hash & (table.length() - 1);
                    ReferenceEntry<K, V> first = table.get(index);

                    // Look for an existing entry.
                    for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {
                        K entryKey = e.getKey();
                        if (e.getHash() == hash && entryKey != null
                                && keyEquivalence.equivalent(key, entryKey)) {
                            // We found an existing entry.

                            ValueReference<K, V> valueReference = e.getValueReference();
                            V entryValue = valueReference.get();

                            if (entryValue == null) {
                                ++modCount;
                                // Value could be partially-collected, unset, or computing.
                                // In the first case, the value must be reclaimed. In the latter
                                // two cases en entry must be evicted. This entry could be both
                                // partially-collected and next on the eviction list, which is why
                                // notifyValueReclaimed must be called prior to evictEntries.
                                valueReference.notifyValueReclaimed();
                                evictEntries();
                                newCount = this.count + 1;
                                this.count = newCount; // write-volatile
                            } else if (onlyIfAbsent) {
                                // Mimic
                                // "if (!map.containsKey(key)) ...
                                //  else return map.get(key);
                                recordLockedRead(e);
                                return entryValue;
                            }
                            // else clobber, don't adjust count

                            setValue(e, value);
                            return entryValue;
                        }
                    }

                    if (evictEntries()) {
                        newCount = this.count + 1;
                        first = table.get(index);
                    }

                    // Create a new entry.
                    ++modCount;
                    ReferenceEntry<K, V> newEntry = newEntry(key, hash, first);
                    setValue(newEntry, value);
                    table.set(index, newEntry);
                    this.count = newCount; // write-volatile
                    return null;
                } finally {
                    unlock();
                    postWriteCleanup();
                }
            }


            void expand() {
                AtomicReferenceArray<ReferenceEntry<K, V>> oldTable = table;
                int oldCapacity = oldTable.length();
                if (oldCapacity >= MAXIMUM_CAPACITY) {
                    return;
                }


                AtomicReferenceArray<ReferenceEntry<K, V>> newTable
                        = newEntryArray(oldCapacity << 1);
                threshold = newTable.length() * 3 / 4;
                int newMask = newTable.length() - 1;
                for (int oldIndex = 0; oldIndex < oldCapacity; ++oldIndex) {
                    // We need to guarantee that any existing reads of old Map can
                    // proceed. So we cannot yet null out each bin.
                    ReferenceEntry<K, V> head = oldTable.get(oldIndex);

                    if (head != null) {
                        ReferenceEntry<K, V> next = head.getNext();
                        int headIndex = head.getHash() & newMask;

                        // Single node on list
                        if (next == null) {
                            newTable.set(headIndex, head);
                        } else {
                            // Reuse the consecutive sequence of nodes with the same target
                            // index from the end of the list. tail points to the first
                            // entry in the reusable list.
                            ReferenceEntry<K, V> tail = head;
                            int tailIndex = headIndex;
                            for (ReferenceEntry<K, V> e = next; e != null; e = e.getNext()) {
                                int newIndex = e.getHash() & newMask;
                                if (newIndex != tailIndex) {
                                    // The index changed. We'll need to copy the previous entry.
                                    tailIndex = newIndex;
                                    tail = e;
                                }
                            }
                            newTable.set(tailIndex, tail);

                            // Clone nodes leading up to the tail.
                            for (ReferenceEntry<K, V> e = head; e != tail; e = e.getNext()) {
                                if (isCollected(e)) {
                                    unsetLiveEntry(e, e.getHash()); // decrements count
                                } else {
                                    int newIndex = e.getHash() & newMask;
                                    ReferenceEntry<K, V> newNext = newTable.get(newIndex);
                                    newTable.set(newIndex, copyEntry(e, newNext));
                                }
                            }
                        }
                    }
                }
                table = newTable;
            }

            V remove(Object key, int hash) {
                lock();
                try {
                    preWriteCleanup();

                    int newCount = this.count - 1;
                    AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
                    int index = hash & (table.length() - 1);
                    ReferenceEntry<K, V> first = table.get(index);

                    for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {
                        K entryKey = e.getKey();
                        if (e.getHash() == hash && entryKey != null
                                && keyEquivalence.equivalent(key, entryKey)) {
                            V entryValue = e.getValueReference().get();
                            if (entryValue == null) {
                                unsetLiveEntry(e, hash);
                            } else {
                                ++modCount;
                                ReferenceEntry<K, V> newFirst =
                                        removeFromChain(first, e); // could decrement count
                                newCount = this.count - 1;
                                table.set(index, newFirst);
                                this.count = newCount; // write-volatile
                            }
                            return entryValue;
                        }
                    }

                    return null;
                } finally {
                    unlock();
                    postWriteCleanup();
                }
            }

            boolean remove(Object key, int hash, Object value) {
                checkNotNull(value);
                lock();
                try {
                    preWriteCleanup();

                    int newCount = this.count - 1;
                    AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
                    int index = hash & (table.length() - 1);
                    ReferenceEntry<K, V> first = table.get(index);

                    for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {
                        K entryKey = e.getKey();
                        if (e.getHash() == hash && entryKey != null
                                && keyEquivalence.equivalent(key, entryKey)) {
                            V entryValue = e.getValueReference().get();
                            if (entryValue == null) {
                                unsetLiveEntry(e, hash);
                            } else if (valueEquivalence.equivalent(value, entryValue)) {
                                ++modCount;
                                ReferenceEntry<K, V> newFirst =
                                        removeFromChain(first, e); // could decrement count
                                newCount = this.count - 1;
                                table.set(index, newFirst);
                                this.count = newCount; // write-volatile
                                return true;
                            }
                            return false;
                        }
                    }

                    return false;
                } finally {
                    unlock();
                    postWriteCleanup();
                }
            }

            ReferenceEntry<K, V> removeFromChain(ReferenceEntry<K, V> first,
                                                 ReferenceEntry<K, V> entry) {
                evictionQueue.remove(entry);
                expirationQueue.remove(entry);

                ReferenceEntry<K, V> newFirst = entry.getNext();
                for (ReferenceEntry<K, V> e = first; e != entry; e = e.getNext()) {
                    if (isCollected(e)) {
                        unsetLiveEntry(e, e.getHash()); // decrements count
                    } else {
                        newFirst = copyEntry(e, newFirst);
                    }
                }
                return newFirst;
            }

            boolean unsetKey(ReferenceEntry<K, V> entry, int hash) {
                lock();
                try {
                    int newCount = count - 1;
                    AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
                    int index = hash & (table.length() - 1);
                    ReferenceEntry<K, V> first = table.get(index);

                    for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {
                        if (e == entry) {
                            ++modCount;
                            enqueueNotification(e.getKey(), hash, e.getValueReference());
                            enqueueCleanup(e);
                            count = newCount; // write-volatile
                            return true;
                        }
                    }

                    return false;
                } finally {
                    unlock();
                }
            }


            boolean unsetValue(K key, int hash,
                               ValueReference<K, V> valueReference) {
                lock();
                try {
                    int newCount = this.count - 1;
                    for (ReferenceEntry<K, V> e = getFirst(hash); e != null;
                         e = e.getNext()) {
                        K entryKey = e.getKey();
                        if (e.getHash() == hash && entryKey != null
                                && keyEquivalence.equivalent(key, entryKey)) {
                            ValueReference<K, V> v = e.getValueReference();
                            if (v == valueReference) {
                                ++modCount;
                                enqueueNotification(key, hash, valueReference);
                                enqueueCleanup(e);
                                this.count = newCount; // write-volatile
                                return true;
                            }
                            return false;
                        }
                    }

                    return false;
                } finally {
                    unlock();
                }
            }

            boolean clearValue(K key, int hash, ValueReference<K, V> valueReference) {
                lock();
                try {
                    for (ReferenceEntry<K, V> e = getFirst(hash); e != null;
                         e = e.getNext()) {
                        K entryKey = e.getKey();
                        if (e.getHash() == hash && entryKey != null
                                && keyEquivalence.equivalent(key, entryKey)) {
                            ValueReference<K, V> v = e.getValueReference();
                            if (v == valueReference) {
                                enqueueCleanup(e);
                                return true;
                            }
                            return false;
                        }
                    }

                    return false;
                } finally {
                    unlock();
                }
            }

            boolean unsetEntry(ReferenceEntry<K, V> entry, int hash) {
                for (ReferenceEntry<K, V> e = getFirst(hash); e != null;
                     e = e.getNext()) {
                    if (e == entry) {
                        return unsetLiveEntry(entry, hash);
                    }
                }

                return false;
            }

            boolean unsetLiveEntry(ReferenceEntry<K, V> entry, int hash) {
                if (isUnset(entry)) {
                    // keep count consistent
                    return false;
                }

                int newCount = this.count - 1;
                ++modCount;
                ValueReference<K, V> valueReference = entry.getValueReference();
                if (valueReference.isComputingReference()) {
                    return false;
                }

                K key = entry.getKey();
                enqueueNotification(key, hash, valueReference);
                enqueueCleanup(entry);
                this.count = newCount; // write-volatile
                return true;
            }

            void enqueueCleanup(ReferenceEntry<K, V> entry) {
                ValueReference<K, V> unset = unset();
                entry.setValueReference(unset);
                cleanupQueue.offer(entry);
                evictionQueue.remove(entry);
                expirationQueue.remove(entry);
            }

            V getLiveValue(ReferenceEntry<K, V> entry) {
                if (entry.getKey() == null) {
                    return null;
                }
                V value = entry.getValueReference().get();
                if (value == null) {
                    return null;
                }
                if (expires() && isExpired(entry)) {
                    tryExpireEntries();
                    return null;
                }
                return value;
            }


            void processPendingCleanup() {
                AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
                ReferenceEntry<K, V> entry;
                int cleanedUp = 0;
                while (cleanedUp < CLEANUP_MAX && (entry = cleanupQueue.poll()) != null) {
                    int index = entry.getHash() & (table.length() - 1);

                    ReferenceEntry<K, V> first = table.get(index);
                    for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {
                        if (e == entry) {
                            if (isUnset(e)) {
                                ReferenceEntry<K, V> newFirst = removeFromChain(first, e);
                                table.set(index, newFirst);
                                cleanedUp++;
                            }
                            break;
                        }
                    }
                }
            }

            void postReadCleanup() {
                // we are not under lock, so only drain a small fraction of the time
                if ((readCount.incrementAndGet() & DRAIN_THRESHOLD) == 0) {
                    if (isInlineCleanup()) {
                        // inline cleanup normally avoids taking the lock, but since no
                        // writes are happening we need to force some locked cleanup
                        runCleanup();
                    } else if (!isHeldByCurrentThread()) {
                        cleanupExecutor.execute(cleanupRunnable);
                    }
                }
            }


            void preWriteCleanup() {
                if (isInlineCleanup()) {
                    // this is the only time we have the lock, so do everything we can
                    runLockedCleanup();
                } else {
                    expireEntries();
                }
            }

            void postWriteCleanup() {
                if (isInlineCleanup()) {
                    // this cleanup pattern is optimized for writes, where cleanup requiring
                    // the lock is performed when the lock is acquired, and cleanup not
                    // requiring the lock is performed when the lock is released
                    if (isHeldByCurrentThread()) {
                        runLockedCleanup();
                    } else {
                        runUnlockedCleanup();
                    }
                } else if (!isHeldByCurrentThread()) {
                    // non-default cleanup executors can ignore cleanup optimizations when
                    // the lock is held, as cleanup will always be called when the lock is
                    // released
                    cleanupExecutor.execute(cleanupRunnable);
                }
            }

            final Runnable cleanupRunnable =
                    new Runnable() {
                        @Override
                        public void run() {
                            runCleanup();
                        }
                    };

            void runCleanup() {
                runLockedCleanup();
                // locked cleanup may generate notifications we can send unlocked
                runUnlockedCleanup();
            }


            void runUnlockedCleanup() {
                processPendingNotifications();
            }

            void runLockedCleanup() {
                lock();
                try {
                    expireEntries(); // calls drainRecencyQueue
                    processPendingCleanup();
                    readCount.set(0);
                } finally {
                    unlock();
                }
            }

            void clear() {
                if (count != 0) {
                    lock();
                    try {
                        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
                        for (int i = 0; i < table.length(); ++i) {
                            table.set(i, null);
                        }
                        evictionQueue.clear();
                        expirationQueue.clear();
                        readCount.set(0);

                        ++modCount;
                        count = 0; // write-volatile
                    } finally {
                        unlock();
                    }
                }
            }

             class EvictionQueue
                    extends AbstractQueue<ReferenceEntry<K, V>> {
                // TODO(user): create UnsupportedOperationException throwing base class
                            final ReferenceEntry<K, V> head =
                        new ReferenceEntry<K, V>() {

                            ReferenceEntry<K, V> nextEvictable = this;
                            @Override
                            public ReferenceEntry<K, V> getNextEvictable() {
                                return nextEvictable;
                            }
                            @Override
                            public void setNextEvictable(ReferenceEntry<K, V> next) {
                                this.nextEvictable = next;
                            }

                            ReferenceEntry<K, V> previousEvictable = this;
                            @Override
                            public ReferenceEntry<K, V> getPreviousEvictable() {
                                return previousEvictable;
                            }
                            @Override
                            public void setPreviousEvictable(ReferenceEntry<K, V> previous) {
                                this.previousEvictable = previous;
                            }

                            @Override
                            public ValueReference<K, V> getValueReference() {
                                throw new UnsupportedOperationException();
                            }
                            @Override
                            public void setValueReference(ValueReference<K, V> valueReference) {
                                throw new UnsupportedOperationException();
                            }
                            @Override
                            public void notifyKeyReclaimed() {}
                            @Override
                            public void notifyValueReclaimed(ValueReference<K, V> valueReference) {
                                throw new UnsupportedOperationException();
                            }
                            @Override
                            public ReferenceEntry<K, V> getNext() {
                                throw new UnsupportedOperationException();
                            }
                            @Override
                            public int getHash() {
                                throw new UnsupportedOperationException();
                            }
                            @Override
                            public K getKey() {
                                throw new UnsupportedOperationException();
                            }

                            // null expiration
                            @Override
                            public long getExpirationTime() {
                                throw new UnsupportedOperationException();
                            }
                            @Override
                            public void setExpirationTime(long time) {
                                throw new UnsupportedOperationException();
                            }

                            @Override
                            public ReferenceEntry<K, V> getNextExpirable() {
                                throw new UnsupportedOperationException();
                            }
                            @Override
                            public void setNextExpirable(ReferenceEntry<K, V> next) {
                                throw new UnsupportedOperationException();
                            }

                            @Override
                            public ReferenceEntry<K, V> getPreviousExpirable() {
                                throw new UnsupportedOperationException();
                            }
                            @Override
                            public void setPreviousExpirable(ReferenceEntry<K, V> previous) {
                                throw new UnsupportedOperationException();
                            }
                        };

                // implements Queue

                @Override
                public boolean offer(ReferenceEntry<K, V> entry) {
                    // unlink
                    connectEvictables(entry.getPreviousEvictable(),
                            entry.getNextEvictable());

                    // add to tail
                    connectEvictables(head.getPreviousEvictable(), entry);
                    connectEvictables(entry, head);

                    return true;
                }

                @Override
                public ReferenceEntry<K, V> peek() {
                    ReferenceEntry<K, V> next = head.getNextEvictable();
                    return (next == head) ? null : next;
                }

                @Override
                public ReferenceEntry<K, V> poll() {
                    ReferenceEntry<K, V> next = head.getNextEvictable();
                    if (next == head) {
                        return null;
                    }

                    remove(next);
                    return next;
                }

                @Override
                @SuppressWarnings("unchecked")
                public boolean remove(Object o) {
                    ReferenceEntry<K, V> e = (ReferenceEntry) o;
                    ReferenceEntry<K, V> previous = e.getPreviousEvictable();
                    ReferenceEntry<K, V> next = e.getNextEvictable();
                    connectEvictables(previous, next);
                    nullifyEvictable(e);

                    return next != NullEntry.INSTANCE;
                }

                @Override
                @SuppressWarnings("unchecked")
                public boolean contains(Object o) {
                    ReferenceEntry<K, V> e = (ReferenceEntry) o;
                    return e.getNextEvictable() != NullEntry.INSTANCE;
                }

                @Override
                public boolean isEmpty() {
                    return head.getNextEvictable() == head;
                }

                @Override
                public int size() {
                    int size = 0;
                    for (ReferenceEntry<K, V> e = head.getNextEvictable(); e != head;
                         e = e.getNextEvictable()) {
                        size++;
                    }
                    return size;
                }

                @Override
                public void clear() {
                    ReferenceEntry<K, V> e = head.getNextEvictable();
                    while (e != head) {
                        ReferenceEntry<K, V> next = e.getNextEvictable();
                        nullifyEvictable(e);
                        e = next;
                    }

                    head.setNextEvictable(head);
                    head.setPreviousEvictable(head);
                }

                @Override
                public Iterator<ReferenceEntry<K, V>> iterator() {
                    return new AbstractLinkedIterator<ReferenceEntry<K, V>>(peek()) {
                        @Override
                        protected ReferenceEntry<K, V> computeNext(
                                ReferenceEntry<K, V> previous) {
                            ReferenceEntry<K, V> next = previous.getNextEvictable();
                            return (next == head) ? null : next;
                        }
                    };
                }
            }

            class ExpirationQueue
                    extends AbstractQueue<ReferenceEntry<K, V>> {
                // TODO(user): create UnsupportedOperationException throwing base class
                final ReferenceEntry<K, V> head =
                        new ReferenceEntry<K, V>() {

                            @Override
                            public long getExpirationTime() {
                                return Long.MAX_VALUE;
                            }
                            @Override
                            public void setExpirationTime(long time) {}

                            ReferenceEntry<K, V> nextExpirable = this;
                            @Override
                            public ReferenceEntry<K, V> getNextExpirable() {
                                return nextExpirable;
                            }
                            @Override
                            public void setNextExpirable(ReferenceEntry<K, V> next) {
                                this.nextExpirable = next;
                            }

                            ReferenceEntry<K, V> previousExpirable = this;
                            @Override
                            public ReferenceEntry<K, V> getPreviousExpirable() {
                                return previousExpirable;
                            }
                            @Override
                            public void setPreviousExpirable(ReferenceEntry<K, V> previous) {
                                this.previousExpirable = previous;
                            }

                            @Override
                            public ValueReference<K, V> getValueReference() {
                                throw new UnsupportedOperationException();
                            }
                            @Override
                            public void setValueReference(ValueReference<K, V> valueReference) {
                                throw new UnsupportedOperationException();
                            }
                            @Override
                            public void notifyKeyReclaimed() {}
                            @Override
                            public void notifyValueReclaimed(ValueReference<K, V> valueReference) {
                                throw new UnsupportedOperationException();
                            }
                            @Override
                            public ReferenceEntry<K, V> getNext() {
                                throw new UnsupportedOperationException();
                            }
                            @Override
                            public int getHash() {
                                throw new UnsupportedOperationException();
                            }
                            @Override
                            public K getKey() {
                                throw new UnsupportedOperationException();
                            }

                            // null eviction
                            @Override
                            public ReferenceEntry<K, V> getNextEvictable() {
                                throw new UnsupportedOperationException();
                            }
                            @Override
                            public void setNextEvictable(ReferenceEntry<K, V> next) {
                                throw new UnsupportedOperationException();
                            }

                            @Override
                            public ReferenceEntry<K, V> getPreviousEvictable() {
                                throw new UnsupportedOperationException();
                            }
                            @Override
                            public void setPreviousEvictable(ReferenceEntry<K, V> previous) {
                                throw new UnsupportedOperationException();
                            }
                        };

                // implements Queue

                @Override
                public boolean offer(ReferenceEntry<K, V> entry) {
                    // unlink
                    connectExpirables(entry.getPreviousExpirable(),
                            entry.getNextExpirable());

                    // add to tail
                    connectExpirables(head.getPreviousExpirable(), entry);
                    connectExpirables(entry, head);

                    return true;
                }

                @Override
                public ReferenceEntry<K, V> peek() {
                    ReferenceEntry<K, V> next = head.getNextExpirable();
                    return (next == head) ? null : next;
                }

                @Override
                public ReferenceEntry<K, V> poll() {
                    ReferenceEntry<K, V> next = head.getNextExpirable();
                    if (next == head) {
                        return null;
                    }

                    remove(next);
                    return next;
                }

                @Override
                @SuppressWarnings("unchecked")
                public boolean remove(Object o) {
                    ReferenceEntry<K, V> e = (ReferenceEntry) o;
                    ReferenceEntry<K, V> previous = e.getPreviousExpirable();
                    ReferenceEntry<K, V> next = e.getNextExpirable();
                    connectExpirables(previous, next);
                    nullifyExpirable(e);

                    return next != NullEntry.INSTANCE;
                }

                @Override
                @SuppressWarnings("unchecked")
                public boolean contains(Object o) {
                    ReferenceEntry<K, V> e = (ReferenceEntry) o;
                    return e.getNextExpirable() != NullEntry.INSTANCE;
                }

                @Override
                public boolean isEmpty() {
                    return head.getNextExpirable() == head;
                }

                @Override
                public int size() {
                    int size = 0;
                    for (ReferenceEntry<K, V> e = head.getNextExpirable(); e != head;
                         e = e.getNextExpirable()) {
                        size++;
                    }
                    return size;
                }

                @Override
                public void clear() {
                    ReferenceEntry<K, V> e = head.getNextExpirable();
                    while (e != head) {
                        ReferenceEntry<K, V> next = e.getNextExpirable();
                        nullifyExpirable(e);
                        e = next;
                    }

                    head.setNextExpirable(head);
                    head.setPreviousExpirable(head);
                }

                @Override
                public Iterator<ReferenceEntry<K, V>> iterator() {
                    return new AbstractLinkedIterator<ReferenceEntry<K, V>>(peek()) {
                        @Override
                        protected ReferenceEntry<K, V> computeNext(
                                ReferenceEntry<K, V> previous) {
                            ReferenceEntry<K, V> next = previous.getNextExpirable();
                            return (next == head) ? null : next;
                        }
                    };
                }
            }
        }


        @Override public boolean isEmpty() {
            Segment[] segments = this.segments;

            int[] mc = new int[segments.length];
            int mcsum = 0;
            for (int i = 0; i < segments.length; ++i) {
                if (segments[i].count != 0) {
                    return false;
                }
                mcsum += mc[i] = segments[i].modCount;
            }


            if (mcsum != 0) {
                for (int i = 0; i < segments.length; ++i) {
                    if (segments[i].count != 0 ||
                            mc[i] != segments[i].modCount) {
                        return false;
                    }
                }
            }
            return true;
        }

        @Override public int size() {
            Segment[] segments = this.segments;
            long sum = 0;
            for (int i = 0; i < segments.length; ++i) {
                sum += segments[i].count;
            }
            return Ints.saturatedCast(sum);
        }

        @Override public V get(Object key) {
            int hash = hash(key);
            return segmentFor(hash).get(key, hash);
        }

         ReferenceEntry<K, V> getEntry(Object key) {
            int hash = hash(key);
            return segmentFor(hash).getEntry(key, hash);
        }

        @Override public boolean containsKey(Object key) {
            int hash = hash(key);
            return segmentFor(hash).containsKey(key, hash);
        }

        @Override public boolean containsValue(Object value) {
            // TODO(kevinb): document why we choose to throw over returning false?
            checkNotNull(value);

            Segment[] segments = this.segments;
            for (int i = 0; i < segments.length; ++i) {
                // ensure visibility of most recent completed write
                @SuppressWarnings({"UnusedDeclaration", "unused"})
                int c = segments[i].count; // read-volatile
                if (segments[i].containsValue(value)) {
                    return true;
                }
            }
            return false;
        }

        @Override public V put(K key, V value) {
            int hash = hash(key);
            return segmentFor(hash).put(key, hash, value, false);
        }

        public V putIfAbsent(K key, V value) {
            int hash = hash(key);
            return segmentFor(hash).put(key, hash, value, true);
        }

        @Override public void putAll(Map<? extends K, ? extends V> m) {
            for (Entry<? extends K, ? extends V> e : m.entrySet()) {
                put(e.getKey(), e.getValue());
            }
        }

        @Override public V remove(Object key) {
            int hash = hash(key);
            return segmentFor(hash).remove(key, hash);
        }


        public boolean remove(Object key, Object value) {
            int hash = hash(key);
            return segmentFor(hash).remove(key, hash, value);
        }


        public boolean replace(K key, V oldValue, V newValue) {
            int hash = hash(key);
            return segmentFor(hash).replace(key, hash, oldValue, newValue);
        }


        public V replace(K key, V value) {
            int hash = hash(key);
            return segmentFor(hash).replace(key, hash, value);
        }

        @Override public void clear() {
            for (Segment segment : segments) {
                segment.clear();
            }
        }

        Set<K> keySet;

        @Override public Set<K> keySet() {
            Set<K> ks = keySet;
            return (ks != null) ? ks : (keySet = new KeySet());
        }

        Collection<V> values;

        @Override public Collection<V> values() {
            Collection<V> vs = values;
            return (vs != null) ? vs : (values = new Values());
        }

        Set<Entry<K, V>> entrySet;

        @Override public Set<Entry<K, V>> entrySet() {
            Set<Entry<K, V>> es = entrySet;
            return (es != null) ? es : (entrySet = new EntrySet());
        }


        abstract class HashIterator {

            int nextSegmentIndex;
            int nextTableIndex;
            AtomicReferenceArray<ReferenceEntry<K, V>> currentTable;
            ReferenceEntry<K, V> nextEntry;
            WriteThroughEntry nextExternal;
            WriteThroughEntry lastReturned;

            HashIterator() {
                nextSegmentIndex = segments.length - 1;
                nextTableIndex = -1;
                advance();
            }

            final void advance() {
                nextExternal = null;

                if (nextInChain()) {
                    return;
                }

                if (nextInTable()) {
                    return;
                }

                while (nextSegmentIndex >= 0) {
                    Segment seg = segments[nextSegmentIndex--];
                    if (seg.count != 0) {
                        currentTable = seg.table;
                        nextTableIndex = currentTable.length() - 1;
                        if (nextInTable()) {
                            return;
                        }
                    }
                }
            }

            boolean nextInChain() {
                if (nextEntry != null) {
                    for (nextEntry = nextEntry.getNext(); nextEntry != null;
                         nextEntry = nextEntry.getNext()) {
                        if (advanceTo(nextEntry)) {
                            return true;
                        }
                    }
                }
                return false;
            }


            boolean nextInTable() {
                while (nextTableIndex >= 0) {
                    if ((nextEntry = currentTable.get(nextTableIndex--)) != null) {
                        if (advanceTo(nextEntry) || nextInChain()) {
                            return true;
                        }
                    }
                }
                return false;
            }


            boolean advanceTo(ReferenceEntry<K, V> entry) {
                K key = entry.getKey();
                // TODO(user): call getLiveValue when it's moved out of Segment
                V value = entry.getValueReference().get();
                if (key != null && value != null &&
                        !(expires() && isExpired(entry))) {
                    nextExternal = new WriteThroughEntry(key, value);
                    return true;
                } else {
                    // Skip partially reclaimed entry.
                    return false;
                }
            }

            public boolean hasNext() {
                return nextExternal != null;
            }

            WriteThroughEntry nextEntry() {
                if (nextExternal == null) {
                    throw new NoSuchElementException();
                }
                lastReturned = nextExternal;
                advance();
                return lastReturned;
            }

            public void remove() {
                checkState(lastReturned != null);
                CustomConcurrentHashMap.this.remove(lastReturned.getKey());
                lastReturned = null;
            }
        }

        final class KeyIterator extends HashIterator implements Iterator<K> {

            public K next() {
                return nextEntry().getKey();
            }
        }

        final class ValueIterator extends HashIterator implements Iterator<V> {

            public V next() {
                return nextEntry().getValue();
            }
        }


        final class WriteThroughEntry extends AbstractMapEntry<K, V> {
            final K key; // non-null
            V value; // non-null

            WriteThroughEntry(K key, V value) {
                this.key = key;
                this.value = value;
            }

            @Override public K getKey() {
                return key;
            }

            @Override public V getValue() {
                return value;
            }

            @Override public boolean equals(@Nullable Object object) {
                // Cannot use key and value equivalence
                if (object instanceof Entry) {
                    Entry<?, ?> that = (Entry<?, ?>) object;
                    return key.equals(that.getKey())
                            && value.equals(that.getValue());
                }
                return false;
            }

            @Override public int hashCode() {
                // Cannot use key and value equivalence
                return key.hashCode() ^ value.hashCode();
            }

            @Override public V setValue(V newValue) {
                V oldValue = put(key, newValue);
                value = newValue; // only if put succeeds
                return oldValue;
            }
        }

        final class EntryIterator extends HashIterator
                implements Iterator<Entry<K, V>> {

            public Entry<K, V> next() {
                return nextEntry();
            }
        }

        final class KeySet extends AbstractSet<K> {

            @Override public Iterator<K> iterator() {
                return new KeyIterator();
            }

            @Override public int size() {
                return CustomConcurrentHashMap.this.size();
            }

            @Override public boolean isEmpty() {
                return CustomConcurrentHashMap.this.isEmpty();
            }

            @Override public boolean contains(Object o) {
                return CustomConcurrentHashMap.this.containsKey(o);
            }

            @Override public boolean remove(Object o) {
                return CustomConcurrentHashMap.this.remove(o) != null;
            }

            @Override public void clear() {
                CustomConcurrentHashMap.this.clear();
            }
        }

        final class Values extends AbstractCollection<V> {

            @Override public Iterator<V> iterator() {
                return new ValueIterator();
            }

            @Override public int size() {
                return CustomConcurrentHashMap.this.size();
            }

            @Override public boolean isEmpty() {
                return CustomConcurrentHashMap.this.isEmpty();
            }

            @Override public boolean contains(Object o) {
                return CustomConcurrentHashMap.this.containsValue(o);
            }

            @Override public void clear() {
                CustomConcurrentHashMap.this.clear();
            }
        }

        final class EntrySet extends AbstractSet<Entry<K, V>> {

            @Override public Iterator<Entry<K, V>> iterator() {
                return new EntryIterator();
            }

            @Override public boolean contains(Object o) {
                if (!(o instanceof Entry)) {
                    return false;
                }
                Entry<?, ?> e = (Entry<?, ?>) o;
                Object key = e.getKey();
                if (key == null) {
                    return false;
                }
                V v = CustomConcurrentHashMap.this.get(key);

                return v != null && valueEquivalence.equivalent(e.getValue(), v);
            }

            @Override public boolean remove(Object o) {
                if (!(o instanceof Entry)) {
                    return false;
                }
                Entry<?, ?> e = (Entry<?, ?>) o;
                Object key = e.getKey();
                return key != null
                        && CustomConcurrentHashMap.this.remove(key, e.getValue());
            }

            @Override public int size() {
                return CustomConcurrentHashMap.this.size();
            }

            @Override public boolean isEmpty() {
                return CustomConcurrentHashMap.this.isEmpty();
            }

            @Override public void clear() {
                CustomConcurrentHashMap.this.clear();
            }
        }



        private static final long serialVersionUID = 4;

        Object writeReplace() {
            return new SerializationProxy<K, V>(keyStrength, valueStrength,
                    keyEquivalence, valueEquivalence, expireAfterWriteNanos,
                    expireAfterAccessNanos, maximumSize, concurrencyLevel, evictionListener,
                    this);
        }


        abstract static class AbstractSerializationProxy<K, V>
                extends ForwardingConcurrentMap<K, V> implements Serializable {
            private static final long serialVersionUID = 2;

            final Strength keyStrength;
            final Strength valueStrength;
            final Equivalence<Object> keyEquivalence;
            final Equivalence<Object> valueEquivalence;
            final long expireAfterWriteNanos;
            final long expireAfterAccessNanos;
            final int maximumSize;
            final int concurrencyLevel;
            final MapEvictionListener<? super K, ? super V> evictionListener;

            transient ConcurrentMap<K, V> delegate;

            AbstractSerializationProxy(Strength keyStrength,
                                       Strength valueStrength,
                                       Equivalence<Object> keyEquivalence,
                                       Equivalence<Object> valueEquivalence,
                                       long expireAfterWriteNanos, long expireAfterAccessNanos,
                                       int maximumSize, int concurrencyLevel,
                                       MapEvictionListener<? super K, ? super V> evictionListener,
                                       ConcurrentMap<K, V> delegate) {
                this.keyStrength = keyStrength;
                this.valueStrength = valueStrength;
                this.keyEquivalence = keyEquivalence;
                this.valueEquivalence = valueEquivalence;
                this.expireAfterWriteNanos = expireAfterWriteNanos;
                this.expireAfterAccessNanos = expireAfterAccessNanos;
                this.maximumSize = maximumSize;
                this.concurrencyLevel = concurrencyLevel;
                this.evictionListener = evictionListener;
                this.delegate = delegate;
            }

            @Override
            protected ConcurrentMap<K, V> delegate() {
                return delegate;
            }

            void writeMapTo(ObjectOutputStream out) throws IOException {
                out.writeInt(delegate.size());
                for (Entry<K, V> entry : delegate.entrySet()) {
                    out.writeObject(entry.getKey());
                    out.writeObject(entry.getValue());
                }
                out.writeObject(null); // terminate entries
            }

            MapMaker readMapMaker(ObjectInputStream in) throws IOException {
                int size = in.readInt();
                MapMaker mapMaker = new MapMaker()
                        .initialCapacity(size)
                        .setKeyStrength(keyStrength)
                        .setValueStrength(valueStrength)
                        .privateKeyEquivalence(keyEquivalence)
                        .privateValueEquivalence(valueEquivalence)
                        .concurrencyLevel(concurrencyLevel);
                mapMaker.evictionListener(evictionListener);
                if (expireAfterWriteNanos > 0) {
                    mapMaker.expireAfterWrite(expireAfterWriteNanos, TimeUnit.NANOSECONDS);
                }
                if (expireAfterAccessNanos > 0) {
                    mapMaker.expireAfterAccess(
                            expireAfterAccessNanos, TimeUnit.NANOSECONDS);
                }
                if (maximumSize != MapMaker.UNSET_INT) {
                    mapMaker.maximumSize(maximumSize);
                }
                return mapMaker;
            }

            @SuppressWarnings("unchecked")
            void readEntries(ObjectInputStream in) throws IOException,
                    ClassNotFoundException {
                while (true) {
                    K key = (K) in.readObject();
                    if (key == null) {
                        break; // terminator
                    }
                    V value = (V) in.readObject();
                    delegate.put(key, value);
                }
            }
        }


        private static class SerializationProxy<K, V>
                extends AbstractSerializationProxy<K, V> {
            private static final long serialVersionUID = 2;

            SerializationProxy(Strength keyStrength,
                               Strength valueStrength,
                               Equivalence<Object> keyEquivalence,
                               Equivalence<Object> valueEquivalence,
                               long expireAfterWriteNanos,
                               long expireAfterAccessNanos,
                               int maximumSize,
                               int concurrencyLevel,
                               MapEvictionListener<? super K, ? super V> evictionListener,
                               ConcurrentMap<K, V> delegate) {
                super(keyStrength, valueStrength, keyEquivalence, valueEquivalence,
                        expireAfterWriteNanos, expireAfterAccessNanos, maximumSize,
                        concurrencyLevel, evictionListener, delegate);
            }

            private void writeObject(ObjectOutputStream out) throws IOException {
                out.defaultWriteObject();
                writeMapTo(out);
            }

            @SuppressWarnings("unchecked")
            private void readObject(ObjectInputStream in)
                    throws IOException, ClassNotFoundException {
                in.defaultReadObject();
                MapMaker mapMaker = readMapMaker(in);
                delegate = mapMaker.makeMap();
                readEntries(in);
            }

            private Object readResolve() {
                return delegate;
            }
        }
    }
    static class ComputingConcurrentHashMap<K, V> extends CustomConcurrentHashMap<K, V>
            implements Cache<K, V> {
        final Function<? super K, ? extends V> computingFunction;


        ComputingConcurrentHashMap(MapMaker builder,
                                   Function<? super K, ? extends V> computingFunction) {
            super(builder);
            this.computingFunction = checkNotNull(computingFunction);
        }

        @Override
        public ConcurrentMap<K, V> asMap() {
            return this;
        }

        @Override Segment createSegment(int initialCapacity, int maxSegmentSize) {
            return new ComputingSegment(initialCapacity, maxSegmentSize);
        }

        @SuppressWarnings("unchecked") // explain
        @Override ComputingSegment segmentFor(int hash) {
            return (ComputingSegment) super.segmentFor(hash);
        }

        @Override
        public V apply(K key) {
            int hash = hash(key);
            return segmentFor(hash).compute(key, hash);
        }

        @SuppressWarnings("serial") // This class is never serialized.
        class ComputingSegment extends Segment {
            ComputingSegment(int initialCapacity, int maxSegmentSize) {
                super(initialCapacity, maxSegmentSize);
            }

            V compute(K key, int hash) {
                outer: while (true) {
                    V value = get(key, hash);
                    if (value != null) {
                        return value;
                    }

                    ReferenceEntry<K, V> entry = null;
                    ComputingValueReference computingValueReference = null;
                    lock();
                    try {
                        // Try again--an entry could have materialized in the interim.
                        preWriteCleanup();

                        // getFirst, but remember the index
                        AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
                        int index = hash & (table.length() - 1);
                        ReferenceEntry<K, V> first = table.get(index);

                        for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {
                            K entryKey = e.getKey();
                            if (e.getHash() == hash && entryKey != null
                                    && keyEquivalence.equivalent(key, entryKey)) {
                                if (!e.getValueReference().isComputingReference()) {
                                    // never return expired entries
                                    value = getLiveValue(e);
                                    if (value != null) {
                                        recordLockedRead(e);
                                        return value;
                                    }
                                    // clobber invalid entries
                                    unsetLiveEntry(e, hash);
                                }
                                entry = e;
                                break;
                            }
                        }

                        if (entry == null || isUnset(entry)) {
                            // Create a new entry.
                            computingValueReference = new ComputingValueReference();

                            if (entry == null) {
                                entry = newEntry(key, hash, first);
                                table.set(index, entry);
                            }
                            entry.setValueReference(computingValueReference);
                        }
                    } finally {
                        unlock();
                        postWriteCleanup();
                    }

                    if (computingValueReference != null) {
                        // This thread solely created the entry.
                        try {
                            // Synchronizes on the entry to allow failing fast when a
                            // recursive computation is detected. This is not fool-proof
                            // since the entry may be copied when the segment is written to.
                            synchronized (entry) {
                                value = computingValueReference.compute(key, hash);
                            }
                            checkNotNull(value, "compute() returned null unexpectedly");
                            return value;
                        } finally {
                            if (value == null) {
                                clearValue(key, hash, computingValueReference);
                            }
                        }
                    }

                    // The entry already exists. Wait for the computation.
                    boolean interrupted = false;
                    try {
                        while (true) {
                            try {
                                checkState(!Thread.holdsLock(entry), "Recursive computation");
                                value = entry.getValueReference().waitForValue();
                                // don't consider expiration as we're concurrent with computation
                                if (value != null) {
                                    recordRead(entry);
                                    return value;
                                }
                                // else computing thread will clearValue
                                continue outer;
                            } catch (InterruptedException e) {
                                interrupted = true;
                            }
                        }
                    } finally {
                        if (interrupted) {
                            Thread.currentThread().interrupt();
                        }
                    }
                }
            }
        }

        /** Used to provide null pointer exceptions to other threads. */
        private static class NullPointerExceptionReference<K, V>
                implements ValueReference<K, V> {
            final String message;
            NullPointerExceptionReference(String message) {
                this.message = message;
            }
            @Override
            public V get() {
                return null;
            }
            @Override
            public ValueReference<K, V> copyFor(ReferenceEntry<K, V> entry) {
                return this;
            }
            @Override
            public boolean isComputingReference() {
                return false;
            }
            @Override
            public V waitForValue() {
                throw new NullPointerException(message);
            }
            @Override
            public void notifyValueReclaimed() {}
            @Override
            public void clear() {}
        }


        private static class ComputationExceptionReference<K, V>
                implements ValueReference<K, V> {
            final Throwable t;
            ComputationExceptionReference(Throwable t) {
                this.t = t;
            }
            @Override
            public V get() {
                return null;
            }
            @Override
            public ValueReference<K, V> copyFor(ReferenceEntry<K, V> entry) {
                return this;
            }
            @Override
            public boolean isComputingReference() {
                return false;
            }
            @Override
            public V waitForValue() {
                throw new AsynchronousComputationException(t);
            }
            @Override
            public void notifyValueReclaimed() {}
            @Override
            public void clear() {}
        }


        private static class ComputedReference<K, V> implements ValueReference<K, V> {
            final V value;
            ComputedReference(@Nullable V value) {
                this.value = value;
            }
            @Override
            public V get() {
                return value;
            }
            @Override
            public ValueReference<K, V> copyFor(ReferenceEntry<K, V> entry) {
                return this;
            }
            @Override
            public boolean isComputingReference() {
                return false;
            }
            @Override
            public V waitForValue() {
                return get();
            }
            @Override
            public void notifyValueReclaimed() {}
            @Override
            public void clear() {}
        }

        private class ComputingValueReference implements ValueReference<K, V> {
             // writes
                    ValueReference<K, V> computedReference = unset();

            @Override
            public V get() {
                // All computation lookups go through waitForValue. This method thus is
                // only used by put, to whom we always want to appear absent.
                return null;
            }

            @Override
            public ValueReference<K, V> copyFor(ReferenceEntry<K, V> entry) {
                return this;
            }

            @Override
            public boolean isComputingReference() {
                return true;
            }


            @Override
            public V waitForValue() throws InterruptedException {
                if (computedReference == UNSET) {
                    synchronized (this) {
                        if (computedReference == UNSET) {
                            wait();
                        }
                    }
                }
                return computedReference.waitForValue();
            }

            @Override
            public void clear() {
                // The pending computation was clobbered by a manual write. Unblock all
                // pending gets, and have them return the new value.
                setValueReference(new ComputedReference<K, V>(null));

                // TODO(user): could also cancel computation if we had a thread handle
            }

            @Override
            public void notifyValueReclaimed() {}

            V compute(K key, int hash) {
                V value;
                try {
                    value = computingFunction.apply(key);
                } catch (ComputationException e) {
                    // if computingFunction has thrown a computation exception,
                    // propagate rather than wrap
                    setValueReference(
                            new ComputationExceptionReference<K, V>(e.getCause()));
                    throw e;
                } catch (Throwable t) {
                    setValueReference(new ComputationExceptionReference<K, V>(t));
                    throw new ComputationException(t);
                }

                if (value == null) {
                    String message =
                            computingFunction + " returned null for key " + key + ".";
                    setValueReference(new NullPointerExceptionReference<K, V>(message));
                    throw new NullPointerException(message);
                }

                // Call setValueReference first to avoid put clearing us.
                setValueReference(new ComputedReference<K, V>(value));
                // putIfAbsent
                segmentFor(hash).put(key, hash, value, true);
                return value;
            }

            void setValueReference(ValueReference<K, V> valueReference) {
                synchronized (this) {
                    if (computedReference == UNSET) {
                        computedReference = valueReference;
                        notifyAll();
                    }
                }
            }
        }

  /* ---------------- Serialization Support -------------- */

        private static final long serialVersionUID = 2;

        @Override Object writeReplace() {
            return new ComputingSerializationProxy<K, V>(keyStrength, valueStrength,
                    keyEquivalence, valueEquivalence, expireAfterWriteNanos,
                    expireAfterAccessNanos, maximumSize, concurrencyLevel, evictionListener,
                    this, computingFunction);
        }

        static class ComputingSerializationProxy<K, V>
                extends AbstractSerializationProxy<K, V> {

            final Function<? super K, ? extends V> computingFunction;
            transient Cache<K, V> cache;

            ComputingSerializationProxy(Strength keyStrength,
                                        Strength valueStrength,
                                        Equivalence<Object> keyEquivalence,
                                        Equivalence<Object> valueEquivalence,
                                        long expireAfterWriteNanos,
                                        long expireAfterAccessNanos,
                                        int maximumSize,
                                        int concurrencyLevel,
                                        MapEvictionListener<? super K, ? super V> evictionListener,
                                        ConcurrentMap<K, V> delegate,
                                        Function<? super K, ? extends V> computingFunction) {
                super(keyStrength, valueStrength, keyEquivalence, valueEquivalence,
                        expireAfterWriteNanos, expireAfterAccessNanos, maximumSize,
                        concurrencyLevel, evictionListener, delegate);
                this.computingFunction = computingFunction;
            }

            private void writeObject(ObjectOutputStream out)
                    throws IOException {
                out.defaultWriteObject();
                writeMapTo(out);
            }

            @SuppressWarnings("unchecked")
            private void readObject(ObjectInputStream in)
                    throws IOException, ClassNotFoundException {
                in.defaultReadObject();
                MapMaker mapMaker = readMapMaker(in);
                cache = mapMaker.makeCache(computingFunction);
                delegate = cache.asMap();
                readEntries(in);
            }

            Object readResolve() {
                return cache;
            }

            public ConcurrentMap<K, V> asMap() {
                return delegate;
            }

            public V apply(@Nullable K from) {
                return cache.apply(from);
            }

            private static final long serialVersionUID = 2;
        }
    }
    public static class ComputationException extends RuntimeException {

        public ComputationException(Throwable cause) {
            super(cause);
        }
        private static final long serialVersionUID = 0;
    }
    public static class AsynchronousComputationException extends ComputationException {

        public AsynchronousComputationException(Throwable cause) {
            super(cause);
        }
        private static final long serialVersionUID = 0;
    }

    public interface MapDifference<K, V> {

        boolean areEqual();

        Map<K, V> entriesOnlyOnLeft();

        Map<K, V> entriesOnlyOnRight();

        Map<K, V> entriesInCommon();

        Map<K, ValueDifference<V>> entriesDiffering();

        @Override
        boolean equals(@Nullable Object object);

        @Override
        int hashCode();

        interface ValueDifference<V> {

            V leftValue();

            V rightValue();

            @Override boolean equals(@Nullable Object other);


            @Override int hashCode();
        }

    }
    final static class EmptyImmutableSet extends ImmutableSet<Object> {
        static final EmptyImmutableSet INSTANCE = new EmptyImmutableSet();

        private EmptyImmutableSet() {}

        @Override
        public int size() {
            return 0;
        }

        @Override public boolean isEmpty() {
            return true;
        }

        @Override public boolean contains(Object target) {
            return false;
        }

        @Override public UnmodifiableIterator<Object> iterator() {
            return Iterators.emptyIterator();
        }

        @Override boolean isPartialView() {
            return false;
        }

        private static final Object[] EMPTY_ARRAY = new Object[0];

        @Override public Object[] toArray() {
            return EMPTY_ARRAY;
        }

        @Override public <T> T[] toArray(T[] a) {
            if (a.length > 0) {
                a[0] = null;
            }
            return a;
        }

        @Override public boolean containsAll(Collection<?> targets) {
            return targets.isEmpty();
        }

        @Override public boolean equals(@Nullable Object object) {
            if (object instanceof Set) {
                Set<?> that = (Set<?>) object;
                return that.isEmpty();
            }
            return false;
        }

        @Override public final int hashCode() {
            return 0;
        }

        @Override boolean isHashCodeFast() {
            return true;
        }

        @Override public String toString() {
            return "[]";
        }

        Object readResolve() {
            return INSTANCE; // preserve singleton property
        }

        private static final long serialVersionUID = 0;
    }
    static final class ByFunctionOrdering<F, T>
            extends Ordering<F> implements Serializable {
        final Function<F, ? extends T> function;
        final Ordering<T> ordering;

        ByFunctionOrdering(
                Function<F, ? extends T> function, Ordering<T> ordering) {
            this.function = checkNotNull(function);
            this.ordering = checkNotNull(ordering);
        }

        @Override public int compare(F left, F right) {
            return ordering.compare(function.apply(left), function.apply(right));
        }

        @Override public boolean equals(@Nullable Object object) {
            if (object == this) {
                return true;
            }
            if (object instanceof ByFunctionOrdering) {
                ByFunctionOrdering<?, ?> that = (ByFunctionOrdering<?, ?>) object;
                return this.function.equals(that.function)
                        && this.ordering.equals(that.ordering);
            }
            return false;
        }

        @Override public int hashCode() {
            return Objects.hashCode(function, ordering);
        }

        @Override public String toString() {
            return ordering + ".onResultOf(" + function + ")";
        }

        private static final long serialVersionUID = 0;
    }
    static final class ComparatorOrdering<T> extends Ordering<T> implements Serializable {
        final Comparator<T> comparator;

        ComparatorOrdering(Comparator<T> comparator) {
            this.comparator = checkNotNull(comparator);
        }

        @Override public int compare(T a, T b) {
            return comparator.compare(a, b);
        }

        // Override just to remove a level of indirection from inner loops
        @Override public int binarySearch(List<? extends T> sortedList, T key) {
            return Collections.binarySearch(sortedList, key, comparator);
        }

        // Override just to remove a level of indirection from inner loops
        @Override public <E extends T> List<E> sortedCopy(Iterable<E> iterable) {
            List<E> list = Lists.newArrayList(iterable);
            Collections.sort(list, comparator);
            return list;
        }

        @Override public boolean equals(@Nullable Object object) {
            if (object == this) {
                return true;
            }
            if (object instanceof ComparatorOrdering) {
                ComparatorOrdering<?> that = (ComparatorOrdering<?>) object;
                return this.comparator.equals(that.comparator);
            }
            return false;
        }

        @Override public int hashCode() {
            return comparator.hashCode();
        }

        @Override public String toString() {
            return comparator.toString();
        }

        private static final long serialVersionUID = 0;
    }
    static final class CompoundOrdering<T> extends Ordering<T> implements Serializable {
        final ImmutableList<Comparator<? super T>> comparators;

        CompoundOrdering(Comparator<? super T> primary,
                         Comparator<? super T> secondary) {
            this.comparators
                    = ImmutableList.<Comparator<? super T>>of(primary, secondary);
        }

        CompoundOrdering(Iterable<? extends Comparator<? super T>> comparators) {
            this.comparators = ImmutableList.copyOf(comparators);
        }

        CompoundOrdering(List<? extends Comparator<? super T>> comparators,
                         Comparator<? super T> lastComparator) {
            this.comparators = new ImmutableList.Builder<Comparator<? super T>>()
                    .addAll(comparators).add(lastComparator).build();
        }

        @Override public int compare(T left, T right) {
            for (Comparator<? super T> comparator : comparators) {
                int result = comparator.compare(left, right);
                if (result != 0) {
                    return result;
                }
            }
            return 0;
        }

        @Override public boolean equals(Object object) {
            if (object == this) {
                return true;
            }
            if (object instanceof CompoundOrdering) {
                CompoundOrdering<?> that = (CompoundOrdering<?>) object;
                return this.comparators.equals(that.comparators);
            }
            return false;
        }

        @Override public int hashCode() {
            return comparators.hashCode();
        }

        @Override public String toString() {
            return "Ordering.compound(" + comparators + ")";
        }

        private static final long serialVersionUID = 0;
    }
    static final class ImmutableSortedAsList<E> extends ImmutableList<E> {
        private final transient ImmutableSortedSet<E> backingSet;
        private final transient ImmutableList<E> backingList;

        ImmutableSortedAsList(
                ImmutableSortedSet<E> backingSet, ImmutableList<E> backingList) {
            this.backingSet = backingSet;
            this.backingList = backingList;
        }

        // Override contains(), indexOf(), and lastIndexOf() to be O(log N) instead of
        // O(N).

        @Override public boolean contains(Object target) {
            return backingSet.indexOf(target) >= 0;
        }

        @Override public int indexOf(Object target) {
            return backingSet.indexOf(target);
        }

        @Override public int lastIndexOf(Object target) {
            return backingSet.indexOf(target);
        }

        // The returned ImmutableSortedAsList maintains the contains(), indexOf(), and
        // lastIndexOf() performance benefits.
        @Override public ImmutableList<E> subList(int fromIndex, int toIndex) {
            Preconditions.checkPositionIndexes(fromIndex, toIndex, size());
            return (fromIndex == toIndex) ? ImmutableList.<E>of()
                    : new RegularImmutableSortedSet<E>(
                    backingList.subList(fromIndex, toIndex), backingSet.comparator())
                    .asList();
        }

        // The ImmutableAsList serialized form has the correct behavior.
        @Override Object writeReplace() {
            return new ImmutableAsList.SerializedForm(backingSet);
        }

        @Override public UnmodifiableIterator<E> iterator() {
            return backingList.iterator();
        }

        @Override public E get(int index) {
            return backingList.get(index);
        }

        @Override public UnmodifiableListIterator<E> listIterator() {
            return backingList.listIterator();
        }

        @Override public UnmodifiableListIterator<E> listIterator(int index) {
            return backingList.listIterator(index);
        }

        @Override public int size() {
            return backingList.size();
        }

        @Override public boolean equals(@Nullable Object obj) {
            return backingList.equals(obj);
        }

        @Override public int hashCode() {
            return backingList.hashCode();
        }

        @Override boolean isPartialView() {
            return backingList.isPartialView();
        }
    }
    static final class ImmutableAsList<E> extends RegularImmutableList<E> {
        private final transient ImmutableCollection<E> collection;

        ImmutableAsList(Object[] array, ImmutableCollection<E> collection) {
            super(array, 0, array.length);
            this.collection = collection;
        }

        @Override public boolean contains(Object target) {
            // The collection's contains() is at least as fast as RegularImmutableList's
            // and is often faster.
            return collection.contains(target);
        }

        static class SerializedForm implements Serializable {
            final ImmutableCollection<?> collection;
            SerializedForm(ImmutableCollection<?> collection) {
                this.collection = collection;
            }
            Object readResolve() {
                return collection.asList();
            }
            private static final long serialVersionUID = 0;
        }

        private void readObject(ObjectInputStream stream)
                throws InvalidObjectException {
            throw new InvalidObjectException("Use SerializedForm");
        }

        @Override Object writeReplace() {
            return new SerializedForm(collection);
        }
    }
    static class EmptyImmutableSortedSet<E> extends ImmutableSortedSet<E> {
        EmptyImmutableSortedSet(Comparator<? super E> comparator) {
            super(comparator);
        }

        public int size() {
            return 0;
        }

        @Override public boolean isEmpty() {
            return true;
        }

        @Override public boolean contains(Object target) {
            return false;
        }

        @Override public UnmodifiableIterator<E> iterator() {
            return Iterators.emptyIterator();
        }

        @Override boolean isPartialView() {
            return false;
        }

        private static final Object[] EMPTY_ARRAY = new Object[0];

        @Override public Object[] toArray() {
            return EMPTY_ARRAY;
        }

        @Override public <T> T[] toArray(T[] a) {
            if (a.length > 0) {
                a[0] = null;
            }
            return a;
        }

        @Override public boolean containsAll(Collection<?> targets) {
            return targets.isEmpty();
        }

        @Override public boolean equals(@Nullable Object object) {
            if (object instanceof Set) {
                Set<?> that = (Set<?>) object;
                return that.isEmpty();
            }
            return false;
        }

        @Override public int hashCode() {
            return 0;
        }

        @Override public String toString() {
            return "[]";
        }

        public E first() {
            throw new NoSuchElementException();
        }

        public E last() {
            throw new NoSuchElementException();
        }

        @Override ImmutableSortedSet<E> headSetImpl(E toElement) {
            return this;
        }

        @Override ImmutableSortedSet<E> subSetImpl(E fromElement, E toElement) {
            return this;
        }

        @Override ImmutableSortedSet<E> tailSetImpl(E fromElement) {
            return this;
        }

        @Override int indexOf(Object target) {
            return -1;
        }
    }
    static final class SingletonImmutableList<E> extends ImmutableList<E> {

        final transient E element;

        SingletonImmutableList(E element) {
            this.element = checkNotNull(element);
        }

        public E get(int index) {
            Preconditions.checkElementIndex(index, 1);
            return element;
        }

        @Override public int indexOf(@Nullable Object object) {
            return element.equals(object) ? 0 : -1;
        }

        @Override public UnmodifiableIterator<E> iterator() {
            return Iterators.singletonIterator(element);
        }

        @Override public int lastIndexOf(@Nullable Object object) {
            return element.equals(object) ? 0 : -1;
        }

        @Override public UnmodifiableListIterator<E> listIterator(final int start) {
            Preconditions.checkPositionIndex(start, 1);
            return new UnmodifiableListIterator<E>() {

                boolean hasNext = start == 0;

                @Override public boolean hasNext() {
                    return hasNext;
                }

                @Override public boolean hasPrevious() {
                    return !hasNext;
                }

                @Override public E next() {
                    if (!hasNext) {
                        throw new NoSuchElementException();
                    }
                    hasNext = false;
                    return element;
                }

                @Override public int nextIndex() {
                    return hasNext ? 0 : 1;
                }

                @Override public E previous() {
                    if (hasNext) {
                        throw new NoSuchElementException();
                    }
                    hasNext = true;
                    return element;
                }

                @Override public int previousIndex() {
                    return hasNext ? -1 : 0;
                }
            };
        }

        public int size() {
            return 1;
        }

        @Override public ImmutableList<E> subList(int fromIndex, int toIndex) {
            Preconditions.checkPositionIndexes(fromIndex, toIndex, 1);
            return (fromIndex == toIndex) ? ImmutableList.<E>of() : this;
        }

        @Override public ImmutableList<E> reverse() {
            return this;
        }

        @Override public boolean contains(@Nullable Object object) {
            return element.equals(object);
        }

        @Override public boolean equals(Object object) {
            if (object == this) {
                return true;
            }
            if (object instanceof List) {
                List<?> that = (List<?>) object;
                return that.size() == 1 && element.equals(that.get(0));
            }
            return false;
        }

        @Override public int hashCode() {
            // not caching hash code since it could change if the element is mutable
            // in a way that modifies its hash code.
            return 31 + element.hashCode();
        }

        @Override public String toString() {
            String elementToString = element.toString();
            return new StringBuilder(elementToString.length() + 2)
                    .append('[')
                    .append(elementToString)
                    .append(']')
                    .toString();
        }

        @Override public boolean isEmpty() {
            return false;
        }

        @Override boolean isPartialView() {
            return false;
        }

        @Override public Object[] toArray() {
            return new Object[] { element };
        }

        @Override public <T> T[] toArray(T[] array) {
            if (array.length == 0) {
                array = ObjectArrays.newArray(array, 1);
            } else if (array.length > 1) {
                array[1] = null;
            }
            // Writes will produce ArrayStoreException when the toArray() doc requires.
            Object[] objectArray = array;
            objectArray[0] = element;
            return array;
        }
    }
    static final class ExplicitOrderedImmutableSortedSet<E>
            extends ImmutableSortedSet<E> {

        static <E> ImmutableSortedSet<E> create(List<E> list) {
            ExplicitOrdering<E> ordering = new ExplicitOrdering<E>(list);
            if (ordering.rankMap.isEmpty()) {
                return emptySet(ordering);
            }
            // Not using list.toArray() to avoid iterating across the input list twice.
            Object[] elements = ordering.rankMap.keySet().toArray();
            return new ExplicitOrderedImmutableSortedSet<E>(elements, ordering);
        }

        private final Object[] elements;

        private final int fromIndex;

        private final int toIndex;

        ExplicitOrderedImmutableSortedSet(Object[] elements,
                                          Comparator<? super E> comparator) {
            this(elements, comparator, 0, elements.length);
        }

        ExplicitOrderedImmutableSortedSet(Object[] elements,
                                          Comparator<? super E> comparator, int fromIndex, int toIndex) {
            super(comparator);
            this.elements = elements;
            this.fromIndex = fromIndex;
            this.toIndex = toIndex;
        }

        // create() generates an ImmutableMap<E, Integer> rankMap.
        @SuppressWarnings("unchecked")
        private ImmutableMap<E, Integer> rankMap() {
            ExplicitOrdering<E> eo = (ExplicitOrdering<E>) comparator();
            return eo.rankMap;
        }

        // create() ensures that every element is an E.
        @SuppressWarnings("unchecked")
        @Override public UnmodifiableIterator<E> iterator() {
            return (UnmodifiableIterator<E>)
                    Iterators.forArray(elements, fromIndex, size());
        }

        @Override public boolean isEmpty() {
            return false;
        }

        @Override
        public int size() {
            return toIndex - fromIndex;
        }

        @Override public boolean contains(Object o) {
            Integer index = rankMap().get(o);
            return (index != null && index >= fromIndex && index < toIndex);
        }

        @Override boolean isPartialView() {
            return fromIndex != 0 || toIndex != elements.length;
        }

        @Override public Object[] toArray() {
            Object[] array = new Object[size()];
            Platform.unsafeArrayCopy(elements, fromIndex, array, 0, size());
            return array;
        }

        // TODO(jlevy): Move to ObjectArrays (same code in ImmutableList).
        @Override public <T> T[] toArray(T[] array) {
            int size = size();
            if (array.length < size) {
                array = ObjectArrays.newArray(array, size);
            } else if (array.length > size) {
                array[size] = null;
            }
            Platform.unsafeArrayCopy(elements, fromIndex, array, 0, size);
            return array;
        }

        @Override public int hashCode() {
            // TODO(jlevy): Cache hash code?
            int hash = 0;
            for (int i = fromIndex; i < toIndex; i++) {
                hash += elements[i].hashCode();
            }
            return hash;
        }

        // The factory methods ensure that every element is an E.
        @Override
        @SuppressWarnings("unchecked")
        public E first() {
            return (E) elements[fromIndex];
        }

        // The factory methods ensure that every element is an E.
        @Override
        @SuppressWarnings("unchecked")
        public E last() {
            return (E) elements[toIndex - 1];
        }

        @Override ImmutableSortedSet<E> headSetImpl(E toElement) {
            return createSubset(fromIndex, findSubsetIndex(toElement));
        }

        // TODO(jlevy): Override subSet to avoid redundant map lookups.
        @Override ImmutableSortedSet<E> subSetImpl(E fromElement, E toElement) {
            return createSubset(
                    findSubsetIndex(fromElement), findSubsetIndex(toElement));
        }

        @Override ImmutableSortedSet<E> tailSetImpl(E fromElement) {
            return createSubset(findSubsetIndex(fromElement), toIndex);
        }

        private int findSubsetIndex(E element) {
            Integer index = rankMap().get(element);
            if (index == null) {
                // TODO(kevinb): Make Ordering.IncomparableValueException public, use it
                throw new ClassCastException();
            }
            if (index <= fromIndex) {
                return fromIndex;
            } else if (index >= toIndex) {
                return toIndex;
            } else {
                return index;
            }
        }

        private ImmutableSortedSet<E> createSubset(
                int newFromIndex, int newToIndex) {
            if (newFromIndex < newToIndex) {
                return new ExplicitOrderedImmutableSortedSet<E>(elements, comparator,
                        newFromIndex, newToIndex);
            } else {
                return emptySet(comparator);
            }
        }

        @Override int indexOf(Object target) {
            Integer index = rankMap().get(target);
            return (index != null && index >= fromIndex && index < toIndex)
                    ? index - fromIndex : -1;
        }

        /*
         * TODO(jlevy): Modify ImmutableSortedAsList.subList() so it creates a list
         * based on an ExplicitOrderedImmutableSortedSet when the original list was
         * constructed from one, for faster contains(), indexOf(), and lastIndexOf().
         */
        @Override ImmutableList<E> createAsList() {
            return new ImmutableSortedAsList<E>(
                    this, new RegularImmutableList<E>(elements, fromIndex, size()));
        }

        /*
         * Generates an ExplicitOrderedImmutableSortedSet when deserialized, for
         * better performance.
         */
        private static class SerializedForm<E> implements Serializable {
            final Object[] elements;

            public SerializedForm(Object[] elements) {
                this.elements = elements;
            }

            @SuppressWarnings("deprecation") // serialization for deprecated method
            Object readResolve() {
                return ImmutableSortedSet.withExplicitOrder(Arrays.asList(elements));
            }

            private static final long serialVersionUID = 0;
        }

        private void readObject(ObjectInputStream stream)
                throws InvalidObjectException {
            throw new InvalidObjectException("Use SerializedForm");
        }

        @Override Object writeReplace() {
            return new SerializedForm<E>(toArray());
        }
    }
    static public class ImmutableSortedMap<K, V>
            extends ImmutableSortedMapFauxverideShim<K, V> implements SortedMap<K, V> {


        private static final Comparator<Comparable> NATURAL_ORDER =
                Ordering.natural();

        private static final ImmutableSortedMap<Comparable, Object>
                NATURAL_EMPTY_MAP =
                new ImmutableSortedMap<Comparable, Object>(
                        ImmutableList.<Entry<Comparable, Object>>of(), NATURAL_ORDER);


        @SuppressWarnings("unchecked")
        // unsafe, comparator() returns a comparator on the specified type
        // TODO(kevinb): evaluate whether or not of().comparator() should return null
        public static <K, V> ImmutableSortedMap<K, V> of() {
            return (ImmutableSortedMap<K, V>) NATURAL_EMPTY_MAP;
        }

        @SuppressWarnings("unchecked")
        private static <K, V> ImmutableSortedMap<K, V> emptyMap(
                Comparator<? super K> comparator) {
            if (NATURAL_ORDER.equals(comparator)) {
                return (ImmutableSortedMap<K, V>) NATURAL_EMPTY_MAP;
            } else {
                return new ImmutableSortedMap<K, V>(
                        ImmutableList.<Entry<K, V>>of(), comparator);
            }
        }


        public static <K extends Comparable<? super K>, V>
        ImmutableSortedMap<K, V> of(K k1, V v1) {
            return new ImmutableSortedMap<K, V>(
                    ImmutableList.of(entryOf(k1, v1)), Ordering.natural());
        }


        public static <K extends Comparable<? super K>, V> ImmutableSortedMap<K, V>
        of(K k1, V v1, K k2, V v2) {
            return new Builder<K, V>(Ordering.natural())
                    .put(k1, v1).put(k2, v2).build();
        }


        public static <K extends Comparable<? super K>, V> ImmutableSortedMap<K, V>
        of(K k1, V v1, K k2, V v2, K k3, V v3) {
            return new Builder<K, V>(Ordering.natural())
                    .put(k1, v1).put(k2, v2).put(k3, v3).build();
        }


        public static <K extends Comparable<? super K>, V> ImmutableSortedMap<K, V>
        of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {
            return new Builder<K, V>(Ordering.natural())
                    .put(k1, v1).put(k2, v2).put(k3, v3).put(k4, v4).build();
        }

        public static <K extends Comparable<? super K>, V> ImmutableSortedMap<K, V>
        of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {
            return new Builder<K, V>(Ordering.natural())
                    .put(k1, v1).put(k2, v2).put(k3, v3).put(k4, v4).put(k5, v5).build();
        }


        public static <K, V> ImmutableSortedMap<K, V> copyOf(
                Map<? extends K, ? extends V> map) {
            // Hack around K not being a subtype of Comparable.
            // Unsafe, see ImmutableSortedSetFauxverideShim.
            @SuppressWarnings("unchecked")
            Ordering<K> naturalOrder = (Ordering<K>) Ordering.<Comparable>natural();
            return copyOfInternal(map, naturalOrder);
        }


        public static <K, V> ImmutableSortedMap<K, V> copyOf(
                Map<? extends K, ? extends V> map, Comparator<? super K> comparator) {
            return copyOfInternal(map, checkNotNull(comparator));
        }


        @SuppressWarnings("unchecked")
        public static <K, V> ImmutableSortedMap<K, V> copyOfSorted(
                SortedMap<K, ? extends V> map) {
            Comparator<? super K> comparator = map.comparator();
            if (comparator == null) {
                // If map has a null comparator, the keys should have a natural ordering,
                // even though K doesn't explicitly implement Comparable.
                comparator = (Comparator<? super K>) NATURAL_ORDER;
            }
            return copyOfInternal(map, comparator);
        }

        private static <K, V> ImmutableSortedMap<K, V> copyOfInternal(
                Map<? extends K, ? extends V> map, Comparator<? super K> comparator) {
            boolean sameComparator = false;
            if (map instanceof SortedMap) {
                SortedMap<?, ?> sortedMap = (SortedMap<?, ?>) map;
                Comparator<?> comparator2 = sortedMap.comparator();
                sameComparator = (comparator2 == null)
                        ? comparator == NATURAL_ORDER
                        : comparator.equals(comparator2);
            }

            if (sameComparator && (map instanceof ImmutableSortedMap)) {
                // TODO(kevinb): Prove that this cast is safe, even though
                // Collections.unmodifiableSortedMap requires the same key type.
                @SuppressWarnings("unchecked")
                ImmutableSortedMap<K, V> kvMap = (ImmutableSortedMap<K, V>) map;
                if (!kvMap.isPartialView()) {
                    return kvMap;
                }
            }


            @SuppressWarnings("unchecked")
            Entry<K, V>[] entries = map.entrySet().toArray(new Entry[0]);

            for (int i = 0; i < entries.length; i++) {
                Entry<K, V> entry = entries[i];
                entries[i] = entryOf(entry.getKey(), entry.getValue());
            }

            List<Entry<K, V>> list = Arrays.asList(entries);

            if (!sameComparator) {
                sortEntries(list, comparator);
                validateEntries(list, comparator);
            }

            return new ImmutableSortedMap<K, V>(ImmutableList.copyOf(list), comparator);
        }

        private static <K, V> void sortEntries(
                List<Entry<K, V>> entries, final Comparator<? super K> comparator) {
            Comparator<Entry<K, V>> entryComparator = new Comparator<Entry<K, V>>() {

                @Override public int compare(Entry<K, V> entry1, Entry<K, V> entry2) {
                    return comparator.compare(entry1.getKey(), entry2.getKey());
                }
            };

            Collections.sort(entries, entryComparator);
        }

        private static <K, V> void validateEntries(List<Entry<K, V>> entries,
                                                   Comparator<? super K> comparator) {
            for (int i = 1; i < entries.size(); i++) {
                if (comparator.compare(
                        entries.get(i - 1).getKey(), entries.get(i).getKey()) == 0) {
                    throw new IllegalArgumentException(
                            "Duplicate keys in mappings " + entries.get(i - 1) + " and "
                                    + entries.get(i));
                }
            }
        }


        public static <K extends Comparable<K>, V> Builder<K, V> naturalOrder() {
            return new Builder<K, V>(Ordering.natural());
        }


        public static <K, V> Builder<K, V> orderedBy(Comparator<K> comparator) {
            return new Builder<K, V>(comparator);
        }

        public static <K extends Comparable<K>, V> Builder<K, V> reverseOrder() {
            return new Builder<K, V>(Ordering.natural().reverse());
        }


        public static class Builder<K, V> extends ImmutableMap.Builder<K, V> {
            private final Comparator<? super K> comparator;


            public Builder(Comparator<? super K> comparator) {
                this.comparator = checkNotNull(comparator);
            }


            @Override public Builder<K, V> put(K key, V value) {
                entries.add(entryOf(key, value));
                return this;
            }


            @Override public Builder<K, V> putAll(Map<? extends K, ? extends V> map) {
                for (Entry<? extends K, ? extends V> entry : map.entrySet()) {
                    put(entry.getKey(), entry.getValue());
                }
                return this;
            }


            @Override public ImmutableSortedMap<K, V> build() {
                sortEntries(entries, comparator);
                validateEntries(entries, comparator);
                return new ImmutableSortedMap<K, V>(
                        ImmutableList.copyOf(entries), comparator);
            }
        }

        final transient ImmutableList<Entry<K, V>> entries;
        private final transient Comparator<? super K> comparator;

        ImmutableSortedMap(
                ImmutableList<Entry<K, V>> entries, Comparator<? super K> comparator) {
            this.entries = entries;
            this.comparator = comparator;
        }

        @Override
        public int size() {
            return entries.size();
        }

        transient final Function<Entry<K, V>, K> keyFunction =
                new Function<Entry<K, V>, K>() {

                    @Override public K apply(Entry<K, V> entry) {
                        return entry.getKey();
                    }
                };


        @SuppressWarnings("unchecked")
        Comparator<Object> unsafeComparator() {
            return (Comparator<Object>) comparator;
        }

        @Override public V get(@Nullable Object key) {
            if (key == null) {
                return null;
            }
            int i;
            try {
                i = SortedLists.binarySearch(Lists.transform(entries, keyFunction), key,
                        unsafeComparator(), SortedLists.Relation.EQUAL, false);
            } catch (ClassCastException e) {
                return null;
            }
            return i >= 0 ? entries.get(i).getValue() : null;
        }

        @Override public boolean containsValue(@Nullable Object value) {
            if (value == null) {
                return false;
            }
            return Iterators.contains(valueIterator(), value);
        }

        @Override boolean isPartialView() {
            return entries.isPartialView();
        }

        private transient ImmutableSet<Entry<K, V>> entrySet;


        @Override public ImmutableSet<Entry<K, V>> entrySet() {
            ImmutableSet<Entry<K, V>> es = entrySet;
            return (es == null) ? (entrySet = createEntrySet()) : es;
        }

        private ImmutableSet<Entry<K, V>> createEntrySet() {
            return isEmpty() ? ImmutableSet.<Entry<K, V>>of()
                    : new EntrySet<K, V>(this);
        }

        @SuppressWarnings("serial") // uses writeReplace(), not default serialization
        private static class EntrySet<K, V> extends ImmutableSet<Entry<K, V>> {
            final transient ImmutableSortedMap<K, V> map;

            EntrySet(ImmutableSortedMap<K, V> map) {
                this.map = map;
            }

            @Override boolean isPartialView() {
                return map.isPartialView();
            }

            @Override
            public int size() {
                return map.size();
            }

            @Override public UnmodifiableIterator<Entry<K, V>> iterator() {
                return map.entries.iterator();
            }

            @Override public boolean contains(Object target) {
                if (target instanceof Entry) {
                    Entry<?, ?> entry = (Entry<?, ?>) target;
                    V mappedValue = map.get(entry.getKey());
                    return mappedValue != null && mappedValue.equals(entry.getValue());
                }
                return false;
            }

            @Override Object writeReplace() {
                return new EntrySetSerializedForm<K, V>(map);
            }
        }

        private static class EntrySetSerializedForm<K, V> implements Serializable {
            final ImmutableSortedMap<K, V> map;
            EntrySetSerializedForm(ImmutableSortedMap<K, V> map) {
                this.map = map;
            }
            Object readResolve() {
                return map.entrySet();
            }
            private static final long serialVersionUID = 0;
        }

        private transient ImmutableSortedSet<K> keySet;

        /**
         * Returns an immutable sorted set of the keys in this map.
         */
        @Override public ImmutableSortedSet<K> keySet() {
            ImmutableSortedSet<K> ks = keySet;
            return (ks == null) ? (keySet = createKeySet()) : ks;
        }

        @SuppressWarnings("serial") // does not use default serialization
        private ImmutableSortedSet<K> createKeySet() {
            if (isEmpty()) {
                return ImmutableSortedSet.emptySet(comparator);
            }

            return new RegularImmutableSortedSet<K>(
                    new TransformedImmutableList<Entry<K, V>, K>(entries) {

                        @Override K transform(Entry<K, V> entry) {
                            return entry.getKey();
                        }
                    }, comparator);
        }

        private transient ImmutableCollection<V> values;


        @Override public ImmutableCollection<V> values() {
            ImmutableCollection<V> v = values;
            return (v == null) ? (values = new Values<V>(this)) : v;
        }

        UnmodifiableIterator<V> valueIterator(){
            final UnmodifiableIterator<Entry<K, V>> entryIterator = entries.iterator();
            return new UnmodifiableIterator<V>() {

                @Override public boolean hasNext() {
                    return entryIterator.hasNext();
                }

                @Override public V next() {
                    return entryIterator.next().getValue();
                }
            };
        }

        @SuppressWarnings("serial") // uses writeReplace(), not default serialization
        private static class Values<V> extends ImmutableCollection<V> {
            private final ImmutableSortedMap<?, V> map;

            Values(ImmutableSortedMap<?, V> map) {
                this.map = map;
            }

            @Override
            public int size() {
                return map.size();
            }

            @Override public UnmodifiableIterator<V> iterator() {
                return map.valueIterator();
            }

            @Override public boolean contains(Object target) {
                return map.containsValue(target);
            }

            @Override boolean isPartialView() {
                return true;
            }

            @Override Object writeReplace() {
                return new ValuesSerializedForm<V>(map);
            }
        }

        private static class ValuesSerializedForm<V> implements Serializable {
            final ImmutableSortedMap<?, V> map;
            ValuesSerializedForm(ImmutableSortedMap<?, V> map) {
                this.map = map;
            }
            Object readResolve() {
                return map.values();
            }
            private static final long serialVersionUID = 0;
        }


        @Override
        public Comparator<? super K> comparator() {
            return comparator;
        }

        @Override
        public K firstKey() {
            if (isEmpty()) {
                throw new NoSuchElementException();
            }
            return entries.get(0).getKey();
        }

        @Override
        public K lastKey() {
            if (isEmpty()) {
                throw new NoSuchElementException();
            }
            return entries.get(size() - 1).getKey();
        }


        @Override
        public ImmutableSortedMap<K, V> headMap(K toKey) {
            int newToIndex = findSubmapIndex(checkNotNull(toKey));
            return createSubmap(0, newToIndex);
        }


        @Override
        public ImmutableSortedMap<K, V> subMap(K fromKey, K toKey) {
            checkNotNull(fromKey);
            checkNotNull(toKey);
            checkArgument(comparator.compare(fromKey, toKey) <= 0);
            int newFromIndex = findSubmapIndex(fromKey);
            int newToIndex = findSubmapIndex(toKey);
            return createSubmap(newFromIndex, newToIndex);
        }


        @Override
        public ImmutableSortedMap<K, V> tailMap(K fromKey) {
            int newFromIndex = findSubmapIndex(checkNotNull(fromKey));
            return createSubmap(newFromIndex, size());
        }

        private int findSubmapIndex(K key) {
            return SortedLists.binarySearch(
                    Lists.transform(entries, keyFunction), key, comparator, SortedLists.Relation.CEILING, false);
        }

        private ImmutableSortedMap<K, V> createSubmap(
                int newFromIndex, int newToIndex) {
            if (newFromIndex < newToIndex) {
                return new ImmutableSortedMap<K, V>(
                        entries.subList(newFromIndex, newToIndex), comparator);
            } else {
                return emptyMap(comparator);
            }
        }


        private static class SerializedForm extends ImmutableMap.SerializedForm {
            private final Comparator<Object> comparator;
            @SuppressWarnings("unchecked")
            SerializedForm(ImmutableSortedMap<?, ?> sortedMap) {
                super(sortedMap);
                comparator = (Comparator<Object>) sortedMap.comparator();
            }
            @Override Object readResolve() {
                Builder<Object, Object> builder = new Builder<Object, Object>(comparator);
                return createMap(builder);
            }
            private static final long serialVersionUID = 0;
        }

        @Override Object writeReplace() {
            return new SerializedForm(this);
        }

        // This class is never actually serialized directly, but we have to make the
        // warning go away (and suppressing would suppress for all nested classes too)
        private static final long serialVersionUID = 0;
    }
    abstract static class ImmutableSortedMapFauxverideShim<K, V>
            extends ImmutableMap<K, V> {
         public static <K, V> MahoutRecommender.ImmutableSortedMap.Builder<K, V> builder() {
            throw new UnsupportedOperationException();
        }

         public static <K, V> ImmutableSortedMap<K, V> of(K k1, V v1) {
            throw new UnsupportedOperationException();
        }

         public static <K, V> ImmutableSortedMap<K, V> of(
                K k1, V v1, K k2, V v2) {
            throw new UnsupportedOperationException();
        }

         public static <K, V> ImmutableSortedMap<K, V> of(
                K k1, V v1, K k2, V v2, K k3, V v3) {
            throw new UnsupportedOperationException();
        }

        public static <K, V> ImmutableSortedMap<K, V> of(
                K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {
            throw new UnsupportedOperationException();
        }

         public static <K, V> ImmutableSortedMap<K, V> of(
                K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {
            throw new UnsupportedOperationException();
        }

        // No copyOf() fauxveride; see ImmutableSortedSetFauxverideShim.
    }
    static class RegularImmutableList<E> extends ImmutableList<E> {
        private final transient int offset;
        private final transient int size;
        private final transient Object[] array;

        RegularImmutableList(Object[] array, int offset, int size) {
            this.offset = offset;
            this.size = size;
            this.array = array;
        }

        RegularImmutableList(Object[] array) {
            this(array, 0, array.length);
        }

        public int size() {
            return size;
        }

        @Override public boolean isEmpty() {
            return false;
        }

        @Override boolean isPartialView() {
            return offset != 0 || size != array.length;
        }

        @Override public boolean contains(Object target) {
            return indexOf(target) != -1;
        }

        // The fake cast to E is safe because the creation methods only allow E's
        @SuppressWarnings("unchecked")
        @Override public UnmodifiableIterator<E> iterator() {
            return (UnmodifiableIterator<E>) Iterators.forArray(array, offset, size);
        }

        @Override public Object[] toArray() {
            Object[] newArray = new Object[size()];
            System.arraycopy(array, offset, newArray, 0, size);
            return newArray;
        }

        @Override public <T> T[] toArray(T[] other) {
            if (other.length < size) {
                other = ObjectArrays.newArray(other, size);
            } else if (other.length > size) {
                other[size] = null;
            }
            System.arraycopy(array, offset, other, 0, size);
            return other;
        }

        // The fake cast to E is safe because the creation methods only allow E's
        @SuppressWarnings("unchecked")
        public E get(int index) {
            Preconditions.checkElementIndex(index, size);
            return (E) array[index + offset];
        }

        @Override public int indexOf(Object target) {
            if (target != null) {
                for (int i = offset; i < offset + size; i++) {
                    if (array[i].equals(target)) {
                        return i - offset;
                    }
                }
            }
            return -1;
        }

        @Override public int lastIndexOf(Object target) {
            if (target != null) {
                for (int i = offset + size - 1; i >= offset; i--) {
                    if (array[i].equals(target)) {
                        return i - offset;
                    }
                }
            }
            return -1;
        }

        @Override public ImmutableList<E> subList(int fromIndex, int toIndex) {
            Preconditions.checkPositionIndexes(fromIndex, toIndex, size);
            return (fromIndex == toIndex)
                    ? ImmutableList.<E>of()
                    : new RegularImmutableList<E>(
                    array, offset + fromIndex, toIndex - fromIndex);
        }

        @Override public UnmodifiableListIterator<E> listIterator(final int start) {
            return new AbstractIndexedListIterator<E>(size, start) {
                // The fake cast to E is safe because the creation methods only allow E's
                @SuppressWarnings("unchecked")
                @Override protected E get(int index) {
                    return (E) array[index + offset];
                }

            };
        }

        @Override public boolean equals(@Nullable Object object) {
            if (object == this) {
                return true;
            }
            if (!(object instanceof List)) {
                return false;
            }

            List<?> that = (List<?>) object;
            if (this.size() != that.size()) {
                return false;
            }

            int index = offset;
            if (object instanceof RegularImmutableList) {
                RegularImmutableList<?> other = (RegularImmutableList<?>) object;
                for (int i = other.offset; i < other.offset + other.size; i++) {
                    if (!array[index++].equals(other.array[i])) {
                        return false;
                    }
                }
            } else {
                for (Object element : that) {
                    if (!array[index++].equals(element)) {
                        return false;
                    }
                }
            }
            return true;
        }

        @Override public int hashCode() {
            // not caching hash code since it could change if the elements are mutable
            // in a way that modifies their hash codes
            int hashCode = 1;
            for (int i = offset; i < offset + size; i++) {
                hashCode = 31 * hashCode + array[i].hashCode();
            }
            return hashCode;
        }

        @Override public String toString() {
            StringBuilder sb = Collections2.newStringBuilderForCollection(size())
                    .append('[').append(array[offset]);
            for (int i = offset + 1; i < offset + size; i++) {
                sb.append(", ").append(array[i]);
            }
            return sb.append(']').toString();
        }

        int offset() {
            return offset;
        }

        Object[] array() {
            return array;
        }
    }
    static final class ExplicitOrdering<T> extends Ordering<T> implements Serializable {
        final ImmutableMap<T, Integer> rankMap;

        ExplicitOrdering(List<T> valuesInOrder) {
            this(buildRankMap(valuesInOrder));
        }

        ExplicitOrdering(ImmutableMap<T, Integer> rankMap) {
            this.rankMap = rankMap;
        }

        @Override public int compare(T left, T right) {
            return rank(left) - rank(right); // safe because both are nonnegative
        }

        private int rank(T value) {
            Integer rank = rankMap.get(value);
            if (rank == null) {
                throw new IncomparableValueException(value);
            }
            return rank;
        }

        private static <T> ImmutableMap<T, Integer> buildRankMap(
                List<T> valuesInOrder) {
            ImmutableMap.Builder<T, Integer> builder = ImmutableMap.builder();
            int rank = 0;
            for (T value : valuesInOrder) {
                builder.put(value, rank++);
            }
            return builder.build();
        }

        @Override public boolean equals(@Nullable Object object) {
            if (object instanceof ExplicitOrdering) {
                ExplicitOrdering<?> that = (ExplicitOrdering<?>) object;
                return this.rankMap.equals(that.rankMap);
            }
            return false;
        }

        @Override public int hashCode() {
            return rankMap.hashCode();
        }

        @Override public String toString() {
            return "Ordering.explicit(" + rankMap.keySet() + ")";
        }

        private static final long serialVersionUID = 0;
    }
    static final class LexicographicalOrdering<T>
            extends Ordering<Iterable<T>> implements Serializable {
        final Ordering<? super T> elementOrder;

        LexicographicalOrdering(Ordering<? super T> elementOrder) {
            this.elementOrder = elementOrder;
        }

        @Override public int compare(
                Iterable<T> leftIterable, Iterable<T> rightIterable) {
            Iterator<T> left = leftIterable.iterator();
            Iterator<T> right = rightIterable.iterator();
            while (left.hasNext()) {
                if (!right.hasNext()) {
                    return LEFT_IS_GREATER; // because it's longer
                }
                int result = elementOrder.compare(left.next(), right.next());
                if (result != 0) {
                    return result;
                }
            }
            if (right.hasNext()) {
                return RIGHT_IS_GREATER; // because it's longer
            }
            return 0;
        }

        @Override public boolean equals(@Nullable Object object) {
            if (object == this) {
                return true;
            }
            if (object instanceof LexicographicalOrdering) {
                LexicographicalOrdering<?> that = (LexicographicalOrdering<?>) object;
                return this.elementOrder.equals(that.elementOrder);
            }
            return false;
        }

        @Override public int hashCode() {
            return elementOrder.hashCode() ^ 2075626741; // meaningless
        }

        @Override public String toString() {
            return elementOrder + ".lexicographical()";
        }

        private static final long serialVersionUID = 0;
    }
    static final class NaturalOrdering
            extends Ordering<Comparable> implements Serializable {
        static final NaturalOrdering INSTANCE = new NaturalOrdering();

        @Override public int compare(Comparable left, Comparable right) {
            checkNotNull(right); // left null is caught later
            if (left == right) {
                return 0;
            }

            @SuppressWarnings("unchecked") // we're permitted to throw CCE
                    int result = left.compareTo(right);
            return result;
        }

        @SuppressWarnings("unchecked") // TODO(kevinb): the right way to explain this??
        @Override public <S extends Comparable> Ordering<S> reverse() {
            return (Ordering<S>) ReverseNaturalOrdering.INSTANCE;
        }

        // Override to remove a level of indirection from inner loop
        @SuppressWarnings("unchecked") // TODO(kevinb): the right way to explain this??
        @Override public int binarySearch(
                List<? extends Comparable> sortedList, Comparable key) {
            return Collections.binarySearch((List) sortedList, key);
        }

        // Override to remove a level of indirection from inner loop
        @Override public <E extends Comparable> List<E> sortedCopy(
                Iterable<E> iterable) {
            List<E> list = Lists.newArrayList(iterable);
            Collections.sort(list);
            return list;
        }

        // preserving singleton-ness gives equals()/hashCode() for free
        private Object readResolve() {
            return INSTANCE;
        }

        @Override public String toString() {
            return "Ordering.natural()";
        }

        private NaturalOrdering() {}

        private static final long serialVersionUID = 0;
    }
    static final class NullsFirstOrdering<T> extends Ordering<T> implements Serializable {
        final Ordering<? super T> ordering;

        NullsFirstOrdering(Ordering<? super T> ordering) {
            this.ordering = ordering;
        }

        @Override public int compare(@Nullable T left, @Nullable T right) {
            if (left == right) {
                return 0;
            }
            if (left == null) {
                return RIGHT_IS_GREATER;
            }
            if (right == null) {
                return LEFT_IS_GREATER;
            }
            return ordering.compare(left, right);
        }

        @Override public <S extends T> Ordering<S> reverse() {
            // ordering.reverse() might be optimized, so let it do its thing
            return ordering.reverse().nullsLast();
        }

        @SuppressWarnings("unchecked") // still need the right way to explain this
        @Override public <S extends T> Ordering<S> nullsFirst() {
            return (Ordering<S>) this;
        }

        @Override public <S extends T> Ordering<S> nullsLast() {
            return ordering.nullsLast();
        }

        @Override public boolean equals(@Nullable Object object) {
            if (object == this) {
                return true;
            }
            if (object instanceof NullsFirstOrdering) {
                NullsFirstOrdering<?> that = (NullsFirstOrdering<?>) object;
                return this.ordering.equals(that.ordering);
            }
            return false;
        }

        @Override public int hashCode() {
            return ordering.hashCode() ^ 957692532; // meaningless
        }

        @Override public String toString() {
            return ordering + ".nullsFirst()";
        }

        private static final long serialVersionUID = 0;
    }
    static final class NullsLastOrdering<T> extends Ordering<T> implements Serializable {
        final Ordering<? super T> ordering;

        NullsLastOrdering(Ordering<? super T> ordering) {
            this.ordering = ordering;
        }

        @Override public int compare(@Nullable T left, @Nullable T right) {
            if (left == right) {
                return 0;
            }
            if (left == null) {
                return LEFT_IS_GREATER;
            }
            if (right == null) {
                return RIGHT_IS_GREATER;
            }
            return ordering.compare(left, right);
        }

        @Override public <S extends T> Ordering<S> reverse() {
            // ordering.reverse() might be optimized, so let it do its thing
            return ordering.reverse().nullsFirst();
        }

        @Override public <S extends T> Ordering<S> nullsFirst() {
            return ordering.nullsFirst();
        }

        @SuppressWarnings("unchecked") // still need the right way to explain this
        @Override public <S extends T> Ordering<S> nullsLast() {
            return (Ordering<S>) this;
        }

        @Override public boolean equals(@Nullable Object object) {
            if (object == this) {
                return true;
            }
            if (object instanceof NullsLastOrdering) {
                NullsLastOrdering<?> that = (NullsLastOrdering<?>) object;
                return this.ordering.equals(that.ordering);
            }
            return false;
        }

        @Override public int hashCode() {
            return ordering.hashCode() ^ -921210296; // meaningless
        }

        @Override public String toString() {
            return ordering + ".nullsLast()";
        }

        private static final long serialVersionUID = 0;
    }
    static final class ReverseNaturalOrdering
            extends Ordering<Comparable> implements Serializable {
        static final ReverseNaturalOrdering INSTANCE = new ReverseNaturalOrdering();

        @Override public int compare(Comparable left, Comparable right) {
            checkNotNull(left); // right null is caught later
            if (left == right) {
                return 0;
            }

            @SuppressWarnings("unchecked") // we're permitted to throw CCE
                    int result = right.compareTo(left);
            return result;
        }

        @Override public <S extends Comparable> Ordering<S> reverse() {
            return Ordering.natural();
        }

        // Override the six min/max methods to "hoist" delegation outside loops

        @Override public <E extends Comparable> E min(E a, E b) {
            return NaturalOrdering.INSTANCE.max(a, b);
        }

        @Override public <E extends Comparable> E min(E a, E b, E c, E... rest) {
            return NaturalOrdering.INSTANCE.max(a, b, c, rest);
        }

        @Override public <E extends Comparable> E min(Iterable<E> iterable) {
            return NaturalOrdering.INSTANCE.max(iterable);
        }

        @Override public <E extends Comparable> E max(E a, E b) {
            return NaturalOrdering.INSTANCE.min(a, b);
        }

        @Override public <E extends Comparable> E max(E a, E b, E c, E... rest) {
            return NaturalOrdering.INSTANCE.min(a, b, c, rest);
        }

        @Override public <E extends Comparable> E max(Iterable<E> iterable) {
            return NaturalOrdering.INSTANCE.min(iterable);
        }

        // preserving singleton-ness gives equals()/hashCode() for free
        private Object readResolve() {
            return INSTANCE;
        }

        @Override public String toString() {
            return "Ordering.natural().reverse()";
        }

        private ReverseNaturalOrdering() {}

        private static final long serialVersionUID = 0;
    }
    static final class ReverseOrdering<T> extends Ordering<T> implements Serializable {
        final Ordering<? super T> forwardOrder;

        ReverseOrdering(Ordering<? super T> forwardOrder) {
            this.forwardOrder = checkNotNull(forwardOrder);
        }

        @Override public int compare(T a, T b) {
            return forwardOrder.compare(b, a);
        }

        @SuppressWarnings("unchecked") // how to explain?
        @Override public <S extends T> Ordering<S> reverse() {
            return (Ordering<S>) forwardOrder;
        }

        // Override the six min/max methods to "hoist" delegation outside loops

        @Override public <E extends T> E min(E a, E b) {
            return forwardOrder.max(a, b);
        }

        @Override public <E extends T> E min(E a, E b, E c, E... rest) {
            return forwardOrder.max(a, b, c, rest);
        }

        @Override public <E extends T> E min(Iterable<E> iterable) {
            return forwardOrder.max(iterable);
        }

        @Override public <E extends T> E max(E a, E b) {
            return forwardOrder.min(a, b);
        }

        @Override public <E extends T> E max(E a, E b, E c, E... rest) {
            return forwardOrder.min(a, b, c, rest);
        }

        @Override public <E extends T> E max(Iterable<E> iterable) {
            return forwardOrder.min(iterable);
        }

        @Override public int hashCode() {
            return -forwardOrder.hashCode();
        }

        @Override public boolean equals(@Nullable Object object) {
            if (object == this) {
                return true;
            }
            if (object instanceof ReverseOrdering) {
                ReverseOrdering<?> that = (ReverseOrdering<?>) object;
                return this.forwardOrder.equals(that.forwardOrder);
            }
            return false;
        }

        @Override public String toString() {
            return forwardOrder + ".reverse()";
        }

        private static final long serialVersionUID = 0;
    }
    static final class UsingToStringOrdering
            extends Ordering<Object> implements Serializable {
        static final UsingToStringOrdering INSTANCE = new UsingToStringOrdering();

        @Override public int compare(Object left, Object right) {
            return left.toString().compareTo(right.toString());
        }

        // preserve singleton-ness, so equals() and hashCode() work correctly
        private Object readResolve() {
            return INSTANCE;
        }

        @Override public String toString() {
            return "Ordering.usingToString()";
        }

        private UsingToStringOrdering() {}

        private static final long serialVersionUID = 0;
    }
    static public abstract class Ordering<T> implements Comparator<T> {
        // Static factories


        @GwtCompatible(serializable = true)
        @SuppressWarnings("unchecked") // TODO(kevinb): the right way to explain this??
        public static <C extends Comparable> Ordering<C> natural() {
            return (Ordering<C>) NaturalOrdering.INSTANCE;
        }


        @GwtCompatible(serializable = true)
        public static <T> Ordering<T> from(Comparator<T> comparator) {
            return (comparator instanceof Ordering)
                    ? (Ordering<T>) comparator
                    : new ComparatorOrdering<T>(comparator);
        }


        @GwtCompatible(serializable = true)
        @Deprecated public static <T> Ordering<T> from(Ordering<T> ordering) {
            return checkNotNull(ordering);
        }


        @GwtCompatible(serializable = true)
        public static <T> Ordering<T> explicit(List<T> valuesInOrder) {
            return new ExplicitOrdering<T>(valuesInOrder);
        }


        @GwtCompatible(serializable = true)
        public static <T> Ordering<T> explicit(
                T leastValue, T... remainingValuesInOrder) {
            return explicit(Lists.asList(leastValue, remainingValuesInOrder));
        }


        // TODO(kevinb): make this public, document it right
        @VisibleForTesting
        static class IncomparableValueException extends ClassCastException {
            final Object value;

            IncomparableValueException(Object value) {
                super("Cannot compare value: " + value);
                this.value = value;
            }

            private static final long serialVersionUID = 0;
        }


        public static Ordering<Object> arbitrary() {
            return ArbitraryOrderingHolder.ARBITRARY_ORDERING;
        }

        private static class ArbitraryOrderingHolder {
            static final Ordering<Object> ARBITRARY_ORDERING = new ArbitraryOrdering();
        }

        static class ArbitraryOrdering extends Ordering<Object> {
            private Map<Object, Integer> uids =
                    Platform.tryWeakKeys(new MapMaker()).makeComputingMap(
                            new Function<Object, Integer>() {
                                final AtomicInteger counter = new AtomicInteger(0);
                                @Override
                                public Integer apply(Object from) {
                                    return counter.getAndIncrement();
                                }
                            });

            @Override public int compare(Object left, Object right) {
                if (left == right) {
                    return 0;
                }
                int leftCode = identityHashCode(left);
                int rightCode = identityHashCode(right);
                if (leftCode != rightCode) {
                    return leftCode < rightCode ? -1 : 1;
                }

                // identityHashCode collision (rare, but not as rare as you'd think)
                int result = uids.get(left).compareTo(uids.get(right));
                if (result == 0) {
                    throw new AssertionError(); // extremely, extremely unlikely.
                }
                return result;
            }

            @Override public String toString() {
                return "Ordering.arbitrary()";
            }


            int identityHashCode(Object object) {
                return System.identityHashCode(object);
            }
        }


        @GwtCompatible(serializable = true)
        public static Ordering<Object> usingToString() {
            return UsingToStringOrdering.INSTANCE;
        }


        @GwtCompatible(serializable = true)
        public static <T> Ordering<T> compound(
                Iterable<? extends Comparator<? super T>> comparators) {
            return new CompoundOrdering<T>(comparators);
        }


        protected Ordering() {}

        // Non-static factories


        @GwtCompatible(serializable = true)
        public <U extends T> Ordering<U> compound(
                Comparator<? super U> secondaryComparator) {
            return new CompoundOrdering<U>(this, checkNotNull(secondaryComparator));
        }


        // type parameter <S> lets us avoid the extra <String> in statements like:
        // Ordering<String> o = Ordering.<String>natural().reverse();
        @GwtCompatible(serializable = true)
        public <S extends T> Ordering<S> reverse() {
            return new ReverseOrdering<S>(this);
        }


        @GwtCompatible(serializable = true)
        public <F> Ordering<F> onResultOf(Function<F, ? extends T> function) {
            return new ByFunctionOrdering<F, T>(function, this);
        }


        @GwtCompatible(serializable = true)
        // type parameter <S> lets us avoid the extra <String> in statements like:
        // Ordering<Iterable<String>> o =
        //     Ordering.<String>natural().lexicographical();
        public <S extends T> Ordering<Iterable<S>> lexicographical() {

            return new LexicographicalOrdering<S>(this);
        }


        // type parameter <S> lets us avoid the extra <String> in statements like:
        // Ordering<String> o = Ordering.<String>natural().nullsFirst();
        @GwtCompatible(serializable = true)
        public <S extends T> Ordering<S> nullsFirst() {
            return new NullsFirstOrdering<S>(this);
        }


        // type parameter <S> lets us avoid the extra <String> in statements like:
        // Ordering<String> o = Ordering.<String>natural().nullsLast();
        @GwtCompatible(serializable = true)
        public <S extends T> Ordering<S> nullsLast() {
            return new NullsLastOrdering<S>(this);
        }

        // Regular instance methods

        // Override to add @Nullable
        @Override public abstract int compare(@Nullable T left, @Nullable T right);


        public <E extends T> List<E> leastOf(Iterable<E> iterable, int k) {
            checkArgument(k >= 0, "%d is negative", k);

            // values is not an E[], but we use it as such for readability. Hack.
            @SuppressWarnings("unchecked")
            E[] values = (E[]) Iterables.toArray(iterable);

            // TODO(nshupe): also sort whole list if k is *near* values.length?
            // TODO(kevinb): benchmark this impl against hand-coded heap
            E[] resultArray;
            if (values.length <= k) {
                Arrays.sort(values, this);
                resultArray = values;
            } else {
                quicksortLeastK(values, 0, values.length - 1, k);

                // this is not an E[], but we use it as such for readability. Hack.
                @SuppressWarnings("unchecked")
                E[] tmp = (E[]) new Object[k];
                resultArray = tmp;
                System.arraycopy(values, 0, resultArray, 0, k);
            }

            return Collections.unmodifiableList(Arrays.asList(resultArray));
        }


        public <E extends T> List<E> greatestOf(Iterable<E> iterable, int k) {
            // TODO(kevinb): see if delegation is hurting performance noticeably
            // TODO(kevinb): if we change this implementation, add full unit tests.
            return reverse().leastOf(iterable, k);
        }

        private <E extends T> void quicksortLeastK(
                E[] values, int left, int right, int k) {
            if (right > left) {
                int pivotIndex = (left + right) >>> 1; // left + ((right - left) / 2)
                int pivotNewIndex = partition(values, left, right, pivotIndex);
                quicksortLeastK(values, left, pivotNewIndex - 1, k);
                if (pivotNewIndex < k) {
                    quicksortLeastK(values, pivotNewIndex + 1, right, k);
                }
            }
        }

        private <E extends T> int partition(
                E[] values, int left, int right, int pivotIndex) {
            E pivotValue = values[pivotIndex];

            values[pivotIndex] = values[right];
            values[right] = pivotValue;

            int storeIndex = left;
            for (int i = left; i < right; i++) {
                if (compare(values[i], pivotValue) < 0) {
                    ObjectArrays.swap(values, storeIndex, i);
                    storeIndex++;
                }
            }
            ObjectArrays.swap(values, right, storeIndex);
            return storeIndex;
        }


        public int binarySearch(List<? extends T> sortedList, @Nullable T key) {
            return Collections.binarySearch(sortedList, key, this);
        }


        public <E extends T> List<E> sortedCopy(Iterable<E> iterable) {
            List<E> list = Lists.newArrayList(iterable);
            Collections.sort(list, this);
            return list;
        }


        public <E extends T> ImmutableList<E> immutableSortedCopy(
                Iterable<E> iterable) {
            return ImmutableList.copyOf(sortedCopy(iterable));
        }


        public boolean isOrdered(Iterable<? extends T> iterable) {
            Iterator<? extends T> it = iterable.iterator();
            if (it.hasNext()) {
                T prev = it.next();
                while (it.hasNext()) {
                    T next = it.next();
                    if (compare(prev, next) > 0) {
                        return false;
                    }
                    prev = next;
                }
            }
            return true;
        }

        public boolean isStrictlyOrdered(Iterable<? extends T> iterable) {
            Iterator<? extends T> it = iterable.iterator();
            if (it.hasNext()) {
                T prev = it.next();
                while (it.hasNext()) {
                    T next = it.next();
                    if (compare(prev, next) >= 0) {
                        return false;
                    }
                    prev = next;
                }
            }
            return true;
        }

        public <E extends T> E max(Iterable<E> iterable) {
            Iterator<E> iterator = iterable.iterator();

            // let this throw NoSuchElementException as necessary
            E maxSoFar = iterator.next();

            while (iterator.hasNext()) {
                maxSoFar = max(maxSoFar, iterator.next());
            }

            return maxSoFar;
        }


        public <E extends T> E max(
                @Nullable E a, @Nullable E b, @Nullable E c, E... rest) {
            E maxSoFar = max(max(a, b), c);

            for (E r : rest) {
                maxSoFar = max(maxSoFar, r);
            }

            return maxSoFar;
        }


        public <E extends T> E max(@Nullable E a, @Nullable E b) {
            return compare(a, b) >= 0 ? a : b;
        }


        public <E extends T> E min(Iterable<E> iterable) {
            Iterator<E> iterator = iterable.iterator();

            // let this throw NoSuchElementException as necessary
            E minSoFar = iterator.next();

            while (iterator.hasNext()) {
                minSoFar = min(minSoFar, iterator.next());
            }

            return minSoFar;
        }

        public <E extends T> E min(
                @Nullable E a, @Nullable E b, @Nullable E c, E... rest) {
            E minSoFar = min(min(a, b), c);

            for (E r : rest) {
                minSoFar = min(minSoFar, r);
            }

            return minSoFar;
        }


        public <E extends T> E min(@Nullable E a, @Nullable E b) {
            return compare(a, b) <= 0 ? a : b;
        }

        // Never make these public
        static final int LEFT_IS_GREATER = 1;
        static final int RIGHT_IS_GREATER = -1;
    }
    public @interface VisibleForTesting {
    }
    public static abstract class ImmutableSortedSet<E>
            extends ImmutableSortedSetFauxverideShim<E> implements SortedSet<E> {

        /*
         * TODO(cpovirk): find a way to remove this @SuppressWarnings even for
         * eclipse?
         */
        @SuppressWarnings("unchecked")
        private static final Comparator<Comparable> NATURAL_ORDER =
                Ordering.natural();

        @SuppressWarnings("unchecked")
        private static final ImmutableSortedSet<Comparable> NATURAL_EMPTY_SET =
                new EmptyImmutableSortedSet<Comparable>(NATURAL_ORDER);

        @SuppressWarnings("unchecked")
        private static <E> ImmutableSortedSet<E> emptySet() {
            return (ImmutableSortedSet<E>) NATURAL_EMPTY_SET;
        }

        static <E> ImmutableSortedSet<E> emptySet(
                Comparator<? super E> comparator) {
            if (NATURAL_ORDER.equals(comparator)) {
                return emptySet();
            } else {
                return new EmptyImmutableSortedSet<E>(comparator);
            }
        }


        public static <E> ImmutableSortedSet<E> of() {
            return emptySet();
        }

        public static <E extends Comparable<? super E>> ImmutableSortedSet<E> of(
                E element) {
            return new RegularImmutableSortedSet<E>(
                    ImmutableList.of(element), Ordering.natural());
        }


        @SuppressWarnings("unchecked")
        public static <E extends Comparable<? super E>> ImmutableSortedSet<E> of(
                E e1, E e2) {
            return copyOf(Ordering.natural(), Arrays.asList(e1, e2));
        }


        @SuppressWarnings("unchecked")
        public static <E extends Comparable<? super E>> ImmutableSortedSet<E> of(
                E e1, E e2, E e3) {
            return copyOf(Ordering.natural(), Arrays.asList(e1, e2, e3));
        }


        @SuppressWarnings("unchecked")
        public static <E extends Comparable<? super E>> ImmutableSortedSet<E> of(
                E e1, E e2, E e3, E e4) {
            return copyOf(Ordering.natural(), Arrays.asList(e1, e2, e3, e4));
        }

        @SuppressWarnings("unchecked")
        public static <E extends Comparable<? super E>> ImmutableSortedSet<E> of(
                E e1, E e2, E e3, E e4, E e5) {
            return copyOf(Ordering.natural(), Arrays.asList(e1, e2, e3, e4, e5));
        }


        @SuppressWarnings("unchecked")
        public static <E extends Comparable<? super E>> ImmutableSortedSet<E> of(
                E e1, E e2, E e3, E e4, E e5, E e6, E... remaining) {
            int size = remaining.length + 6;
            List<E> all = new ArrayList<E>(size);
            Collections.addAll(all, e1, e2, e3, e4, e5, e6);
            Collections.addAll(all, remaining);
            return copyOf(Ordering.natural(), all);
        }

        // TODO(kevinb): Consider factory methods that reject duplicates


        @Deprecated
        public
        static <E extends Comparable<? super E>> ImmutableSortedSet<E> of(
                E[] elements) {
            return copyOf(elements);
        }

        public static <E extends Comparable<? super E>> ImmutableSortedSet<E> copyOf(
                E[] elements) {
            return copyOf(Ordering.natural(), Arrays.asList(elements));
        }

        public static <E> ImmutableSortedSet<E> copyOf(
                Iterable<? extends E> elements) {
            // Hack around K not being a subtype of Comparable.
            // Unsafe, see ImmutableSortedSetFauxverideShim.
            @SuppressWarnings("unchecked")
            Ordering<E> naturalOrder = (Ordering<E>) Ordering.<Comparable>natural();
            return copyOf(naturalOrder, elements);
        }


        public static <E> ImmutableSortedSet<E> copyOf(
                Collection<? extends E> elements) {
            // Hack around K not being a subtype of Comparable.
            // Unsafe, see ImmutableSortedSetFauxverideShim.
            @SuppressWarnings("unchecked")
            Ordering<E> naturalOrder = (Ordering<E>) Ordering.<Comparable>natural();
            return copyOf(naturalOrder, elements);
        }

        public static <E> ImmutableSortedSet<E> copyOf(
                Iterator<? extends E> elements) {
            // Hack around K not being a subtype of Comparable.
            // Unsafe, see ImmutableSortedSetFauxverideShim.
            @SuppressWarnings("unchecked")
            Ordering<E> naturalOrder = (Ordering<E>) Ordering.<Comparable>natural();
            return copyOfInternal(naturalOrder, elements);
        }

        public static <E> ImmutableSortedSet<E> copyOf(
                Comparator<? super E> comparator, Iterator<? extends E> elements) {
            checkNotNull(comparator);
            return copyOfInternal(comparator, elements);
        }


        public static <E> ImmutableSortedSet<E> copyOf(
                Comparator<? super E> comparator, Iterable<? extends E> elements) {
            checkNotNull(comparator);
            return copyOfInternal(comparator, elements, false);
        }


        public static <E> ImmutableSortedSet<E> copyOf(
                Comparator<? super E> comparator, Collection<? extends E> elements) {
            checkNotNull(comparator);
            return copyOfInternal(comparator, elements, false);
        }


        @SuppressWarnings("unchecked")
        public static <E> ImmutableSortedSet<E> copyOfSorted(SortedSet<E> sortedSet) {
            Comparator<? super E> comparator = sortedSet.comparator();
            if (comparator == null) {
                comparator = (Comparator<? super E>) NATURAL_ORDER;
            }
            return copyOfInternal(comparator, sortedSet, true);
        }

        private static <E> ImmutableSortedSet<E> copyOfInternal(
                Comparator<? super E> comparator, Iterable<? extends E> elements,
                boolean fromSortedSet) {
            boolean hasSameComparator
                    = fromSortedSet || hasSameComparator(elements, comparator);

            if (hasSameComparator && (elements instanceof ImmutableSortedSet)) {
                @SuppressWarnings("unchecked")
                ImmutableSortedSet<E> original = (ImmutableSortedSet<E>) elements;
                if (original.isEmpty()) {
                    return original;
                }
                ImmutableList<E> elementsList = original.asList();
                ImmutableList<E> copiedElementsList = ImmutableList.copyOf(elements);
                if (elementsList == copiedElementsList) {
                    return original;
                }
                return new RegularImmutableSortedSet<E>(copiedElementsList, comparator);
            }

            ImmutableList<E> list =
                    immutableSortedUniqueCopy(comparator, Lists.newArrayList(elements));
            if (list.isEmpty()) {
                return emptySet(comparator);
            }
            return new RegularImmutableSortedSet<E>(list, comparator);
        }

        private static <E> ImmutableSortedSet<E> copyOfInternal(
                Comparator<? super E> comparator, Iterator<? extends E> elements) {
            if (!elements.hasNext()) {
                return emptySet(comparator);
            }
            ImmutableList<E> list =
                    immutableSortedUniqueCopy(comparator, Lists.newArrayList(elements));
            return new RegularImmutableSortedSet<E>(list, comparator);
        }


        private static <E> ImmutableList<E> immutableSortedUniqueCopy(
                Comparator<? super E> comparator, List<E> list) {
            if (list.isEmpty()) {
                return ImmutableList.of();
            }
            Collections.sort(list, comparator);
            int size = 1;
            for (int i = 1; i < list.size(); i++) {
                E elem = list.get(i);
                if (comparator.compare(elem, list.get(size - 1)) != 0) {
                    list.set(size++, elem);
                }
            }
            return ImmutableList.copyOf(list.subList(0, size));
        }

        static boolean hasSameComparator(
                Iterable<?> elements, Comparator<?> comparator) {
            if (elements instanceof SortedSet) {
                SortedSet<?> sortedSet = (SortedSet<?>) elements;
                Comparator<?> comparator2 = sortedSet.comparator();
                return (comparator2 == null)
                        ? comparator == Ordering.natural()
                        : comparator.equals(comparator2);
            }
            return false;
        }

        @Deprecated
        public static <E> ImmutableSortedSet<E> withExplicitOrder(List<E> elements) {
            return ExplicitOrderedImmutableSortedSet.create(elements);
        }

        @Deprecated
        public static <E> ImmutableSortedSet<E> withExplicitOrder(
                E firstElement, E... remainingElementsInOrder) {
            return withExplicitOrder(
                    Lists.asList(firstElement, remainingElementsInOrder));
        }

        public static <E> Builder<E> orderedBy(Comparator<E> comparator) {
            return new Builder<E>(comparator);
        }


        public static <E extends Comparable<E>> Builder<E> reverseOrder() {
            return new Builder<E>(Ordering.natural().reverse());
        }


        public static <E extends Comparable<E>> Builder<E> naturalOrder() {
            return new Builder<E>(Ordering.natural());
        }

        public static final class Builder<E> extends ImmutableSet.Builder<E> {
            private final Comparator<? super E> comparator;

            public Builder(Comparator<? super E> comparator) {
                this.comparator = checkNotNull(comparator);
            }


            @Override public Builder<E> add(E element) {
                super.add(element);
                return this;
            }

            @Override public Builder<E> add(E... elements) {
                super.add(elements);
                return this;
            }


            @Override public Builder<E> addAll(Iterable<? extends E> elements) {
                super.addAll(elements);
                return this;
            }


            @Override public Builder<E> addAll(Iterator<? extends E> elements) {
                super.addAll(elements);
                return this;
            }


            @Override public ImmutableSortedSet<E> build() {
                return copyOfInternal(comparator, contents.iterator());
            }
        }

        int unsafeCompare(Object a, Object b) {
            return unsafeCompare(comparator, a, b);
        }

        static int unsafeCompare(
                Comparator<?> comparator, Object a, Object b) {
            // Pretend the comparator can compare anything. If it turns out it can't
            // compare a and b, we should get a CCE on the subsequent line. Only methods
            // that are spec'd to throw CCE should call this.
            @SuppressWarnings("unchecked")
            Comparator<Object> unsafeComparator = (Comparator<Object>) comparator;
            return unsafeComparator.compare(a, b);
        }

        final transient Comparator<? super E> comparator;

        ImmutableSortedSet(Comparator<? super E> comparator) {
            this.comparator = comparator;
        }


        @Override
        public Comparator<? super E> comparator() {
            return comparator;
        }


        @Override
        public ImmutableSortedSet<E> headSet(E toElement) {
            return headSetImpl(checkNotNull(toElement));
        }


        @Override
        public ImmutableSortedSet<E> subSet(E fromElement, E toElement) {
            checkNotNull(fromElement);
            checkNotNull(toElement);
            checkArgument(comparator.compare(fromElement, toElement) <= 0);
            return subSetImpl(fromElement, toElement);
        }


        @Override
        public ImmutableSortedSet<E> tailSet(E fromElement) {
            return tailSetImpl(checkNotNull(fromElement));
        }

        /*
         * These methods perform most headSet, subSet, and tailSet logic, besides
         * parameter validation.
         */
        abstract ImmutableSortedSet<E> headSetImpl(E toElement);
        abstract ImmutableSortedSet<E> subSetImpl(E fromElement, E toElement);
        abstract ImmutableSortedSet<E> tailSetImpl(E fromElement);


        abstract int indexOf(Object target);

        /*
         * This class is used to serialize all ImmutableSortedSet instances,
         * regardless of implementation type. It captures their "logical contents"
         * only. This is necessary to ensure that the existence of a particular
         * implementation type is an implementation detail.
         */
        private static class SerializedForm<E> implements Serializable {
            final Comparator<? super E> comparator;
            final Object[] elements;

            public SerializedForm(Comparator<? super E> comparator, Object[] elements) {
                this.comparator = comparator;
                this.elements = elements;
            }

            @SuppressWarnings("unchecked")
            Object readResolve() {
                return new Builder<E>(comparator).add((E[]) elements).build();
            }

            private static final long serialVersionUID = 0;
        }

        private void readObject(ObjectInputStream stream)
                throws InvalidObjectException {
            throw new InvalidObjectException("Use SerializedForm");
        }

        @Override Object writeReplace() {
            return new SerializedForm<E>(comparator, toArray());
        }
    }
    static abstract class ImmutableSortedSetFauxverideShim<E> extends ImmutableSet<E> {

        @Deprecated public static <E> ImmutableSortedSet.Builder<E> builder() {
            throw new UnsupportedOperationException();
        }


        @Deprecated public static <E> ImmutableSortedSet<E> of(E element) {
            throw new UnsupportedOperationException();
        }


        @Deprecated public static <E> ImmutableSortedSet<E> of(E e1, E e2) {
            throw new UnsupportedOperationException();
        }


        @Deprecated public static <E> ImmutableSortedSet<E> of(E e1, E e2, E e3) {
            throw new UnsupportedOperationException();
        }


        @Deprecated public static <E> ImmutableSortedSet<E> of(
                E e1, E e2, E e3, E e4) {
            throw new UnsupportedOperationException();
        }


        @Deprecated public static <E> ImmutableSortedSet<E> of(
                E e1, E e2, E e3, E e4, E e5) {
            throw new UnsupportedOperationException();
        }


        @Deprecated public static <E> ImmutableSortedSet<E> of(
                E e1, E e2, E e3, E e4, E e5, E e6, E... remaining) {
            throw new UnsupportedOperationException();
        }


        // NOTE: This one is "really" deprecated - we must remove it when we remove
        // the corresponding Immutable(Sorted)Set methods!
        @Deprecated public static <E> ImmutableSortedSet<E> of(E[] elements) {
            throw new UnsupportedOperationException();
        }


        @Deprecated public static <E> ImmutableSortedSet<E> copyOf(E[] elements) {
            throw new UnsupportedOperationException();
        }


    }
    static final class SortedLists {

        private SortedLists() {}


        enum Relation {

            LOWER {

                @Override Relation reverse() {
                    return HIGHER;
                }

                @Override <E> int exactMatchFound(List<? extends E> list, E e,
                                                  int lower, int index, int upper, Comparator<? super E> comparator,
                                                  boolean worryAboutDuplicates) {
                    return FLOOR.exactMatchFound(
                            list, e, lower, index, upper, comparator, worryAboutDuplicates)
                            - 1;
                }

                @Override <E> int exactMatchNotFound(List<? extends E> list, E e,
                                                     int higherIndex, Comparator<? super E> comparator) {
                    return higherIndex - 1;
                }
            },


            FLOOR {

                @Override Relation reverse() {
                    return CEILING;
                }

                @Override <E> int exactMatchFound(List<? extends E> list, E e,
                                                  int lower, int index, int upper, Comparator<? super E> comparator,
                                                  boolean worryAboutDuplicates) {
                    if (!worryAboutDuplicates) {
                        return index;
                    }
                    // Of course, we have to use binary search to find the precise
                    // breakpoint...
                    upper = index;
                    // Everything between lower and upper inclusive compares at <= 0.
                    while (lower < upper) {
                        int middle = lower + (upper - lower) / 2;
                        int c = comparator.compare(list.get(middle), e);
                        if (c < 0) {
                            lower = middle + 1;
                        } else { // c == 0
                            upper = middle;
                        }
                    }
                    return lower;
                }

                @Override <E> int exactMatchNotFound(List<? extends E> list, E e,
                                                     int higherIndex, Comparator<? super E> comparator) {
                    return higherIndex - 1;
                }
            },

            EQUAL {

                @Override Relation reverse() {
                    return this;
                }

                @Override <E> int exactMatchFound(List<? extends E> list, E e,
                                                  int lower, int index, int upper, Comparator<? super E> comparator,
                                                  boolean worryAboutDuplicates) {
                    return index;
                }

                @Override <E> int exactMatchNotFound(List<? extends E> list, E e,
                                                     int higherIndex, Comparator<? super E> comparator) {
                    return -1;
                }
            },

            CEILING {

                @Override Relation reverse() {
                    return FLOOR;
                }

                @Override <E> int exactMatchFound(List<? extends E> list, E e,
                                                  int lower, int index, int upper, Comparator<? super E> comparator,
                                                  boolean worryAboutDuplicates) {
                    if (!worryAboutDuplicates) {
                        return index;
                    }
                    // Of course, we have to use binary search to find the precise
                    // breakpoint...
                    lower = index;
                    // Everything between lower and upper inclusive compares at >= 0.
                    while (lower < upper) {
                        int middle = lower + (upper - lower + 1) / 2;
                        int c = comparator.compare(list.get(middle), e);
                        if (c > 0) {
                            upper = middle - 1;
                        } else { // c == 0
                            lower = middle;
                        }
                    }
                    return lower;
                }

                @Override <E> int exactMatchNotFound(List<? extends E> list, E e,
                                                     int higherIndex, Comparator<? super E> comparator) {
                    return higherIndex;
                }
            },

            HIGHER {

                @Override Relation reverse() {
                    return LOWER;
                }

                @Override <E> int exactMatchFound(List<? extends E> list, E e,
                                                  int lower, int index, int upper, Comparator<? super E> comparator,
                                                  boolean worryAboutDuplicates) {
                    return CEILING.exactMatchFound(
                            list, e, lower, index, upper, comparator, worryAboutDuplicates)
                            + 1;
                }

                @Override <E> int exactMatchNotFound(List<? extends E> list, E e,
                                                     int higherIndex, Comparator<? super E> comparator) {
                    return higherIndex;
                }
            };

            abstract Relation reverse();

            abstract <E> int exactMatchFound(List<? extends E> list, @Nullable E e,
                                             int lower, int index, int upper, Comparator<? super E> comparator,
                                             boolean worryAboutDuplicates);


            abstract <E> int exactMatchNotFound(List<? extends E> list, @Nullable E e,
                                                int higherIndex, Comparator<? super E> comparator);
        }

        static <E> int binarySearch(List<? extends E> list, @Nullable E e,
                                    Comparator<? super E> comparator, Relation relation) {
            return binarySearch(list, e, comparator, relation, true);
        }

        static <E> int binarySearch(List<? extends E> list, @Nullable E e,
                                    Comparator<? super E> comparator, Relation relation,
                                    boolean worryAboutDuplicates) {

            checkNotNull(comparator);
            checkNotNull(relation);

            int lower = 0;
            int upper = list.size() - 1;

            while (lower <= upper) {
                int middle = lower + (upper - lower) / 2;
                int c = comparator.compare(e, list.get(middle));
                if (c < 0) {
                    upper = middle - 1;
                } else if (c > 0) {
                    lower = middle + 1;
                } else {
                    return relation.exactMatchFound(
                            list, e, lower, middle, upper, comparator, worryAboutDuplicates);
                }
            }

            return relation.exactMatchNotFound(list, e, lower, comparator);
        }
    }
    static public abstract class ImmutableSet<E> extends ImmutableCollection<E>
            implements Set<E> {

        // Casting to any type is safe because the set will never hold any elements.
        @SuppressWarnings({"unchecked"})
        public static <E> ImmutableSet<E> of() {
            return (ImmutableSet<E>) EmptyImmutableSet.INSTANCE;
        }

        public static <E> ImmutableSet<E> of(E element) {
            return new SingletonImmutableSet<E>(element);
        }


        public static <E> ImmutableSet<E> of(E e1, E e2) {
            return construct(e1, e2);
        }

        public static <E> ImmutableSet<E> of(E e1, E e2, E e3) {
            return construct(e1, e2, e3);
        }

        public static <E> ImmutableSet<E> of(E e1, E e2, E e3, E e4) {
            return construct(e1, e2, e3, e4);
        }

        public static <E> ImmutableSet<E> of(E e1, E e2, E e3, E e4, E e5) {
            return construct(e1, e2, e3, e4, e5);
        }

        public static <E> ImmutableSet<E> of(E e1, E e2, E e3, E e4, E e5, E e6,
                                             E... others) {
            final int paramCount = 6;
            Object[] elements = new Object[paramCount + others.length];
            elements[0] = e1;
            elements[1] = e2;
            elements[2] = e3;
            elements[3] = e4;
            elements[4] = e5;
            elements[5] = e6;
            for (int i = paramCount; i < elements.length; i++) {
                elements[i] = others[i - paramCount];
            }
            return construct(elements);
        }


        private static <E> ImmutableSet<E> construct(Object... elements) {
            int tableSize = chooseTableSize(elements.length);
            Object[] table = new Object[tableSize];
            int mask = tableSize - 1;
            ArrayList<Object> uniqueElementsList = null;
            int hashCode = 0;
            for (int i = 0; i < elements.length; i++) {
                Object element = elements[i];
                int hash = element.hashCode();
                for (int j = Hashing.smear(hash); ; j++) {
                    int index = j & mask;
                    Object value = table[index];
                    if (value == null) {
                        if (uniqueElementsList != null) {
                            uniqueElementsList.add(element);
                        }
                        // Came to an empty slot. Put the element here.
                        table[index] = element;
                        hashCode += hash;
                        break;
                    } else if (value.equals(element)) {
                        if (uniqueElementsList == null) {
                            // first dup
                            uniqueElementsList = new ArrayList<Object>(elements.length);
                            for (int k = 0; k < i; k++) {
                                Object previous = elements[k];
                                uniqueElementsList.add(previous);
                            }
                        }
                        break;
                    }
                }
            }
            Object[] uniqueElements = uniqueElementsList == null
                    ? elements
                    : uniqueElementsList.toArray();
            if (uniqueElements.length == 1) {
                // There is only one element or elements are all duplicates
                @SuppressWarnings("unchecked") // we are careful to only pass in E
                        E element = (E) uniqueElements[0];
                return new SingletonImmutableSet<E>(element, hashCode);
            } else if (tableSize > 2 * chooseTableSize(uniqueElements.length)) {
                // Resize the table when the array includes too many duplicates.
                // when this happens, we have already made a copy
                return construct(uniqueElements);
            } else {
                return new RegularImmutableSet<E>(uniqueElements, hashCode, table, mask);
            }
        }

        // We use power-of-2 tables, and this is the highest int that's a power of 2
        static final int MAX_TABLE_SIZE = 1 << 30;

        // If the set has this many elements, it will "max out" the table size
        static final int CUTOFF = 1 << 29;

        static int chooseTableSize(int setSize) {
            if (setSize < CUTOFF) {
                return Integer.highestOneBit(setSize) << 2;
            }

            // The table can't be completely full or we'll get infinite reprobes
            checkArgument(setSize < MAX_TABLE_SIZE, "collection too large");
            return MAX_TABLE_SIZE;
        }

        // TODO(kevinb): when this is removed, remember to remove from ISS and ISSFS
        @Deprecated
        public static <E> ImmutableSet<E> of(E[] elements) {
            return copyOf(elements);
        }


        public static <E> ImmutableSet<E> copyOf(E[] elements) {
            // TODO(benyu): could we delegate to
            // copyFromCollection(Arrays.asList(elements))?
            switch (elements.length) {
                case 0:
                    return of();
                case 1:
                    return of(elements[0]);
                default:
                    return construct(elements.clone());
            }
        }


        public static <E> ImmutableSet<E> copyOf(Iterable<? extends E> elements) {
            return (elements instanceof Collection)
                    ? copyOf(Collections2.cast(elements))
                    : copyOf(elements.iterator());
        }


        public static <E> ImmutableSet<E> copyOf(Iterator<? extends E> elements) {
            // TODO(benyu): here we could avoid toArray() for 0 or 1-element list,
            // worth it?
            return copyFromCollection(Lists.newArrayList(elements));
        }

        public static <E> ImmutableSet<E> copyOf(Collection<? extends E> elements) {
            if (elements instanceof ImmutableSet
                    && !(elements instanceof ImmutableSortedSet)) {
                @SuppressWarnings("unchecked") // all supported methods are covariant
                        ImmutableSet<E> set = (ImmutableSet<E>) elements;
                if (!set.isPartialView()) {
                    return set;
                }
            }
            return copyFromCollection(elements);
        }

        private static <E> ImmutableSet<E> copyFromCollection(
                Collection<? extends E> collection) {
            Object[] elements = collection.toArray();
            switch (elements.length) {
                case 0:
                    return of();
                case 1:
                    @SuppressWarnings("unchecked") // collection had only Es in it
                            E onlyElement = (E) elements[0];
                    return of(onlyElement);
                default:
                    // safe to use the array without copying it
                    // as specified by Collection.toArray().
                    return construct(elements);
            }
        }

        ImmutableSet() {}


        boolean isHashCodeFast() {
            return false;
        }

        @Override public boolean equals(@Nullable Object object) {
            if (object == this) {
                return true;
            }
            if (object instanceof ImmutableSet
                    && isHashCodeFast()
                    && ((ImmutableSet<?>) object).isHashCodeFast()
                    && hashCode() != object.hashCode()) {
                return false;
            }
            return Sets.equalsImpl(this, object);
        }

        @Override public int hashCode() {
            return Sets.hashCodeImpl(this);
        }

        // This declaration is needed to make Set.iterator() and
        // ImmutableCollection.iterator() consistent.
        @Override public abstract UnmodifiableIterator<E> iterator();

        abstract static class ArrayImmutableSet<E> extends ImmutableSet<E> {
            // the elements (two or more) in the desired order.
            final transient Object[] elements;

            ArrayImmutableSet(Object[] elements) {
                this.elements = elements;
            }

            @Override
            public int size() {
                return elements.length;
            }

            @Override public boolean isEmpty() {
                return false;
            }


            @SuppressWarnings("unchecked")
            @Override public UnmodifiableIterator<E> iterator() {
                return (UnmodifiableIterator<E>) Iterators.forArray(elements);
            }

            @Override public Object[] toArray() {
                Object[] array = new Object[size()];
                System.arraycopy(elements, 0, array, 0, size());
                return array;
            }

            @Override public <T> T[] toArray(T[] array) {
                int size = size();
                if (array.length < size) {
                    array = ObjectArrays.newArray(array, size);
                } else if (array.length > size) {
                    array[size] = null;
                }
                System.arraycopy(elements, 0, array, 0, size);
                return array;
            }

            @Override public boolean containsAll(Collection<?> targets) {
                if (targets == this) {
                    return true;
                }
                if (!(targets instanceof ArrayImmutableSet)) {
                    return super.containsAll(targets);
                }
                if (targets.size() > size()) {
                    return false;
                }
                for (Object target : ((ArrayImmutableSet<?>) targets).elements) {
                    if (!contains(target)) {
                        return false;
                    }
                }
                return true;
            }

            @Override boolean isPartialView() {
                return false;
            }

            @Override ImmutableList<E> createAsList() {
                return new ImmutableAsList<E>(elements, this);
            }
        }


        abstract static class TransformedImmutableSet<D, E> extends ImmutableSet<E> {
            final D[] source;
            final int hashCode;

            TransformedImmutableSet(D[] source, int hashCode) {
                this.source = source;
                this.hashCode = hashCode;
            }

            abstract E transform(D element);

            @Override
            public int size() {
                return source.length;
            }

            @Override public boolean isEmpty() {
                return false;
            }

            @Override public UnmodifiableIterator<E> iterator() {
                return new AbstractIndexedListIterator<E>(source.length) {
                    @Override protected E get(int index) {
                        return transform(source[index]);
                    }
                };
            }

            @Override public Object[] toArray() {
                return toArray(new Object[size()]);
            }

            @Override public <T> T[] toArray(T[] array) {
                int size = size();
                if (array.length < size) {
                    array = ObjectArrays.newArray(array, size);
                } else if (array.length > size) {
                    array[size] = null;
                }

                // Writes will produce ArrayStoreException when the toArray() doc requires
                Object[] objectArray = array;
                for (int i = 0; i < source.length; i++) {
                    objectArray[i] = transform(source[i]);
                }
                return array;
            }

            @Override public final int hashCode() {
                return hashCode;
            }

            @Override boolean isHashCodeFast() {
                return true;
            }
        }


        private static class SerializedForm implements Serializable {
            final Object[] elements;
            SerializedForm(Object[] elements) {
                this.elements = elements;
            }
            Object readResolve() {
                return copyOf(elements);
            }
            private static final long serialVersionUID = 0;
        }

        @Override Object writeReplace() {
            return new SerializedForm(toArray());
        }


        public static <E> Builder<E> builder() {
            return new Builder<E>();
        }


        public static class Builder<E> extends ImmutableCollection.Builder<E> {
            // accessed directly by ImmutableSortedSet
            final ArrayList<E> contents = Lists.newArrayList();


            public Builder() {}


            @Override public Builder<E> add(E element) {
                contents.add(checkNotNull(element));
                return this;
            }

            @Override public Builder<E> add(E... elements) {
                contents.ensureCapacity(contents.size() + elements.length);
                super.add(elements);
                return this;
            }


            @Override public Builder<E> addAll(Iterable<? extends E> elements) {
                if (elements instanceof Collection) {
                    Collection<?> collection = (Collection<?>) elements;
                    contents.ensureCapacity(contents.size() + collection.size());
                }
                super.addAll(elements);
                return this;
            }

            @Override public Builder<E> addAll(Iterator<? extends E> elements) {
                super.addAll(elements);
                return this;
            }


            @Override public ImmutableSet<E> build() {
                return copyOf(contents);
            }
        }
    }
    static class ImmutableEntry<K, V> extends AbstractMapEntry<K, V>
            implements Serializable {
        private final K key;
        private final V value;

        ImmutableEntry(@Nullable K key, @Nullable V value) {
            this.key = key;
            this.value = value;
        }

        @Override public K getKey() {
            return key;
        }

        @Override public V getValue() {
            return value;
        }

        @Override public final V setValue(V value){
            throw new UnsupportedOperationException();
        }

        private static final long serialVersionUID = 0;
    }
    static final class RegularImmutableSortedSet<E> extends ImmutableSortedSet<E> {

        private transient final ImmutableList<E> elements;

        RegularImmutableSortedSet(
                ImmutableList<E> elements, Comparator<? super E> comparator) {
            super(comparator);
            this.elements = elements;
            checkArgument(!elements.isEmpty());
        }

        @Override public UnmodifiableIterator<E> iterator() {
            return elements.iterator();
        }

        @Override public boolean isEmpty() {
            return false;
        }

        public int size() {
            return elements.size();
        }

        @Override public boolean contains(Object o) {
            if (o == null) {
                return false;
            }
            try {
                return binarySearch(o) >= 0;
            } catch (ClassCastException e) {
                return false;
            }
        }

        @Override public boolean containsAll(Collection<?> targets) {

            if (!hasSameComparator(targets, comparator()) || (targets.size() <= 1)) {
                return super.containsAll(targets);
            }


            Iterator<E> thisIterator = iterator();
            Iterator<?> thatIterator = targets.iterator();
            Object target = thatIterator.next();

            try {

                while (thisIterator.hasNext()) {

                    int cmp = unsafeCompare(thisIterator.next(), target);

                    if (cmp == 0) {

                        if (!thatIterator.hasNext()) {

                            return true;
                        }

                        target = thatIterator.next();

                    } else if (cmp > 0) {
                        return false;
                    }
                }
            } catch (NullPointerException e) {
                return false;
            } catch (ClassCastException e) {
                return false;
            }

            return false;
        }

        private int binarySearch(Object key) {

            @SuppressWarnings("unchecked")
            Comparator<Object> unsafeComparator = (Comparator<Object>) comparator;

            return Collections.binarySearch(elements, key, unsafeComparator);
        }

        @Override boolean isPartialView() {
            return elements.isPartialView();
        }

        @Override public Object[] toArray() {
            return elements.toArray();
        }

        @Override public <T> T[] toArray(T[] array) {
            return elements.toArray(array);
        }

        @Override public boolean equals(@Nullable Object object) {
            if (object == this) {
                return true;
            }
            if (!(object instanceof Set)) {
                return false;
            }

            Set<?> that = (Set<?>) object;
            if (size() != that.size()) {
                return false;
            }

            if (hasSameComparator(that, comparator)) {
                Iterator<?> otherIterator = that.iterator();
                try {
                    Iterator<E> iterator = iterator();
                    while (iterator.hasNext()) {
                        Object element = iterator.next();
                        Object otherElement = otherIterator.next();
                        if (otherElement == null
                                || unsafeCompare(element, otherElement) != 0) {
                            return false;
                        }
                    }
                    return true;
                } catch (ClassCastException e) {
                    return false;
                } catch (NoSuchElementException e) {
                    return false; // concurrent change to other set
                }
            }
            return this.containsAll(that);
        }

        public E first() {
            return elements.get(0);
        }

        public E last() {
            return elements.get(size() - 1);
        }

        @Override ImmutableSortedSet<E> headSetImpl(E toElement) {
            return createSubset(0, findSubsetIndex(toElement));
        }

        @Override ImmutableSortedSet<E> subSetImpl(E fromElement, E toElement) {
            return createSubset(
                    findSubsetIndex(fromElement), findSubsetIndex(toElement));
        }

        @Override ImmutableSortedSet<E> tailSetImpl(E fromElement) {
            return createSubset(findSubsetIndex(fromElement), size());
        }

        private int findSubsetIndex(E element) {
            int index = binarySearch(element);
            return (index >= 0) ? index : (-index - 1);
        }

        private ImmutableSortedSet<E> createSubset(int newFromIndex, int newToIndex) {
            if (newFromIndex < newToIndex) {
                return new RegularImmutableSortedSet<E>(
                        elements.subList(newFromIndex, newToIndex), comparator);
            } else {
                return emptySet(comparator);
            }
        }

        @Override int indexOf(Object target) {
            if (target == null) {
                return -1;
            }
            int position;
            try {
                position = binarySearch(target);
            } catch (ClassCastException e) {
                return -1;
            }

            return (position >= 0 && elements.get(position).equals(target))
                    ? position : -1;
        }

        @Override ImmutableList<E> createAsList() {
            return new ImmutableSortedAsList<E>(this, elements);
        }
    }
    static final class RegularImmutableSet<E> extends ArrayImmutableSet<E> {
        // the same elements in hashed positions (plus nulls)
        @VisibleForTesting final transient Object[] table;
        // 'and' with an int to get a valid table index.
        private final transient int mask;
        private final transient int hashCode;

        RegularImmutableSet(
                Object[] elements, int hashCode, Object[] table, int mask) {
            super(elements);
            this.table = table;
            this.mask = mask;
            this.hashCode = hashCode;
        }

        @Override public boolean contains(Object target) {
            if (target == null) {
                return false;
            }
            for (int i = Hashing.smear(target.hashCode()); true; i++) {
                Object candidate = table[i & mask];
                if (candidate == null) {
                    return false;
                }
                if (candidate.equals(target)) {
                    return true;
                }
            }
        }

        @Override public int hashCode() {
            return hashCode;
        }

        @Override boolean isHashCodeFast() {
            return true;
        }
    }
    final static class SingletonImmutableSet<E> extends ImmutableSet<E> {

        final transient E element;

        // Non-volatile because:
        //   - Integer is immutable and thus thread-safe;
        //   - no problems if one thread overwrites the cachedHashCode from another.
        private transient Integer cachedHashCode;

        SingletonImmutableSet(E element) {
            this.element = Preconditions.checkNotNull(element);
        }

        SingletonImmutableSet(E element, int hashCode) {
            // Guaranteed to be non-null by the presence of the pre-computed hash code.
            this.element = element;
            cachedHashCode = hashCode;
        }

        @Override
        public int size() {
            return 1;
        }

        @Override public boolean isEmpty() {
            return false;
        }

        @Override public boolean contains(Object target) {
            return element.equals(target);
        }

        @Override public UnmodifiableIterator<E> iterator() {
            return Iterators.singletonIterator(element);
        }

        @Override boolean isPartialView() {
            return false;
        }

        @Override public Object[] toArray() {
            return new Object[] { element };
        }

        @SuppressWarnings({"unchecked"})
        @Override public <T> T[] toArray(T[] array) {
            if (array.length == 0) {
                array = ObjectArrays.newArray(array, 1);
            } else if (array.length > 1) {
                array[1] = null;
            }
            // Writes will produce ArrayStoreException when the toArray() doc requires.
            Object[] objectArray = array;
            objectArray[0] = element;
            return array;
        }

        @Override public boolean equals(@Nullable Object object) {
            if (object == this) {
                return true;
            }
            if (object instanceof Set) {
                Set<?> that = (Set<?>) object;
                return that.size() == 1 && element.equals(that.iterator().next());
            }
            return false;
        }

        @Override public final int hashCode() {
            Integer code = cachedHashCode;
            if (code == null) {
                return cachedHashCode = element.hashCode();
            }
            return code;
        }

        @Override boolean isHashCodeFast() {
            return false;
        }

        @Override public String toString() {
            String elementToString = element.toString();
            return new StringBuilder(elementToString.length() + 2)
                    .append('[')
                    .append(elementToString)
                    .append(']')
                    .toString();
        }
    }

    static final class Hashing {
        private Hashing() {}

        static int smear(int hashCode) {
            hashCode ^= (hashCode >>> 20) ^ (hashCode >>> 12);
            return hashCode ^ (hashCode >>> 7) ^ (hashCode >>> 4);
        }
    }
    final static class SingletonImmutableMap<K, V> extends ImmutableMap<K, V> {

        final transient K singleKey;
        final transient V singleValue;

        private transient Entry<K, V> entry;

        SingletonImmutableMap(K singleKey, V singleValue) {
            this.singleKey = singleKey;
            this.singleValue = singleValue;
        }

        SingletonImmutableMap(Entry<K, V> entry) {
            this.entry = entry;
            this.singleKey = entry.getKey();
            this.singleValue = entry.getValue();
        }

        private Entry<K, V> entry() {
            Entry<K, V> e = entry;
            return (e == null)
                    ? (entry = Maps.immutableEntry(singleKey, singleValue)) : e;
        }

        @Override public V get(Object key) {
            return singleKey.equals(key) ? singleValue : null;
        }

        @Override
        public int size() {
            return 1;
        }

        @Override public boolean isEmpty() {
            return false;
        }

        @Override public boolean containsKey(Object key) {
            return singleKey.equals(key);
        }

        @Override public boolean containsValue(Object value) {
            return singleValue.equals(value);
        }

        @Override boolean isPartialView() {
            return false;
        }

        private transient ImmutableSet<Entry<K, V>> entrySet;

        @Override public ImmutableSet<Entry<K, V>> entrySet() {
            ImmutableSet<Entry<K, V>> es = entrySet;
            return (es == null) ? (entrySet = ImmutableSet.of(entry())) : es;
        }

        private transient ImmutableSet<K> keySet;

        @Override public ImmutableSet<K> keySet() {
            ImmutableSet<K> ks = keySet;
            return (ks == null) ? (keySet = ImmutableSet.of(singleKey)) : ks;
        }

        private transient ImmutableCollection<V> values;

        @Override public ImmutableCollection<V> values() {
            ImmutableCollection<V> v = values;
            return (v == null) ? (values = new Values<V>(singleValue)) : v;
        }

        @SuppressWarnings("serial") // uses writeReplace(), not default serialization
        private static class Values<V> extends ImmutableCollection<V> {
            final V singleValue;

            Values(V singleValue) {
                this.singleValue = singleValue;
            }

            @Override public boolean contains(Object object) {
                return singleValue.equals(object);
            }

            @Override public boolean isEmpty() {
                return false;
            }

            @Override
            public int size() {
                return 1;
            }

            @Override public UnmodifiableIterator<V> iterator() {
                return Iterators.singletonIterator(singleValue);
            }

            @Override boolean isPartialView() {
                return true;
            }
        }

        @Override public boolean equals(@Nullable Object object) {
            if (object == this) {
                return true;
            }
            if (object instanceof Map) {
                Map<?, ?> that = (Map<?, ?>) object;
                if (that.size() != 1) {
                    return false;
                }
                Entry<?, ?> entry = that.entrySet().iterator().next();
                return singleKey.equals(entry.getKey())
                        && singleValue.equals(entry.getValue());
            }
            return false;
        }

        @Override public int hashCode() {
            return singleKey.hashCode() ^ singleValue.hashCode();
        }

        @Override public String toString() {
            return new StringBuilder()
                    .append('{')
                    .append(singleKey.toString())
                    .append('=')
                    .append(singleValue.toString())
                    .append('}')
                    .toString();
        }
    }

     public interface BiMap<K, V> extends Map<K, V> {
        // Modification Operations

        @Override
        V put(@Nullable K key, @Nullable V value);

        V forcePut(@Nullable K key, @Nullable V value);

        // Bulk Operations


        @Override
        void putAll(Map<? extends K, ? extends V> map);

        @Override
        Set<V> values();

        BiMap<V, K> inverse();
    }
    abstract static class TransformedImmutableList<D, E> extends ImmutableList<E> {
        private class TransformedView extends TransformedImmutableList<D, E> {
            TransformedView(ImmutableList<D> backingList) {
                super(backingList);
            }

            @Override E transform(D d) {
                return TransformedImmutableList.this.transform(d);
            }
        }

        private transient final ImmutableList<D> backingList;

        TransformedImmutableList(ImmutableList<D> backingList) {
            this.backingList = checkNotNull(backingList);
        }

        abstract E transform(D d);

        @Override public int indexOf(@Nullable Object object) {
            if (object == null) {
                return -1;
            }
            for (int i = 0; i < size(); i++) {
                if (get(i).equals(object)) {
                    return i;
                }
            }
            return -1;
        }

        @Override public int lastIndexOf(@Nullable Object object) {
            if (object == null) {
                return -1;
            }
            for (int i = size() - 1; i >= 0; i--) {
                if (get(i).equals(object)) {
                    return i;
                }
            }
            return -1;
        }

        @Override public E get(int index) {
            return transform(backingList.get(index));
        }

        @Override public UnmodifiableListIterator<E> listIterator(int index) {
            return new AbstractIndexedListIterator<E>(size(), index) {
                @Override protected E get(int index) {
                    return TransformedImmutableList.this.get(index);
                }
            };
        }

        @Override public int size() {
            return backingList.size();
        }

        @Override public ImmutableList<E> subList(int fromIndex, int toIndex) {
            return new TransformedView(backingList.subList(fromIndex, toIndex));
        }

        @Override public boolean equals(Object obj) {
            if (obj == this) {
                return true;
            }
            if (obj instanceof List) {
                List<?> list = (List<?>) obj;
                return size() == list.size()
                        && Iterators.elementsEqual(iterator(), list.iterator());
            }
            return false;
        }

        @Override public int hashCode() {
            int hashCode = 1;
            for (E e : this) {
                hashCode = 31 * hashCode + (e == null ? 0 : e.hashCode());
            }
            return hashCode;
        }

        @Override public Object[] toArray() {
            return ObjectArrays.toArrayImpl(this);
        }

        @Override public <T> T[] toArray(T[] array) {
            return ObjectArrays.toArrayImpl(this, array);
        }

        @Override boolean isPartialView() {
            return true;
        }
    }

    final static class RegularImmutableMap<K, V> extends ImmutableMap<K, V> {

        // entries in insertion order
        private final transient LinkedEntry<K, V>[] entries;
        // array of linked lists of entries
        private final transient LinkedEntry<K, V>[] table;
        // 'and' with an int to get a table index
        private final transient int mask;
        private final transient int keySetHashCode;

        // TODO(gak): investigate avoiding the creation of ImmutableEntries since we
        // re-copy them anyway.
        RegularImmutableMap(Entry<?, ?>... immutableEntries) {
            int size = immutableEntries.length;
            entries = createEntryArray(size);

            int tableSize = chooseTableSize(size);
            table = createEntryArray(tableSize);
            mask = tableSize - 1;

            int keySetHashCodeMutable = 0;
            for (int entryIndex = 0; entryIndex < size; entryIndex++) {
                // each of our 6 callers carefully put only Entry<K, V>s into the array!
                @SuppressWarnings("unchecked")
                Entry<K, V> entry = (Entry<K, V>) immutableEntries[entryIndex];
                K key = entry.getKey();
                int keyHashCode = key.hashCode();
                keySetHashCodeMutable += keyHashCode;
                int tableIndex = Hashing.smear(keyHashCode) & mask;
                @Nullable LinkedEntry<K, V> existing = table[tableIndex];
                // prepend, not append, so the entries can be immutable
                LinkedEntry<K, V> linkedEntry =
                        newLinkedEntry(key, entry.getValue(), existing);
                table[tableIndex] = linkedEntry;
                entries[entryIndex] = linkedEntry;
                while (existing != null) {
                    checkArgument(!key.equals(existing.getKey()), "duplicate key: %s", key);
                    existing = existing.next();
                }
            }
            keySetHashCode = keySetHashCodeMutable;
        }

        private static int chooseTableSize(int size) {
            // least power of 2 greater than size
            int tableSize = Integer.highestOneBit(size) << 1;
            checkArgument(tableSize > 0, "table too large: %s", size);
            return tableSize;
        }


        @SuppressWarnings("unchecked") // Safe as long as the javadocs are followed
        private LinkedEntry<K, V>[] createEntryArray(int size) {
            return new LinkedEntry[size];
        }

        private static <K, V> LinkedEntry<K, V> newLinkedEntry(K key, V value,
                                                               @Nullable LinkedEntry<K, V> next) {
            return (next == null)
                    ? new TerminalEntry<K, V>(key, value)
                    : new NonTerminalEntry<K, V>(key, value, next);
        }

        private interface LinkedEntry<K, V> extends Entry<K, V> {

            @Nullable LinkedEntry<K, V> next();
        }

        @SuppressWarnings("serial") // this class is never serialized
        private static final class NonTerminalEntry<K, V>
                extends ImmutableEntry<K, V> implements LinkedEntry<K, V> {
            final LinkedEntry<K, V> next;

            NonTerminalEntry(K key, V value, LinkedEntry<K, V> next) {
                super(key, value);
                this.next = next;
            }

            @Override public LinkedEntry<K, V> next() {
                return next;
            }
        }



        @SuppressWarnings("serial") // this class is never serialized
        private static final class TerminalEntry<K, V> extends ImmutableEntry<K, V>
                implements LinkedEntry<K, V> {
            TerminalEntry(K key, V value) {
                super(key, value);
            }

            @Nullable @Override public LinkedEntry<K, V> next() {
                return null;
            }
        }

        @Override public V get(Object key) {
            if (key == null) {
                return null;
            }
            int index = Hashing.smear(key.hashCode()) & mask;
            for (LinkedEntry<K, V> entry = table[index];
                 entry != null;
                 entry = entry.next()) {
                K candidateKey = entry.getKey();

                if (key.equals(candidateKey)) {
                    return entry.getValue();
                }
            }
            return null;
        }

        @Override
        public int size() {
            return entries.length;
        }

        @Override public boolean isEmpty() {
            return false;
        }

        @Override public boolean containsValue(Object value) {
            if (value == null) {
                return false;
            }
            for (Entry<K, V> entry : entries) {
                if (entry.getValue().equals(value)) {
                    return true;
                }
            }
            return false;
        }

        @Override boolean isPartialView() {
            return false;
        }

        private transient ImmutableSet<Entry<K, V>> entrySet;

        @Override public ImmutableSet<Entry<K, V>> entrySet() {
            ImmutableSet<Entry<K, V>> es = entrySet;
            return (es == null) ? (entrySet = new EntrySet<K, V>(this)) : es;
        }

        @SuppressWarnings("serial") // uses writeReplace(), not default serialization
        private static class EntrySet<K, V> extends ArrayImmutableSet<Entry<K, V>> {
            final transient RegularImmutableMap<K, V> map;

            EntrySet(RegularImmutableMap<K, V> map) {
                super(map.entries);
                this.map = map;
            }

            @Override public boolean contains(Object target) {
                if (target instanceof Entry) {
                    Entry<?, ?> entry = (Entry<?, ?>) target;
                    V mappedValue = map.get(entry.getKey());
                    return mappedValue != null && mappedValue.equals(entry.getValue());
                }
                return false;
            }
        }

        private transient ImmutableSet<K> keySet;

        @Override public ImmutableSet<K> keySet() {
            ImmutableSet<K> ks = keySet;
            return (ks == null) ? (keySet = new KeySet<K, V>(this)) : ks;
        }

        @SuppressWarnings("serial") // uses writeReplace(), not default serialization
        private static class KeySet<K, V>
                extends ImmutableSet.TransformedImmutableSet<Entry<K, V>, K> {
            final RegularImmutableMap<K, V> map;

            KeySet(RegularImmutableMap<K, V> map) {
                super(map.entries, map.keySetHashCode);
                this.map = map;
            }

            @Override K transform(Entry<K, V> element) {
                return element.getKey();
            }

            @Override public boolean contains(Object target) {
                return map.containsKey(target);
            }

            @Override boolean isPartialView() {
                return true;
            }
        }

        private transient ImmutableCollection<V> values;

        @Override public ImmutableCollection<V> values() {
            ImmutableCollection<V> v = values;
            return (v == null) ? (values = new Values<V>(this)) : v;
        }

        @SuppressWarnings("serial") // uses writeReplace(), not default serialization
        private static class Values<V> extends ImmutableCollection<V> {
            final RegularImmutableMap<?, V> map;

            Values(RegularImmutableMap<?, V> map) {
                this.map = map;
            }

            @Override
            public int size() {
                return map.entries.length;
            }

            @Override public UnmodifiableIterator<V> iterator() {
                return new AbstractIndexedListIterator<V>(map.entries.length) {
                    @Override protected V get(int index) {
                        return map.entries[index].getValue();
                    }
                };
            }

            @Override public boolean contains(Object target) {
                return map.containsValue(target);
            }

            @Override boolean isPartialView() {
                return true;
            }
        }

        @Override public String toString() {
            StringBuilder result
                    = Collections2.newStringBuilderForCollection(size()).append('{');
            Collections2.STANDARD_JOINER.appendTo(result, entries);
            return result.append('}').toString();
        }

        // This class is never actually serialized directly, but we have to make the
        // warning go away (and suppressing would suppress for all nested classes too)
        private static final long serialVersionUID = 0;
    }
    final static class EmptyImmutableMap extends ImmutableMap<Object, Object> {
        static final EmptyImmutableMap INSTANCE = new EmptyImmutableMap();

        private EmptyImmutableMap() {}

        @Override public Object get(Object key) {
            return null;
        }

        @Override
        public int size() {
            return 0;
        }

        @Override public boolean isEmpty() {
            return true;
        }

        @Override public boolean containsKey(Object key) {
            return false;
        }

        @Override public boolean containsValue(Object value) {
            return false;
        }

        @Override public ImmutableSet<Entry<Object, Object>> entrySet() {
            return ImmutableSet.of();
        }

        @Override public ImmutableSet<Object> keySet() {
            return ImmutableSet.of();
        }

        @Override public ImmutableCollection<Object> values() {
            return ImmutableCollection.EMPTY_IMMUTABLE_COLLECTION;
        }

        @Override public boolean equals(@Nullable Object object) {
            if (object instanceof Map) {
                Map<?, ?> that = (Map<?, ?>) object;
                return that.isEmpty();
            }
            return false;
        }

        @Override boolean isPartialView() {
            return false;
        }

        @Override public int hashCode() {
            return 0;
        }

        @Override public String toString() {
            return "{}";
        }

        Object readResolve() {
            return INSTANCE; // preserve singleton property
        }

        private static final long serialVersionUID = 0;
    }
    public abstract static class ImmutableMap<K, V> implements Map<K, V>, Serializable {

        // Casting to any type is safe because the set will never hold any elements.
        @SuppressWarnings("unchecked")
        public static <K, V> ImmutableMap<K, V> of() {
            return (ImmutableMap<K, V>) EmptyImmutableMap.INSTANCE;
        }


        public static <K, V> ImmutableMap<K, V> of(K k1, V v1) {
            return new SingletonImmutableMap<K, V>(
                    checkNotNull(k1), checkNotNull(v1));
        }


        public static <K, V> ImmutableMap<K, V> of(K k1, V v1, K k2, V v2) {
            return new RegularImmutableMap<K, V>(entryOf(k1, v1), entryOf(k2, v2));
        }


        public static <K, V> ImmutableMap<K, V> of(
                K k1, V v1, K k2, V v2, K k3, V v3) {
            return new RegularImmutableMap<K, V>(
                    entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3));
        }


        public static <K, V> ImmutableMap<K, V> of(
                K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {
            return new RegularImmutableMap<K, V>(
                    entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3), entryOf(k4, v4));
        }


        public static <K, V> ImmutableMap<K, V> of(
                K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {
            return new RegularImmutableMap<K, V>(entryOf(k1, v1),
                    entryOf(k2, v2), entryOf(k3, v3), entryOf(k4, v4), entryOf(k5, v5));
        }


        public static <K, V> Builder<K, V> builder() {
            return new Builder<K, V>();
        }


        static <K, V> Entry<K, V> entryOf(K key, V value) {
            return (Entry<K, V>) Maps.immutableEntry(
                    checkNotNull(key, "null key"),
                    checkNotNull(value, "null value"));
        }


        public static class Builder<K, V> {
            final ArrayList<Entry<K, V>> entries = Lists.newArrayList();


            public Builder() {}


            public Builder<K, V> put(K key, V value) {
                entries.add(entryOf(key, value));
                return this;
            }


            public Builder<K, V> putAll(Map<? extends K, ? extends V> map) {
                entries.ensureCapacity(entries.size() + map.size());
                for (Entry<? extends K, ? extends V> entry : map.entrySet()) {
                    put(entry.getKey(), entry.getValue());
                }
                return this;
            }


            public ImmutableMap<K, V> build() {
                return fromEntryList(entries);
            }

            private static <K, V> ImmutableMap<K, V> fromEntryList(
                    List<Entry<K, V>> entries) {
                int size = entries.size();
                switch (size) {
                    case 0:
                        return of();
                    case 1:
                        return new SingletonImmutableMap<K, V>(Iterables.getOnlyElement(entries));
                    default:
                        Entry<?, ?>[] entryArray
                                = entries.toArray(new Entry<?, ?>[entries.size()]);
                        return new RegularImmutableMap<K, V>(entryArray);
                }
            }
        }


        public static <K, V> ImmutableMap<K, V> copyOf(
                Map<? extends K, ? extends V> map) {
            if ((map instanceof ImmutableMap) && !(map instanceof ImmutableSortedMap)) {
                // TODO(user): Make ImmutableMap.copyOf(immutableBiMap) call copyOf()
                // on the ImmutableMap delegate(), rather than the bimap itself

                @SuppressWarnings("unchecked") // safe since map is not writable
                        ImmutableMap<K, V> kvMap = (ImmutableMap<K, V>) map;
                if (!kvMap.isPartialView()) {
                    return kvMap;
                }
            }

            @SuppressWarnings("unchecked") // we won't write to this array
                    Entry<K, V>[] entries = map.entrySet().toArray(new Entry[0]);
            switch (entries.length) {
                case 0:
                    return of();
                case 1:
                    return new SingletonImmutableMap<K, V>(entryOf(
                            entries[0].getKey(), entries[0].getValue()));
                default:
                    for (int i = 0; i < entries.length; i++) {
                        K k = entries[i].getKey();
                        V v = entries[i].getValue();
                        entries[i] = entryOf(k, v);
                    }
                    return new RegularImmutableMap<K, V>(entries);
            }
        }

        ImmutableMap() {}


        @Override
        public final V put(K k, V v) {
            throw new UnsupportedOperationException();
        }

        @Override
        public final V remove(Object o) {
            throw new UnsupportedOperationException();
        }

        @Override
        public final void putAll(Map<? extends K, ? extends V> map) {
            throw new UnsupportedOperationException();
        }

        @Override
        public final void clear() {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean isEmpty() {
            return size() == 0;
        }

        @Override
        public boolean containsKey(@Nullable Object key) {
            return get(key) != null;
        }

        // Overriding to mark it Nullable
        @Override
        public abstract boolean containsValue(@Nullable Object value);

        // Overriding to mark it Nullable
        @Override
        public abstract V get(@Nullable Object key);


        @Override
        public abstract ImmutableSet<Entry<K, V>> entrySet();


        @Override
        public abstract ImmutableSet<K> keySet();

        @Override
        public abstract ImmutableCollection<V> values();

        @Override public boolean equals(@Nullable Object object) {
            if (object == this) {
                return true;
            }
            if (object instanceof Map) {
                Map<?, ?> that = (Map<?, ?>) object;
                return this.entrySet().equals(that.entrySet());
            }
            return false;
        }

        abstract boolean isPartialView();

        @Override public int hashCode() {
            // not caching hash code since it could change if map values are mutable
            // in a way that modifies their hash codes
            return entrySet().hashCode();
        }

        @Override public String toString() {
            return Maps.toStringImpl(this);
        }


        static class SerializedForm implements Serializable {
            private final Object[] keys;
            private final Object[] values;
            SerializedForm(ImmutableMap<?, ?> map) {
                keys = new Object[map.size()];
                values = new Object[map.size()];
                int i = 0;
                for (Entry<?, ?> entry : map.entrySet()) {
                    keys[i] = entry.getKey();
                    values[i] = entry.getValue();
                    i++;
                }
            }
            Object readResolve() {
                Builder<Object, Object> builder = new Builder<Object, Object>();
                return createMap(builder);
            }
            Object createMap(Builder<Object, Object> builder) {
                for (int i = 0; i < keys.length; i++) {
                    builder.put(keys[i], values[i]);
                }
                return builder.build();
            }
            private static final long serialVersionUID = 0;
        }

        Object writeReplace() {
            return new SerializedForm(this);
        }
    }
    public @interface Beta {}
    static final class ImmutableEnumSet<E extends Enum<E>> extends ImmutableSet<E> {

        private final transient EnumSet<E> delegate;

        ImmutableEnumSet(EnumSet<E> delegate) {
            this.delegate = delegate;
        }

        @Override boolean isPartialView() {
            return false;
        }

        @Override public UnmodifiableIterator<E> iterator() {
            return Iterators.unmodifiableIterator(delegate.iterator());
        }

        public int size() {
            return delegate.size();
        }

        @Override public boolean contains(Object object) {
            return delegate.contains(object);
        }

        @Override public boolean containsAll(Collection<?> collection) {
            return delegate.containsAll(collection);
        }

        @Override public boolean isEmpty() {
            return delegate.isEmpty();
        }

        @Override public Object[] toArray() {
            return delegate.toArray();
        }

        @Override public <T> T[] toArray(T[] array) {
            return delegate.toArray(array);
        }

        @Override public boolean equals(Object object) {
            return object == this || delegate.equals(object);
        }

        private transient int hashCode;

        @Override public int hashCode() {
            int result = hashCode;
            return (result == 0) ? hashCode = delegate.hashCode() : result;
        }

        @Override public String toString() {
            return delegate.toString();
        }

        // All callers of the constructor are restricted to <E extends Enum<E>>.
        @Override Object writeReplace() {
            return new EnumSerializedForm<E>(delegate);
        }

        /*
         * This class is used to serialize ImmutableEnumSet instances.
         */
        private static class EnumSerializedForm<E extends Enum<E>>
                implements Serializable {
            final EnumSet<E> delegate;
            EnumSerializedForm(EnumSet<E> delegate) {
                this.delegate = delegate;
            }
            Object readResolve() {
                // EJ2 #76: Write readObject() methods defensively.
                return new ImmutableEnumSet<E>(delegate.clone());
            }
            private static final long serialVersionUID = 0;
        }
    }
    static public final class Sets {
        private Sets() {}

        @GwtCompatible(serializable = true)
        public static <E extends Enum<E>> ImmutableSet<E> immutableEnumSet(
                E anElement, E... otherElements) {
            return new ImmutableEnumSet<E>(EnumSet.of(anElement, otherElements));
        }

        @GwtCompatible(serializable = true)
        public static <E extends Enum<E>> ImmutableSet<E> immutableEnumSet(
                Iterable<E> elements) {
            Iterator<E> iterator = elements.iterator();
            if (!iterator.hasNext()) {
                return ImmutableSet.of();
            }
            if (elements instanceof EnumSet) {
                EnumSet<E> enumSetClone = EnumSet.copyOf((EnumSet<E>) elements);
                return new ImmutableEnumSet<E>(enumSetClone);
            }
            E first = iterator.next();
            EnumSet<E> set = EnumSet.of(first);
            while (iterator.hasNext()) {
                set.add(iterator.next());
            }
            return new ImmutableEnumSet<E>(set);
        }

        public static <E extends Enum<E>> EnumSet<E> newEnumSet(Iterable<E> iterable,
                                                                Class<E> elementType) {

            checkNotNull(iterable);
            EnumSet<E> set = EnumSet.noneOf(elementType);
            Iterables.addAll(set, iterable);
            return set;
        }


        public static <E> HashSet<E> newHashSet() {
            return new HashSet<E>();
        }

        public static <E> HashSet<E> newHashSet(E... elements) {
            int capacity = Maps.capacity(elements.length);
            HashSet<E> set = new HashSet<E>(capacity);
            Collections.addAll(set, elements);
            return set;
        }

        public static <E> HashSet<E> newHashSetWithExpectedSize(int expectedSize) {
            return new HashSet<E>(Maps.capacity(expectedSize));
        }

        public static <E> HashSet<E> newHashSet(Iterable<? extends E> elements) {
            return (elements instanceof Collection)
                    ? new HashSet<E>(Collections2.cast(elements))
                    : newHashSet(elements.iterator());
        }

        public static <E> HashSet<E> newHashSet(Iterator<? extends E> elements) {
            HashSet<E> set = newHashSet();
            while (elements.hasNext()) {
                set.add(elements.next());
            }
            return set;
        }

        public static <E> LinkedHashSet<E> newLinkedHashSet() {
            return new LinkedHashSet<E>();
        }

        public static <E> LinkedHashSet<E> newLinkedHashSet(
                Iterable<? extends E> elements) {
            if (elements instanceof Collection) {
                return new LinkedHashSet<E>(Collections2.cast(elements));
            }
            LinkedHashSet<E> set = newLinkedHashSet();
            for (E element : elements) {
                set.add(element);
            }
            return set;
        }

        @SuppressWarnings("unchecked")  // allow ungenerified Comparable types
        public static <E extends Comparable> TreeSet<E> newTreeSet() {
            return new TreeSet<E>();
        }

        @SuppressWarnings("unchecked")  // allow ungenerified Comparable types
        public static <E extends Comparable> TreeSet<E> newTreeSet(
                Iterable<? extends E> elements) {
            TreeSet<E> set = newTreeSet();
            for (E element : elements) {
                set.add(element);
            }
            return set;
        }

        public static <E> TreeSet<E> newTreeSet(Comparator<? super E> comparator) {
            return new TreeSet<E>(checkNotNull(comparator));
        }

        @Beta
        public static <E> Set<E> newIdentityHashSet() {
            return Sets.newSetFromMap(Maps.<E, Boolean>newIdentityHashMap());
        }

        public static <E extends Enum<E>> EnumSet<E> complementOf(
                Collection<E> collection) {
            if (collection instanceof EnumSet) {
                return EnumSet.complementOf((EnumSet<E>) collection);
            }
            checkArgument(!collection.isEmpty(),
                    "collection is empty; use the other version of this method");
            Class<E> type = collection.iterator().next().getDeclaringClass();
            return makeComplementByHand(collection, type);
        }

        public static <E extends Enum<E>> EnumSet<E> complementOf(
                Collection<E> collection, Class<E> type) {
            checkNotNull(collection);
            return (collection instanceof EnumSet)
                    ? EnumSet.complementOf((EnumSet<E>) collection)
                    : makeComplementByHand(collection, type);
        }

        private static <E extends Enum<E>> EnumSet<E> makeComplementByHand(
                Collection<E> collection, Class<E> type) {
            EnumSet<E> result = EnumSet.allOf(type);
            result.removeAll(collection);
            return result;
        }

        public static <E> Set<E> newSetFromMap(Map<E, Boolean> map) {
            return new SetFromMap<E>(map);
        }

        private static class SetFromMap<E> extends AbstractSet<E>
                implements Set<E>, Serializable {
            private final Map<E, Boolean> m; // The backing map
            private transient Set<E> s; // Its keySet

            SetFromMap(Map<E, Boolean> map) {
                checkArgument(map.isEmpty(), "Map is non-empty");
                m = map;
                s = map.keySet();
            }

            @Override public void clear() {
                m.clear();
            }
            @Override public int size() {
                return m.size();
            }
            @Override public boolean isEmpty() {
                return m.isEmpty();
            }
            @Override public boolean contains(Object o) {
                return m.containsKey(o);
            }
            @Override public boolean remove(Object o) {
                return m.remove(o) != null;
            }
            @Override public boolean add(E e) {
                return m.put(e, Boolean.TRUE) == null;
            }
            @Override public Iterator<E> iterator() {
                return s.iterator();
            }
            @Override public Object[] toArray() {
                return s.toArray();
            }
            @Override public <T> T[] toArray(T[] a) {
                return s.toArray(a);
            }
            @Override public String toString() {
                return s.toString();
            }
            @Override public int hashCode() {
                return s.hashCode();
            }
            @Override public boolean equals(@Nullable Object object) {
                return this == object || this.s.equals(object);
            }
            @Override public boolean containsAll(Collection<?> c) {
                return s.containsAll(c);
            }
            @Override public boolean removeAll(Collection<?> c) {
                return s.removeAll(c);
            }
            @Override public boolean retainAll(Collection<?> c) {
                return s.retainAll(c);
            }

            // addAll is the only inherited implementation
            @GwtIncompatible("not needed in emulated source")
            private static final long serialVersionUID = 0;

            @GwtIncompatible("java.io.ObjectInputStream")
            private void readObject(ObjectInputStream stream)
                    throws IOException, ClassNotFoundException {
                stream.defaultReadObject();
                s = m.keySet();
            }
        }

        public abstract static class SetView<E> extends AbstractSet<E> {
            private SetView() {} // no subclasses but our own

            public ImmutableSet<E> immutableCopy() {
                return ImmutableSet.copyOf(this);
            }


            public <S extends Set<E>> S copyInto(S set) {
                set.addAll(this);
                return set;
            }
        }

        public static <E> SetView<E> union(
                final Set<? extends E> set1, final Set<? extends E> set2) {
            checkNotNull(set1, "set1");
            checkNotNull(set2, "set2");

            final Set<? extends E> set2minus1 = difference(set2, set1);

            return new SetView<E>() {
                @Override public int size() {
                    return set1.size() + set2minus1.size();
                }
                @Override public boolean isEmpty() {
                    return set1.isEmpty() && set2.isEmpty();
                }
                @Override public Iterator<E> iterator() {
                    return Iterators.unmodifiableIterator(
                            Iterators.concat(set1.iterator(), set2minus1.iterator()));
                }
                @Override public boolean contains(Object object) {
                    return set1.contains(object) || set2.contains(object);
                }
                @Override public <S extends Set<E>> S copyInto(S set) {
                    set.addAll(set1);
                    set.addAll(set2);
                    return set;
                }
                @Override public ImmutableSet<E> immutableCopy() {
                    return new ImmutableSet.Builder<E>()
                            .addAll(set1).addAll(set2).build();
                }
            };
        }

        public static <E> SetView<E> intersection(
                final Set<E> set1, final Set<?> set2) {
            checkNotNull(set1, "set1");
            checkNotNull(set2, "set2");

            final Predicate<Object> inSet2 = Predicates.in(set2);
            return new SetView<E>() {
                @Override public Iterator<E> iterator() {
                    return Iterators.filter(set1.iterator(), inSet2);
                }
                @Override public int size() {
                    return Iterators.size(iterator());
                }
                @Override public boolean isEmpty() {
                    return !iterator().hasNext();
                }
                @Override public boolean contains(Object object) {
                    return set1.contains(object) && set2.contains(object);
                }
                @Override public boolean containsAll(Collection<?> collection) {
                    return set1.containsAll(collection)
                            && set2.containsAll(collection);
                }
            };
        }

        public static <E> SetView<E> difference(
                final Set<E> set1, final Set<?> set2) {
            checkNotNull(set1, "set1");
            checkNotNull(set2, "set2");

            final Predicate<Object> notInSet2 = Predicates.not(Predicates.in(set2));
            return new SetView<E>() {
                @Override public Iterator<E> iterator() {
                    return Iterators.filter(set1.iterator(), notInSet2);
                }
                @Override public int size() {
                    return Iterators.size(iterator());
                }
                @Override public boolean isEmpty() {
                    return set2.containsAll(set1);
                }
                @Override public boolean contains(Object element) {
                    return set1.contains(element) && !set2.contains(element);
                }
            };
        }

        @Beta
        public static <E> SetView<E> symmetricDifference(
                Set<? extends E> set1, Set<? extends E> set2) {
            checkNotNull(set1, "set1");
            checkNotNull(set2, "set2");

            // TODO(kevinb): Replace this with a more efficient implementation
            return difference(union(set1, set2), intersection(set1, set2));
        }

        public static <E> Set<E> filter(
                Set<E> unfiltered, Predicate<? super E> predicate) {
            if (unfiltered instanceof FilteredSet) {
                // Support clear(), removeAll(), and retainAll() when filtering a filtered
                // collection.
                FilteredSet<E> filtered = (FilteredSet<E>) unfiltered;
                Predicate<E> combinedPredicate
                        = Predicates.<E>and(filtered.predicate, predicate);
                return new FilteredSet<E>(
                        (Set<E>) filtered.unfiltered, combinedPredicate);
            }

            return new FilteredSet<E>(
                    checkNotNull(unfiltered), checkNotNull(predicate));
        }

        private static class FilteredSet<E> extends Collections2.FilteredCollection<E>
                implements Set<E> {
            FilteredSet(Set<E> unfiltered, Predicate<? super E> predicate) {
                super(unfiltered, predicate);
            }

            @Override public boolean equals(@Nullable Object object) {
                return equalsImpl(this, object);
            }

            @Override public int hashCode() {
                return hashCodeImpl(this);
            }
        }

        public static <B> Set<List<B>> cartesianProduct(
                List<? extends Set<? extends B>> sets) {
            CartesianSet<B> cartesianSet = new CartesianSet<B>(sets);
            return cartesianSet.isEmpty() ? ImmutableSet.<List<B>>of() : cartesianSet;
        }

        public static <B> Set<List<B>> cartesianProduct(
                Set<? extends B>... sets) {
            return cartesianProduct(Arrays.asList(sets));
        }

        private static class CartesianSet<B> extends AbstractSet<List<B>> {
            final ImmutableList<Axis> axes;
            final int size;

            CartesianSet(List<? extends Set<? extends B>> sets) {
                long dividend = 1;
                ImmutableList.Builder<Axis> builder = ImmutableList.builder();
                for (Set<? extends B> set : sets) {
                    Axis axis = new Axis(set, (int) dividend); // check overflow at end
                    builder.add(axis);
                    dividend *= axis.size();
                }
                this.axes = builder.build();
                size = Ints.checkedCast(dividend);
            }

            @Override public int size() {
                return size;
            }

            @Override public UnmodifiableIterator<List<B>> iterator() {
                return new UnmodifiableIterator<List<B>>() {
                    int index;

                    public boolean hasNext() {
                        return index < size;
                    }

                    public List<B> next() {
                        if (!hasNext()) {
                            throw new NoSuchElementException();
                        }

                        Object[] tuple = new Object[axes.size()];
                        for (int i = 0 ; i < tuple.length; i++) {
                            tuple[i] = axes.get(i).getForIndex(index);
                        }
                        index++;

                        @SuppressWarnings("unchecked") // only B's are put in here
                                List<B> result = (ImmutableList<B>) ImmutableList.copyOf(tuple);
                        return result;
                    }
                };
            }

            @Override public boolean contains(Object element) {
                if (!(element instanceof List<?>)) {
                    return false;
                }
                List<?> tuple = (List<?>) element;
                int dimensions = axes.size();
                if (tuple.size() != dimensions) {
                    return false;
                }
                for (int i = 0; i < dimensions; i++) {
                    if (!axes.get(i).contains(tuple.get(i))) {
                        return false;
                    }
                }
                return true;
            }

            @Override public boolean equals(@Nullable Object object) {
                // Warning: this is broken if size() == 0, so it is critical that we
                // substitute an empty ImmutableSet to the user in place of this
                if (object instanceof CartesianSet) {
                    CartesianSet<?> that = (CartesianSet<?>) object;
                    return this.axes.equals(that.axes);
                }
                return super.equals(object);
            }

            @Override public int hashCode() {
                // Warning: this is broken if size() == 0, so it is critical that we
                // substitute an empty ImmutableSet to the user in place of this

                // It's a weird formula, but tests prove it works.
                int adjust = size - 1;
                for (int i = 0; i < axes.size(); i++) {
                    adjust *= 31;
                }
                return axes.hashCode() + adjust;
            }

            private class Axis {
                final ImmutableSet<? extends B> choices;
                final ImmutableList<? extends B> choicesList;
                final int dividend;

                Axis(Set<? extends B> set, int dividend) {
                    choices = ImmutableSet.copyOf(set);
                    choicesList = choices.asList();
                    this.dividend = dividend;
                }

                int size() {
                    return choices.size();
                }

                B getForIndex(int index) {
                    return choicesList.get(index / dividend % size());
                }

                boolean contains(Object target) {
                    return choices.contains(target);
                }

                @SuppressWarnings("unchecked") // javac rejects "CartesianSet<?>.Axis"
                @Override public boolean equals(Object obj) {
                    if (obj instanceof CartesianSet.Axis) {
                        CartesianSet.Axis that = (CartesianSet.Axis) obj;
                        return this.choices.equals(that.choices);
                        // dividends must be equal or we wouldn't have gotten this far
                    }
                    return false;
                }

                @Override public int hashCode() {
                    // Because Axis instances are not exposed, we can
                    // opportunistically choose whatever bizarre formula happens
                    // to make CartesianSet.hashCode() as simple as possible.
                    return size / choices.size() * choices.hashCode();
                }
            }
        }

        @GwtCompatible(serializable = false)
        public static <E> Set<Set<E>> powerSet(Set<E> set) {
            ImmutableSet<E> input = ImmutableSet.copyOf(set);
            checkArgument(input.size() <= 30,
                    "Too many elements to create power set: %s > 30", input.size());
            return new PowerSet<E>(input);
        }

        private static final class PowerSet<E> extends AbstractSet<Set<E>> {
            final ImmutableSet<E> inputSet;
            final ImmutableList<E> inputList;
            final int powerSetSize;

            PowerSet(ImmutableSet<E> input) {
                this.inputSet = input;
                this.inputList = input.asList();
                this.powerSetSize = 1 << input.size();
            }

            @Override public int size() {
                return powerSetSize;
            }

            @Override public boolean isEmpty() {
                return false;
            }

            @Override public Iterator<Set<E>> iterator() {
                return new AbstractIndexedListIterator<Set<E>>(powerSetSize) {
                    @Override protected Set<E> get(final int setBits) {
                        return new AbstractSet<E>() {
                            @Override public int size() {
                                return Integer.bitCount(setBits);
                            }
                            @Override public Iterator<E> iterator() {
                                return new BitFilteredSetIterator<E>(inputList, setBits);
                            }
                        };
                    }
                };
            }

            private static final class BitFilteredSetIterator<E>
                    extends UnmodifiableIterator<E> {
                final ImmutableList<E> input;
                int remainingSetBits;

                BitFilteredSetIterator(ImmutableList<E> input, int allSetBits) {
                    this.input = input;
                    this.remainingSetBits = allSetBits;
                }

                @Override public boolean hasNext() {
                    return remainingSetBits != 0;
                }

                @Override public E next() {
                    int index = Integer.numberOfTrailingZeros(remainingSetBits);
                    if (index == 32) {
                        throw new NoSuchElementException();
                    }

                    int currentElementMask = 1 << index;
                    remainingSetBits &= ~currentElementMask;
                    return input.get(index);
                }
            }

            @Override public boolean contains(@Nullable Object obj) {
                if (obj instanceof Set) {
                    Set<?> set = (Set<?>) obj;
                    return inputSet.containsAll(set);
                }
                return false;
            }

            @Override public boolean equals(@Nullable Object obj) {
                if (obj instanceof PowerSet) {
                    PowerSet<?> that = (PowerSet<?>) obj;
                    return inputSet.equals(that.inputSet);
                }
                return super.equals(obj);
            }

            @Override public int hashCode() {

                return inputSet.hashCode() << (inputSet.size() - 1);
            }

            @Override public String toString() {
                return "powerSet(" + inputSet + ")";
            }
        }


        static int hashCodeImpl(Set<?> s) {
            int hashCode = 0;
            for (Object o : s) {
                hashCode += o != null ? o.hashCode() : 0;
            }
            return hashCode;
        }


        static boolean equalsImpl(Set<?> s, @Nullable Object object){
            if (s == object) {
                return true;
            }
            if (object instanceof Set) {
                Set<?> o = (Set<?>) object;

                try {
                    return s.size() == o.size() && s.containsAll(o);
                } catch (NullPointerException ignored) {
                    return false;
                } catch (ClassCastException ignored) {
                    return false;
                }
            }
            return false;
        }
    }
    static abstract class AbstractMultiset<E> extends AbstractCollection<E>
            implements Multiset<E> {
        public abstract Set<Entry<E>> entrySet();

        // Query Operations

        @Override public int size() {
            return Multisets.sizeImpl(this);
        }

        @Override public boolean isEmpty() {
            return entrySet().isEmpty();
        }

        @Override public boolean contains(@Nullable Object element) {
            return count(element) > 0;
        }

        @Override public Iterator<E> iterator() {
            return Multisets.iteratorImpl(this);
        }

        public int count(Object element) {
            for (Entry<E> entry : entrySet()) {
                if (Objects.equal(entry.getElement(), element)) {
                    return entry.getCount();
                }
            }
            return 0;
        }

        // Modification Operations

        @Override public boolean add(@Nullable E element) {
            add(element, 1);
            return true;
        }

        public int add(E element, int occurrences) {
            throw new UnsupportedOperationException();
        }

        @Override public boolean remove(Object element) {
            return remove(element, 1) > 0;
        }

        public int remove(Object element, int occurrences) {
            throw new UnsupportedOperationException();
        }

        public int setCount(E element, int count) {
            return setCountImpl(this, element, count);
        }

        public boolean setCount(E element, int oldCount, int newCount) {
            return setCountImpl(this, element, oldCount, newCount);
        }

        // Bulk Operations

        @Override public boolean addAll(Collection<? extends E> elementsToAdd) {
            return Multisets.addAllImpl(this, elementsToAdd);
        }

        @Override public boolean removeAll(Collection<?> elementsToRemove) {
            return Multisets.removeAllImpl(this, elementsToRemove);
        }

        @Override public boolean retainAll(Collection<?> elementsToRetain) {
            return Multisets.retainAllImpl(this, elementsToRetain);
        }

        @Override public void clear() {
            entrySet().clear();
        }

        // Views

        private transient Set<E> elementSet;

        public Set<E> elementSet() {
            Set<E> result = elementSet;
            if (result == null) {
                elementSet = result = createElementSet();
            }
            return result;
        }


        Set<E> createElementSet() {
            return Multisets.elementSetImpl(this);
        }

        @Override public boolean equals(@Nullable Object object) {
            return Multisets.equalsImpl(this, object);
        }


        @Override public int hashCode() {
            return entrySet().hashCode();
        }


        @Override public String toString() {
            return entrySet().toString();
        }
    }
    public interface Multiset<E> extends Collection<E> {

        int count(@Nullable Object element);

        int add(@Nullable E element, int occurrences);

        int remove(@Nullable Object element, int occurrences);


        int setCount(E element, int count);

        boolean setCount(E element, int oldCount, int newCount);

        Set<E> elementSet();


        Set<Entry<E>> entrySet();

        interface Entry<E> {

            E getElement();

            int getCount();


            boolean equals(Object o);

            int hashCode();

            String toString();
        }

        boolean equals(@Nullable Object object);

        int hashCode();

        String toString();


        Iterator<E> iterator();


        boolean contains(@Nullable Object element);

        boolean containsAll(Collection<?> elements);

        boolean add(E element);

        boolean remove(@Nullable Object element);

        boolean removeAll(Collection<?> c);

        boolean retainAll(Collection<?> c);
    }



    public static final class Multisets {
        private Multisets() {}

        public static <E> Multiset<E> unmodifiableMultiset(
                Multiset<? extends E> multiset) {
            return new UnmodifiableMultiset<E>(checkNotNull(multiset));
        }

        private static class UnmodifiableMultiset<E>
                extends ForwardingMultiset<E> implements Serializable {
            final Multiset<? extends E> delegate;

            UnmodifiableMultiset(Multiset<? extends E> delegate) {
                this.delegate = delegate;
            }

            @SuppressWarnings("unchecked")
            @Override protected Multiset<E> delegate() {
                // This is safe because all non-covariant methods are overriden
                return (Multiset) delegate;
            }

            transient Set<E> elementSet;

            @Override public Set<E> elementSet() {
                Set<E> es = elementSet;
                return (es == null)
                        ? elementSet = Collections.<E>unmodifiableSet(delegate.elementSet())
                        : es;
            }

            transient Set<Multiset.Entry<E>> entrySet;

            @SuppressWarnings("unchecked")
            @Override public Set<Multiset.Entry<E>> entrySet() {
                Set<Multiset.Entry<E>> es = entrySet;
                return (es == null)
                        // Safe because the returned set is made unmodifiable and Entry
                        // itself is readonly
                        ? entrySet = (Set) Collections.unmodifiableSet(delegate.entrySet())
                        : es;
            }

            @SuppressWarnings("unchecked")
            @Override public Iterator<E> iterator() {
                // Safe because the returned Iterator is made unmodifiable
                return (Iterator) Iterators.unmodifiableIterator(delegate.iterator());
            }

            @Override public boolean add(E element) {
                throw new UnsupportedOperationException();
            }

            @Override public int add(E element, int occurences) {
                throw new UnsupportedOperationException();
            }

            @Override public boolean addAll(Collection<? extends E> elementsToAdd) {
                throw new UnsupportedOperationException();
            }

            @Override public boolean remove(Object element) {
                throw new UnsupportedOperationException();
            }

            @Override public int remove(Object element, int occurrences) {
                throw new UnsupportedOperationException();
            }

            @Override public boolean removeAll(Collection<?> elementsToRemove) {
                throw new UnsupportedOperationException();
            }

            @Override public boolean retainAll(Collection<?> elementsToRetain) {
                throw new UnsupportedOperationException();
            }

            @Override public void clear() {
                throw new UnsupportedOperationException();
            }

            @Override public int setCount(E element, int count) {
                throw new UnsupportedOperationException();
            }

            @Override public boolean setCount(E element, int oldCount, int newCount) {
                throw new UnsupportedOperationException();
            }

            private static final long serialVersionUID = 0;
        }

        public static <E> Multiset.Entry<E> immutableEntry(
                @Nullable final E e, final int n) {
            checkArgument(n >= 0);
            return new AbstractEntry<E>() {
                public E getElement() {
                    return e;
                }
                public int getCount() {
                    return n;
                }
            };
        }

        static <E> Multiset<E> forSet(Set<E> set) {
            return new SetMultiset<E>(set);
        }


        private static class SetMultiset<E> extends ForwardingCollection<E>
                implements Multiset<E>, Serializable {
            final Set<E> delegate;

            SetMultiset(Set<E> set) {
                delegate = checkNotNull(set);
            }

            @Override protected Set<E> delegate() {
                return delegate;
            }

            public int count(Object element) {
                return delegate.contains(element) ? 1 : 0;
            }

            public int add(E element, int occurrences) {
                throw new UnsupportedOperationException();
            }

            public int remove(Object element, int occurrences) {
                if (occurrences == 0) {
                    return count(element);
                }
                checkArgument(occurrences > 0);
                return delegate.remove(element) ? 1 : 0;
            }

            transient Set<E> elementSet;

            public Set<E> elementSet() {
                Set<E> es = elementSet;
                return (es == null) ? elementSet = new ElementSet() : es;
            }

            transient Set<Entry<E>> entrySet;

            public Set<Entry<E>> entrySet() {
                Set<Entry<E>> es = entrySet;
                return (es == null) ? entrySet = new EntrySet() : es;
            }

            @Override public boolean add(E o) {
                throw new UnsupportedOperationException();
            }

            @Override public boolean addAll(Collection<? extends E> c) {
                throw new UnsupportedOperationException();
            }

            public int setCount(E element, int count) {
                checkNonnegative(count, "count");

                if (count == count(element)) {
                    return count;
                } else if (count == 0) {
                    remove(element);
                    return 1;
                } else {
                    throw new UnsupportedOperationException();
                }
            }

            public boolean setCount(E element, int oldCount, int newCount) {
                return setCountImpl(this, element, oldCount, newCount);
            }

            @Override public boolean equals(@Nullable Object object) {
                if (object instanceof Multiset) {
                    Multiset<?> that = (Multiset<?>) object;
                    return this.size() == that.size() && delegate.equals(that.elementSet());
                }
                return false;
            }

            @Override public int hashCode() {
                int sum = 0;
                for (E e : this) {
                    sum += ((e == null) ? 0 : e.hashCode()) ^ 1;
                }
                return sum;
            }


            class ElementSet extends ForwardingSet<E> {
                @Override protected Set<E> delegate() {
                    return delegate;
                }

                @Override public boolean add(E o) {
                    throw new UnsupportedOperationException();
                }

                @Override public boolean addAll(Collection<? extends E> c) {
                    throw new UnsupportedOperationException();
                }
            }


            class EntrySet extends AbstractSet<Entry<E>> {
                @Override public int size() {
                    return delegate.size();
                }
                @Override public Iterator<Entry<E>> iterator() {
                    return new Iterator<Entry<E>>() {
                        final Iterator<E> elements = delegate.iterator();

                        public boolean hasNext() {
                            return elements.hasNext();
                        }
                        public Entry<E> next() {
                            return immutableEntry(elements.next(), 1);
                        }
                        public void remove() {
                            elements.remove();
                        }
                    };
                }
                // TODO(kevinb): faster contains, remove
            }

            private static final long serialVersionUID = 0;
        }

        static int inferDistinctElements(Iterable<?> elements) {
            if (elements instanceof Multiset) {
                return ((Multiset<?>) elements).elementSet().size();
            }
            return 11; // initial capacity will be rounded up to 16
        }

        public static <E> Multiset<E> intersection(
                final Multiset<E> multiset1, final Multiset<?> multiset2) {
            checkNotNull(multiset1);
            checkNotNull(multiset2);

            return new AbstractMultiset<E>() {
                @Override public int count(Object element) {
                    int count1 = multiset1.count(element);
                    return (count1 == 0) ? 0 : Math.min(count1, multiset2.count(element));
                }

                @Override Set<E> createElementSet() {
                    return Sets.intersection(
                            multiset1.elementSet(), multiset2.elementSet());
                }

                @Override public Set<Entry<E>> entrySet() {
                    return entrySet;
                }

                final Set<Entry<E>> entrySet = new AbstractSet<Entry<E>>() {
                    @Override public Iterator<Entry<E>> iterator() {
                        final Iterator<Entry<E>> iterator1 = multiset1.entrySet().iterator();
                        return new AbstractIterator<Entry<E>>() {
                            @Override protected Entry<E> computeNext() {
                                while (iterator1.hasNext()) {
                                    Entry<E> entry1 = iterator1.next();
                                    E element = entry1.getElement();
                                    int count
                                            = Math.min(entry1.getCount(), multiset2.count(element));
                                    if (count > 0) {
                                        return Multisets.immutableEntry(element, count);
                                    }
                                }
                                return endOfData();
                            }
                        };
                    }

                    @Override public int size() {
                        return elementSet().size();
                    }

                    @Override public boolean contains(Object o) {
                        if (o instanceof Entry) {
                            Entry<?> entry = (Entry<?>) o;
                            int entryCount = entry.getCount();
                            return (entryCount > 0)
                                    && (count(entry.getElement()) == entryCount);
                        }
                        return false;
                    }

                    @Override public boolean isEmpty() {
                        return elementSet().isEmpty();
                    }
                };
            };
        }

        abstract static class AbstractEntry<E> implements Multiset.Entry<E> {

            @Override public boolean equals(@Nullable Object object) {
                if (object instanceof Multiset.Entry) {
                    Multiset.Entry<?> that = (Multiset.Entry<?>) object;
                    return this.getCount() == that.getCount()
                            && Objects.equal(this.getElement(), that.getElement());
                }
                return false;
            }

            @Override public int hashCode() {
                E e = getElement();
                return ((e == null) ? 0 : e.hashCode()) ^ getCount();
            }


            @Override public String toString() {
                String text = String.valueOf(getElement());
                int n = getCount();
                return (n == 1) ? text : (text + " x " + n);
            }
        }

        static boolean equalsImpl(Multiset<?> multiset, @Nullable Object object) {
            if (object == multiset) {
                return true;
            }
            if (object instanceof Multiset) {
                Multiset<?> that = (Multiset<?>) object;


                if (multiset.size() != that.size()
                        || multiset.entrySet().size() != that.entrySet().size()) {
                    return false;
                }
                for (Multiset.Entry<?> entry : that.entrySet()) {
                    if (multiset.count(entry.getElement()) != entry.getCount()) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        static <E> boolean addAllImpl(
                Multiset<E> self, Collection<? extends E> elements) {
            if (elements.isEmpty()) {
                return false;
            }
            if (elements instanceof Multiset) {
                Multiset<? extends E> that = cast(elements);
                for (Multiset.Entry<? extends E> entry : that.entrySet()) {
                    self.add(entry.getElement(), entry.getCount());
                }
            } else {
                Iterators.addAll(self, elements.iterator());
            }
            return true;
        }

        static boolean removeAllImpl(
                Multiset<?> self, Collection<?> elementsToRemove) {
            Collection<?> collection = (elementsToRemove instanceof Multiset)
                    ? ((Multiset<?>) elementsToRemove).elementSet() : elementsToRemove;

            return self.elementSet().removeAll(collection);
        }


        static boolean retainAllImpl(
                Multiset<?> self, Collection<?> elementsToRetain) {
            Collection<?> collection = (elementsToRetain instanceof Multiset)
                    ? ((Multiset<?>) elementsToRetain).elementSet() : elementsToRetain;

            return self.elementSet().retainAll(collection);
        }

        static <E> int setCountImpl(Multiset<E> self, E element, int count) {
            checkNonnegative(count, "count");

            int oldCount = self.count(element);

            int delta = count - oldCount;
            if (delta > 0) {
                self.add(element, delta);
            } else if (delta < 0) {
                self.remove(element, -delta);
            }

            return oldCount;
        }


        static <E> boolean setCountImpl(
                Multiset<E> self, E element, int oldCount, int newCount) {
            checkNonnegative(oldCount, "oldCount");
            checkNonnegative(newCount, "newCount");

            if (self.count(element) == oldCount) {
                self.setCount(element, newCount);
                return true;
            } else {
                return false;
            }
        }


        static <E> Set<E> elementSetImpl(Multiset<E> self){
            return new ElementSetImpl<E>(self);
        }

        private static final class ElementSetImpl<E> extends AbstractSet<E>
                implements Serializable {
            private final Multiset<E> multiset;

            ElementSetImpl(Multiset<E> multiset) {
                this.multiset = multiset;
            }

            @Override public boolean add(E e) {
                throw new UnsupportedOperationException();
            }

            @Override public boolean addAll(Collection<? extends E> c) {
                throw new UnsupportedOperationException();
            }

            @Override public void clear() {
                multiset.clear();
            }

            @Override public boolean contains(Object o) {
                return multiset.contains(o);
            }

            @Override public boolean containsAll(Collection<?> c) {
                return multiset.containsAll(c);
            }

            @Override public boolean isEmpty() {
                return multiset.isEmpty();
            }

            @Override public Iterator<E> iterator() {
                final Iterator<Multiset.Entry<E>> entryIterator = multiset.entrySet().iterator();
                return new Iterator<E>() {

                    @Override public boolean hasNext() {
                        return entryIterator.hasNext();
                    }

                    @Override public E next() {
                        return entryIterator.next().getElement();
                    }

                    @Override public void remove() {
                        entryIterator.remove();
                    }
                };
            }

            @Override public boolean remove(Object o) {
                int count = multiset.count(o);
                if (count > 0) {
                    multiset.remove(o, count);
                    return true;
                }
                return false;
            }

            @Override public int size() {
                return multiset.entrySet().size();
            }

            private static final long serialVersionUID = 0;
        }


        static <E> Iterator<E> iteratorImpl(Multiset<E> multiset) {
            return new MultisetIteratorImpl<E>(
                    multiset, multiset.entrySet().iterator());
        }

        static final class MultisetIteratorImpl<E> implements Iterator<E> {
            private final Multiset<E> multiset;
            private final Iterator<Multiset.Entry<E>> entryIterator;
            private Multiset.Entry<E> currentEntry;

            private int laterCount;

            private int totalCount;
            private boolean canRemove;

            MultisetIteratorImpl(
                    Multiset<E> multiset, Iterator<Multiset.Entry<E>> entryIterator) {
                this.multiset = multiset;
                this.entryIterator = entryIterator;
            }

            public boolean hasNext() {
                return laterCount > 0 || entryIterator.hasNext();
            }

            public E next() {
                if (!hasNext()) {
                    throw new NoSuchElementException();
                }
                if (laterCount == 0) {
                    currentEntry = entryIterator.next();
                    totalCount = laterCount = currentEntry.getCount();
                }
                laterCount--;
                canRemove = true;
                return currentEntry.getElement();
            }

            public void remove() {
                checkState(
                        canRemove, "no calls to next() since the last call to remove()");
                if (totalCount == 1) {
                    entryIterator.remove();
                } else {
                    multiset.remove(currentEntry.getElement());
                }
                totalCount--;
                canRemove = false;
            }
        }


        static int sizeImpl(Multiset<?> multiset) {
            long size = 0;
            for (Multiset.Entry<?> entry : multiset.entrySet()) {
                size += entry.getCount();
            }
            return Ints.saturatedCast(size);
        }

        static void checkNonnegative(int count, String name) {
            checkArgument(count >= 0, "%s cannot be negative: %s", name, count);
        }


        static <T> Multiset<T> cast(Iterable<T> iterable) {
            return (Multiset<T>) iterable;
        }
    }
    public interface Multimap<K, V> {
        // Query Operations


        int size();

        boolean isEmpty();


        boolean containsKey(@Nullable Object key);


        boolean containsValue(@Nullable Object value);


        boolean containsEntry(@Nullable Object key, @Nullable Object value);

        boolean put(@Nullable K key, @Nullable V value);

        boolean remove(@Nullable Object key, @Nullable Object value);

        boolean putAll(@Nullable K key, Iterable<? extends V> values);

        boolean putAll(Multimap<? extends K, ? extends V> multimap);

        Collection<V> replaceValues(@Nullable K key, Iterable<? extends V> values);

        Collection<V> removeAll(@Nullable Object key);

        void clear();

        Collection<V> get(@Nullable K key);

        Set<K> keySet();

        Multiset<K> keys();

        Collection<V> values();

        Collection<Map.Entry<K, V>> entries();

        Map<K, Collection<V>> asMap();

        boolean equals(@Nullable Object obj);

        int hashCode();
    }
    static abstract class AbstractMultimap<K, V> implements Multimap<K, V>, Serializable {

        private transient Map<K, Collection<V>> map;
        private transient int totalSize;

        protected AbstractMultimap(Map<K, Collection<V>> map) {
            checkArgument(map.isEmpty());
            this.map = map;
        }


        final void setMap(Map<K, Collection<V>> map) {
            this.map = map;
            totalSize = 0;
            for (Collection<V> values : map.values()) {
                checkArgument(!values.isEmpty());
                totalSize += values.size();
            }
        }

        abstract Collection<V> createCollection();


        Collection<V> createCollection(@Nullable K key) {
            return createCollection();
        }

        Map<K, Collection<V>> backingMap() {
            return map;
        }

        public int size() {
            return totalSize;
        }

        public boolean isEmpty() {
            return totalSize == 0;
        }

        public boolean containsKey(@Nullable Object key) {
            return map.containsKey(key);
        }

        public boolean containsValue(@Nullable Object value) {
            for (Collection<V> collection : map.values()) {
                if (collection.contains(value)) {
                    return true;
                }
            }

            return false;
        }

        public boolean containsEntry(@Nullable Object key, @Nullable Object value) {
            Collection<V> collection = map.get(key);
            return collection != null && collection.contains(value);
        }

        // Modification Operations

        public boolean put(@Nullable K key, @Nullable V value) {
            Collection<V> collection = getOrCreateCollection(key);

            if (collection.add(value)) {
                totalSize++;
                return true;
            } else {
                return false;
            }
        }

        private Collection<V> getOrCreateCollection(@Nullable K key) {
            Collection<V> collection = map.get(key);
            if (collection == null) {
                collection = createCollection(key);
                map.put(key, collection);
            }
            return collection;
        }

        public boolean remove(@Nullable Object key, @Nullable Object value) {
            Collection<V> collection = map.get(key);
            if (collection == null) {
                return false;
            }

            boolean changed = collection.remove(value);
            if (changed) {
                totalSize--;
                if (collection.isEmpty()) {
                    map.remove(key);
                }
            }
            return changed;
        }

        // Bulk Operations

        public boolean putAll(@Nullable K key, Iterable<? extends V> values) {
            if (!values.iterator().hasNext()) {
                return false;
            }
            Collection<V> collection = getOrCreateCollection(key);
            int oldSize = collection.size();

            boolean changed = false;
            if (values instanceof Collection) {
                Collection<? extends V> c = Collections2.cast(values);
                changed = collection.addAll(c);
            } else {
                for (V value : values) {
                    changed |= collection.add(value);
                }
            }

            totalSize += (collection.size() - oldSize);
            return changed;
        }

        public boolean putAll(Multimap<? extends K, ? extends V> multimap) {
            boolean changed = false;
            for (Map.Entry<? extends K, ? extends V> entry : multimap.entries()) {
                changed |= put(entry.getKey(), entry.getValue());
            }
            return changed;
        }

        public Collection<V> replaceValues(
                @Nullable K key, Iterable<? extends V> values) {
            Iterator<? extends V> iterator = values.iterator();
            if (!iterator.hasNext()) {
                return removeAll(key);
            }

            Collection<V> collection = getOrCreateCollection(key);
            Collection<V> oldValues = createCollection();
            oldValues.addAll(collection);

            totalSize -= collection.size();
            collection.clear();

            while (iterator.hasNext()) {
                if (collection.add(iterator.next())) {
                    totalSize++;
                }
            }

            return unmodifiableCollectionSubclass(oldValues);
        }


        public Collection<V> removeAll(@Nullable Object key) {
            Collection<V> collection = map.remove(key);
            Collection<V> output = createCollection();

            if (collection != null) {
                output.addAll(collection);
                totalSize -= collection.size();
                collection.clear();
            }

            return unmodifiableCollectionSubclass(output);
        }

        private Collection<V> unmodifiableCollectionSubclass(
                Collection<V> collection) {
            if (collection instanceof SortedSet) {
                return Collections.unmodifiableSortedSet((SortedSet<V>) collection);
            } else if (collection instanceof Set) {
                return Collections.unmodifiableSet((Set<V>) collection);
            } else if (collection instanceof List) {
                return Collections.unmodifiableList((List<V>) collection);
            } else {
                return Collections.unmodifiableCollection(collection);
            }
        }

        public void clear() {
            // Clear each collection, to make previously returned collections empty.
            for (Collection<V> collection : map.values()) {
                collection.clear();
            }
            map.clear();
            totalSize = 0;
        }


        public Collection<V> get(@Nullable K key) {
            Collection<V> collection = map.get(key);
            if (collection == null) {
                collection = createCollection(key);
            }
            return wrapCollection(key, collection);
        }

        private Collection<V> wrapCollection(
                @Nullable K key, Collection<V> collection) {
            if (collection instanceof SortedSet) {
                return new WrappedSortedSet(key, (SortedSet<V>) collection, null);
            } else if (collection instanceof Set) {
                return new WrappedSet(key, (Set<V>) collection);
            } else if (collection instanceof List) {
                return wrapList(key, (List<V>) collection, null);
            } else {
                return new WrappedCollection(key, collection, null);
            }
        }

        private List<V> wrapList(
                @Nullable K key, List<V> list, @Nullable WrappedCollection ancestor) {
            return (list instanceof RandomAccess)
                    ? new RandomAccessWrappedList(key, list, ancestor)
                    : new WrappedList(key, list, ancestor);
        }

        private class WrappedCollection extends AbstractCollection<V> {
            final K key;
            Collection<V> delegate;
            final WrappedCollection ancestor;
            final Collection<V> ancestorDelegate;

            WrappedCollection(@Nullable K key, Collection<V> delegate,
                              @Nullable WrappedCollection ancestor) {
                this.key = key;
                this.delegate = delegate;
                this.ancestor = ancestor;
                this.ancestorDelegate
                        = (ancestor == null) ? null : ancestor.getDelegate();
            }

            void refreshIfEmpty() {
                if (ancestor != null) {
                    ancestor.refreshIfEmpty();
                    if (ancestor.getDelegate() != ancestorDelegate) {
                        throw new ConcurrentModificationException();
                    }
                } else if (delegate.isEmpty()) {
                    Collection<V> newDelegate = map.get(key);
                    if (newDelegate != null) {
                        delegate = newDelegate;
                    }
                }
            }


            void removeIfEmpty() {
                if (ancestor != null) {
                    ancestor.removeIfEmpty();
                } else if (delegate.isEmpty()) {
                    map.remove(key);
                }
            }

            K getKey() {
                return key;
            }


            void addToMap() {
                if (ancestor != null) {
                    ancestor.addToMap();
                } else {
                    map.put(key, delegate);
                }
            }

            @Override public int size() {
                refreshIfEmpty();
                return delegate.size();
            }

            @Override public boolean equals(@Nullable Object object) {
                if (object == this) {
                    return true;
                }
                refreshIfEmpty();
                return delegate.equals(object);
            }

            @Override public int hashCode() {
                refreshIfEmpty();
                return delegate.hashCode();
            }

            @Override public String toString() {
                refreshIfEmpty();
                return delegate.toString();
            }

            Collection<V> getDelegate() {
                return delegate;
            }

            @Override public Iterator<V> iterator() {
                refreshIfEmpty();
                return new WrappedIterator();
            }


            class WrappedIterator implements Iterator<V> {
                final Iterator<V> delegateIterator;
                final Collection<V> originalDelegate = delegate;

                WrappedIterator() {
                    delegateIterator = iteratorOrListIterator(delegate);
                }

                WrappedIterator(Iterator<V> delegateIterator) {
                    this.delegateIterator = delegateIterator;
                }


                void validateIterator() {
                    refreshIfEmpty();
                    if (delegate != originalDelegate) {
                        throw new ConcurrentModificationException();
                    }
                }

                public boolean hasNext() {
                    validateIterator();
                    return delegateIterator.hasNext();
                }

                public V next() {
                    validateIterator();
                    return delegateIterator.next();
                }

                public void remove() {
                    delegateIterator.remove();
                    totalSize--;
                    removeIfEmpty();
                }

                Iterator<V> getDelegateIterator() {
                    validateIterator();
                    return delegateIterator;
                }
            }

            @Override public boolean add(V value) {
                refreshIfEmpty();
                boolean wasEmpty = delegate.isEmpty();
                boolean changed = delegate.add(value);
                if (changed) {
                    totalSize++;
                    if (wasEmpty) {
                        addToMap();
                    }
                }
                return changed;
            }

            WrappedCollection getAncestor() {
                return ancestor;
            }

            @Override public boolean addAll(Collection<? extends V> collection) {
                if (collection.isEmpty()) {
                    return false;
                }
                int oldSize = size();  // calls refreshIfEmpty
                boolean changed = delegate.addAll(collection);
                if (changed) {
                    int newSize = delegate.size();
                    totalSize += (newSize - oldSize);
                    if (oldSize == 0) {
                        addToMap();
                    }
                }
                return changed;
            }

            @Override public boolean contains(Object o) {
                refreshIfEmpty();
                return delegate.contains(o);
            }

            @Override public boolean containsAll(Collection<?> c) {
                refreshIfEmpty();
                return delegate.containsAll(c);
            }

            @Override public void clear() {
                int oldSize = size();  // calls refreshIfEmpty
                if (oldSize == 0) {
                    return;
                }
                delegate.clear();
                totalSize -= oldSize;
                removeIfEmpty();       // maybe shouldn't be removed if this is a sublist
            }

            @Override public boolean remove(Object o) {
                refreshIfEmpty();
                boolean changed = delegate.remove(o);
                if (changed) {
                    totalSize--;
                    removeIfEmpty();
                }
                return changed;
            }

            @Override public boolean removeAll(Collection<?> c) {
                if (c.isEmpty()) {
                    return false;
                }
                int oldSize = size();  // calls refreshIfEmpty
                boolean changed = delegate.removeAll(c);
                if (changed) {
                    int newSize = delegate.size();
                    totalSize += (newSize - oldSize);
                    removeIfEmpty();
                }
                return changed;
            }

            @Override public boolean retainAll(Collection<?> c) {
                checkNotNull(c);
                int oldSize = size();  // calls refreshIfEmpty
                boolean changed = delegate.retainAll(c);
                if (changed) {
                    int newSize = delegate.size();
                    totalSize += (newSize - oldSize);
                    removeIfEmpty();
                }
                return changed;
            }
        }

        private Iterator<V> iteratorOrListIterator(Collection<V> collection) {
            return (collection instanceof List)
                    ? ((List<V>) collection).listIterator()
                    : collection.iterator();
        }


        private class WrappedSet extends WrappedCollection implements Set<V> {
            WrappedSet(@Nullable K key, Set<V> delegate) {
                super(key, delegate, null);
            }
        }


        private class WrappedSortedSet extends WrappedCollection
                implements SortedSet<V> {
            WrappedSortedSet(@Nullable K key, SortedSet<V> delegate,
                             @Nullable WrappedCollection ancestor) {
                super(key, delegate, ancestor);
            }

            SortedSet<V> getSortedSetDelegate() {
                return (SortedSet<V>) getDelegate();
            }

            public Comparator<? super V> comparator() {
                return getSortedSetDelegate().comparator();
            }

            public V first() {
                refreshIfEmpty();
                return getSortedSetDelegate().first();
            }

            public V last() {
                refreshIfEmpty();
                return getSortedSetDelegate().last();
            }

            public SortedSet<V> headSet(V toElement) {
                refreshIfEmpty();
                return new WrappedSortedSet(
                        getKey(), getSortedSetDelegate().headSet(toElement),
                        (getAncestor() == null) ? this : getAncestor());
            }

            public SortedSet<V> subSet(V fromElement, V toElement) {
                refreshIfEmpty();
                return new WrappedSortedSet(
                        getKey(), getSortedSetDelegate().subSet(fromElement, toElement),
                        (getAncestor() == null) ? this : getAncestor());
            }

            public SortedSet<V> tailSet(V fromElement) {
                refreshIfEmpty();
                return new WrappedSortedSet(
                        getKey(), getSortedSetDelegate().tailSet(fromElement),
                        (getAncestor() == null) ? this : getAncestor());
            }
        }


        private class WrappedList extends WrappedCollection implements List<V> {
            WrappedList(@Nullable K key, List<V> delegate,
                        @Nullable WrappedCollection ancestor) {
                super(key, delegate, ancestor);
            }

            List<V> getListDelegate() {
                return (List<V>) getDelegate();
            }

            public boolean addAll(int index, Collection<? extends V> c) {
                if (c.isEmpty()) {
                    return false;
                }
                int oldSize = size();  // calls refreshIfEmpty
                boolean changed = getListDelegate().addAll(index, c);
                if (changed) {
                    int newSize = getDelegate().size();
                    totalSize += (newSize - oldSize);
                    if (oldSize == 0) {
                        addToMap();
                    }
                }
                return changed;
            }

            public V get(int index) {
                refreshIfEmpty();
                return getListDelegate().get(index);
            }

            public V set(int index, V element) {
                refreshIfEmpty();
                return getListDelegate().set(index, element);
            }

            public void add(int index, V element) {
                refreshIfEmpty();
                boolean wasEmpty = getDelegate().isEmpty();
                getListDelegate().add(index, element);
                totalSize++;
                if (wasEmpty) {
                    addToMap();
                }
            }

            public V remove(int index) {
                refreshIfEmpty();
                V value = getListDelegate().remove(index);
                totalSize--;
                removeIfEmpty();
                return value;
            }

            public int indexOf(Object o) {
                refreshIfEmpty();
                return getListDelegate().indexOf(o);
            }

            public int lastIndexOf(Object o) {
                refreshIfEmpty();
                return getListDelegate().lastIndexOf(o);
            }

            public ListIterator<V> listIterator() {
                refreshIfEmpty();
                return new WrappedListIterator();
            }

            public ListIterator<V> listIterator(int index) {
                refreshIfEmpty();
                return new WrappedListIterator(index);
            }

            public List<V> subList(int fromIndex, int toIndex) {
                refreshIfEmpty();
                return wrapList(getKey(),
                        getListDelegate().subList(fromIndex, toIndex),
                        (getAncestor() == null) ? this : getAncestor());
            }


            private class WrappedListIterator extends WrappedIterator
                    implements ListIterator<V> {
                WrappedListIterator() {}

                public WrappedListIterator(int index) {
                    super(getListDelegate().listIterator(index));
                }

                private ListIterator<V> getDelegateListIterator() {
                    return (ListIterator<V>) getDelegateIterator();
                }

                public boolean hasPrevious() {
                    return getDelegateListIterator().hasPrevious();
                }

                public V previous() {
                    return getDelegateListIterator().previous();
                }

                public int nextIndex() {
                    return getDelegateListIterator().nextIndex();
                }

                public int previousIndex() {
                    return getDelegateListIterator().previousIndex();
                }

                public void set(V value) {
                    getDelegateListIterator().set(value);
                }

                public void add(V value) {
                    boolean wasEmpty = isEmpty();
                    getDelegateListIterator().add(value);
                    totalSize++;
                    if (wasEmpty) {
                        addToMap();
                    }
                }
            }
        }


        private class RandomAccessWrappedList extends WrappedList
                implements RandomAccess {
            RandomAccessWrappedList(@Nullable K key, List<V> delegate,
                                    @Nullable WrappedCollection ancestor) {
                super(key, delegate, ancestor);
            }
        }

        private transient Set<K> keySet;

        public Set<K> keySet() {
            Set<K> result = keySet;
            return (result == null) ? keySet = createKeySet() : result;
        }

        private Set<K> createKeySet() {
            return (map instanceof SortedMap)
                    ? new SortedKeySet((SortedMap<K, Collection<V>>) map) : new KeySet(map);
        }

        private class KeySet extends AbstractSet<K> {

            final Map<K, Collection<V>> subMap;

            KeySet(final Map<K, Collection<V>> subMap) {
                this.subMap = subMap;
            }

            @Override public int size() {
                return subMap.size();
            }

            @Override public Iterator<K> iterator() {
                return new Iterator<K>() {
                    final Iterator<Map.Entry<K, Collection<V>>> entryIterator
                            = subMap.entrySet().iterator();
                    Map.Entry<K, Collection<V>> entry;

                    public boolean hasNext() {
                        return entryIterator.hasNext();
                    }
                    public K next() {
                        entry = entryIterator.next();
                        return entry.getKey();
                    }
                    public void remove() {
                        checkState(entry != null);
                        Collection<V> collection = entry.getValue();
                        entryIterator.remove();
                        totalSize -= collection.size();
                        collection.clear();
                    }
                };
            }

            // The following methods are included for better performance.

            @Override public boolean contains(Object key) {
                return subMap.containsKey(key);
            }

            @Override public boolean remove(Object key) {
                int count = 0;
                Collection<V> collection = subMap.remove(key);
                if (collection != null) {
                    count = collection.size();
                    collection.clear();
                    totalSize -= count;
                }
                return count > 0;
            }

            @Override public boolean removeAll(Collection<?> c) {
                checkNotNull(c); // eager for GWT
                return super.removeAll(c);
            }

            @Override public boolean containsAll(Collection<?> c) {
                return subMap.keySet().containsAll(c);
            }

            @Override public boolean equals(@Nullable Object object) {
                return this == object || this.subMap.keySet().equals(object);
            }

            @Override public int hashCode() {
                return subMap.keySet().hashCode();
            }
        }

        private class SortedKeySet extends KeySet implements SortedSet<K> {

            SortedKeySet(SortedMap<K, Collection<V>> subMap) {
                super(subMap);
            }

            SortedMap<K, Collection<V>> sortedMap() {
                return (SortedMap<K, Collection<V>>) subMap;
            }

            public Comparator<? super K> comparator() {
                return sortedMap().comparator();
            }

            public K first() {
                return sortedMap().firstKey();
            }

            public SortedSet<K> headSet(K toElement) {
                return new SortedKeySet(sortedMap().headMap(toElement));
            }

            public K last() {
                return sortedMap().lastKey();
            }

            public SortedSet<K> subSet(K fromElement, K toElement) {
                return new SortedKeySet(sortedMap().subMap(fromElement, toElement));
            }

            public SortedSet<K> tailSet(K fromElement) {
                return new SortedKeySet(sortedMap().tailMap(fromElement));
            }
        }

        private transient Multiset<K> multiset;

        public Multiset<K> keys() {
            Multiset<K> result = multiset;
            return (result == null) ? multiset = new MultisetView() : result;
        }


        private class MultisetView extends AbstractMultiset<K> {

            @Override public int remove(Object key, int occurrences) {
                if (occurrences == 0) {
                    return count(key);
                }
                checkArgument(occurrences > 0);

                Collection<V> collection;
                try {
                    collection = map.get(key);
                } catch (NullPointerException e) {
                    return 0;
                } catch (ClassCastException e) {
                    return 0;
                }

                if (collection == null) {
                    return 0;
                }
                int count = collection.size();

                if (occurrences >= count) {
                    return removeValuesForKey(key);
                }

                Iterator<V> iterator = collection.iterator();
                for (int i = 0; i < occurrences; i++) {
                    iterator.next();
                    iterator.remove();
                }
                totalSize -= occurrences;
                return count;
            }

            @Override public Set<K> elementSet() {
                return AbstractMultimap.this.keySet();
            }

            transient Set<Multiset.Entry<K>> entrySet;

            @Override public Set<Multiset.Entry<K>> entrySet() {
                Set<Multiset.Entry<K>> result = entrySet;
                return (result == null) ? entrySet = new EntrySet() : result;
            }

            private class EntrySet extends AbstractSet<Multiset.Entry<K>> {
                @Override public Iterator<Multiset.Entry<K>> iterator() {
                    return new MultisetEntryIterator();
                }
                @Override public int size() {
                    return map.size();
                }

                // The following methods are included for better performance.

                @Override public boolean contains(Object o) {
                    if (!(o instanceof Multiset.Entry)) {
                        return false;
                    }
                    Multiset.Entry<?> entry = (Multiset.Entry<?>) o;
                    Collection<V> collection = map.get(entry.getElement());
                    return (collection != null) &&
                            (collection.size() == entry.getCount());
                }
                @Override public void clear() {
                    AbstractMultimap.this.clear();
                }
                @Override public boolean remove(Object o) {
                    return contains(o) &&
                            (removeValuesForKey(((Multiset.Entry<?>) o).getElement()) > 0);
                }
            }

            @Override public Iterator<K> iterator() {
                return new MultisetKeyIterator();
            }

            // The following methods are included for better performance.

            @Override public int count(Object key) {
                try {
                    Collection<V> collection = map.get(key);
                    return (collection == null) ? 0 : collection.size();
                } catch (NullPointerException e) {
                    return 0;
                } catch (ClassCastException e) {
                    return 0;
                }
            }

            @Override public int size() {
                return totalSize;
            }

            @Override public void clear() {
                AbstractMultimap.this.clear();
            }
        }


        private int removeValuesForKey(Object key) {
            Collection<V> collection;
            try {
                collection = map.remove(key);
            } catch (NullPointerException e) {
                return 0;
            } catch (ClassCastException e) {
                return 0;
            }

            int count = 0;
            if (collection != null) {
                count = collection.size();
                collection.clear();
                totalSize -= count;
            }
            return count;
        }


        private class MultisetEntryIterator implements Iterator<Multiset.Entry<K>> {
            final Iterator<Map.Entry<K, Collection<V>>> asMapIterator
                    = asMap().entrySet().iterator();

            public boolean hasNext() {
                return asMapIterator.hasNext();
            }
            public Multiset.Entry<K> next() {
                return new MultisetEntry(asMapIterator.next());
            }
            public void remove() {
                asMapIterator.remove();
            }
        }

        private class MultisetEntry extends Multisets.AbstractEntry<K> {
            final Map.Entry<K, Collection<V>> entry;

            public MultisetEntry(Map.Entry<K, Collection<V>> entry) {
                this.entry = entry;
            }
            public K getElement() {
                return entry.getKey();
            }
            public int getCount() {
                return entry.getValue().size();
            }
        }


        private class MultisetKeyIterator implements Iterator<K> {
            final Iterator<Map.Entry<K, V>> entryIterator = entries().iterator();

            public boolean hasNext() {
                return entryIterator.hasNext();
            }
            public K next() {
                return entryIterator.next().getKey();
            }
            public void remove() {
                entryIterator.remove();
            }
        }

        private transient Collection<V> valuesCollection;


        public Collection<V> values() {
            Collection<V> result = valuesCollection;
            return (result == null) ? valuesCollection = new Values() : result;
        }

        private class Values extends AbstractCollection<V> {
            @Override public Iterator<V> iterator() {
                return new ValueIterator();
            }
            @Override public int size() {
                return totalSize;
            }

            // The following methods are included to improve performance.

            @Override public void clear() {
                AbstractMultimap.this.clear();
            }

            @Override public boolean contains(Object value) {
                return containsValue(value);
            }
        }


        private class ValueIterator implements Iterator<V> {
            final Iterator<Map.Entry<K, V>> entryIterator = createEntryIterator();

            public boolean hasNext() {
                return entryIterator.hasNext();
            }
            public V next() {
                return entryIterator.next().getValue();
            }
            public void remove() {
                entryIterator.remove();
            }
        }

        private transient Collection<Map.Entry<K, V>> entries;


        public Collection<Map.Entry<K, V>> entries() {
            Collection<Map.Entry<K, V>> result = entries;
            return (result == null) ? entries = createEntries() : result;
        }

        private Collection<Map.Entry<K, V>> createEntries() {
            // TODO(kevinb): can we refactor so we're not doing "this instanceof"?
            return (this instanceof SetMultimap) ? new EntrySet() : new Entries();
        }


        private class Entries extends AbstractCollection<Map.Entry<K, V>> {
            @Override public Iterator<Map.Entry<K, V>> iterator() {
                return createEntryIterator();
            }
            @Override public int size() {
                return totalSize;
            }

            // The following methods are included to improve performance.

            @Override public boolean contains(Object o) {
                if (!(o instanceof Map.Entry)) {
                    return false;
                }
                Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;
                return containsEntry(entry.getKey(), entry.getValue());
            }

            @Override public void clear() {
                AbstractMultimap.this.clear();
            }

            @Override public boolean remove(Object o) {
                if (!(o instanceof Map.Entry)) {
                    return false;
                }
                Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;
                return AbstractMultimap.this.remove(entry.getKey(), entry.getValue());
            }
        }


        Iterator<Map.Entry<K, V>> createEntryIterator() {
            return new EntryIterator();
        }


        private class EntryIterator implements Iterator<Map.Entry<K, V>> {
            final Iterator<Map.Entry<K, Collection<V>>> keyIterator;
            K key;
            Collection<V> collection;
            Iterator<V> valueIterator;

            EntryIterator() {
                keyIterator = map.entrySet().iterator();
                if (keyIterator.hasNext()) {
                    findValueIteratorAndKey();
                } else {
                    valueIterator = Iterators.emptyModifiableIterator();
                }
            }

            void findValueIteratorAndKey() {
                Map.Entry<K, Collection<V>> entry = keyIterator.next();
                key = entry.getKey();
                collection = entry.getValue();
                valueIterator = collection.iterator();
            }

            public boolean hasNext() {
                return keyIterator.hasNext() || valueIterator.hasNext();
            }

            public Map.Entry<K, V> next() {
                if (!valueIterator.hasNext()) {
                    findValueIteratorAndKey();
                }
                return (Map.Entry<K, V>) Maps.immutableEntry(key, valueIterator.next());
            }

            public void remove() {
                valueIterator.remove();
                if (collection.isEmpty()) {
                    keyIterator.remove();
                }
                totalSize--;
            }
        }


        private class EntrySet extends Entries implements Set<Map.Entry<K, V>> {
            @Override public boolean equals(@Nullable Object object) {
                return Sets.equalsImpl(this, object);
            }
            @Override public int hashCode() {
                return Sets.hashCodeImpl(this);
            }
        }

        private transient Map<K, Collection<V>> asMap;

        public Map<K, Collection<V>> asMap() {
            Map<K, Collection<V>> result = asMap;
            return (result == null) ? asMap = createAsMap() : result;
        }

        private Map<K, Collection<V>> createAsMap() {
            return (map instanceof SortedMap)
                    ? new SortedAsMap((SortedMap<K, Collection<V>>) map) : new AsMap(map);
        }

        private class AsMap extends AbstractMap<K, Collection<V>> {

            final transient Map<K, Collection<V>> submap;

            AsMap(Map<K, Collection<V>> submap) {
                this.submap = submap;
            }

            transient Set<Map.Entry<K, Collection<V>>> entrySet;

            @Override public Set<Map.Entry<K, Collection<V>>> entrySet() {
                Set<Map.Entry<K, Collection<V>>> result = entrySet;
                return (result == null) ? entrySet = new AsMapEntries() : result;
            }

            // The following methods are included for performance.

            @Override public boolean containsKey(Object key) {
                return Maps.safeContainsKey(submap, key);
            }

            @Override public Collection<V> get(Object key) {
                Collection<V> collection = Maps.safeGet(submap, key);
                if (collection == null) {
                    return null;
                }
                @SuppressWarnings("unchecked")
                K k = (K) key;
                return wrapCollection(k, collection);
            }

            @Override public Set<K> keySet() {
                return AbstractMultimap.this.keySet();
            }

            @Override public Collection<V> remove(Object key) {
                Collection<V> collection = submap.remove(key);
                if (collection == null) {
                    return null;
                }

                Collection<V> output = createCollection();
                output.addAll(collection);
                totalSize -= collection.size();
                collection.clear();
                return output;
            }

            @Override public boolean equals(@Nullable Object object) {
                return this == object || submap.equals(object);
            }

            @Override public int hashCode() {
                return submap.hashCode();
            }

            @Override public String toString() {
                return submap.toString();
            }

            class AsMapEntries extends AbstractSet<Map.Entry<K, Collection<V>>> {
                @Override public Iterator<Map.Entry<K, Collection<V>>> iterator() {
                    return new AsMapIterator();
                }

                @Override public int size() {
                    return submap.size();
                }

                // The following methods are included for performance.

                @Override public boolean contains(Object o) {
                    return Collections2.safeContains(submap.entrySet(), o);
                }

                @Override public boolean remove(Object o) {
                    if (!contains(o)) {
                        return false;
                    }
                    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;
                    removeValuesForKey(entry.getKey());
                    return true;
                }
            }


            class AsMapIterator implements Iterator<Map.Entry<K, Collection<V>>> {
                final Iterator<Map.Entry<K, Collection<V>>> delegateIterator
                        = submap.entrySet().iterator();
                Collection<V> collection;

                public boolean hasNext() {
                    return delegateIterator.hasNext();
                }

                public Map.Entry<K, Collection<V>> next() {
                    Map.Entry<K, Collection<V>> entry = delegateIterator.next();
                    K key = entry.getKey();
                    collection = entry.getValue();
                    return (Entry<K, Collection<V>>) Maps.immutableEntry(key, wrapCollection(key, collection));
                }

                public void remove() {
                    delegateIterator.remove();
                    totalSize -= collection.size();
                    collection.clear();
                }
            }
        }

        private class SortedAsMap extends AsMap
                implements SortedMap<K, Collection<V>> {
            SortedAsMap(SortedMap<K, Collection<V>> submap) {
                super(submap);
            }

            SortedMap<K, Collection<V>> sortedMap() {
                return (SortedMap<K, Collection<V>>) submap;
            }

            public Comparator<? super K> comparator() {
                return sortedMap().comparator();
            }

            public K firstKey() {
                return sortedMap().firstKey();
            }

            public K lastKey() {
                return sortedMap().lastKey();
            }

            public SortedMap<K, Collection<V>> headMap(K toKey) {
                return new SortedAsMap(sortedMap().headMap(toKey));
            }

            public SortedMap<K, Collection<V>> subMap(K fromKey, K toKey) {
                return new SortedAsMap(sortedMap().subMap(fromKey, toKey));
            }

            public SortedMap<K, Collection<V>> tailMap(K fromKey) {
                return new SortedAsMap(sortedMap().tailMap(fromKey));
            }

            SortedSet<K> sortedKeySet;

            // returns a SortedSet, even though returning a Set would be sufficient to
            // satisfy the SortedMap.keySet() interface
            @Override public SortedSet<K> keySet() {
                SortedSet<K> result = sortedKeySet;
                return (result == null)
                        ? sortedKeySet = new SortedKeySet(sortedMap()) : result;
            }
        }

        // Comparison and hashing

        @Override public boolean equals(@Nullable Object object) {
            if (object == this) {
                return true;
            }
            if (object instanceof Multimap) {
                Multimap<?, ?> that = (Multimap<?, ?>) object;
                return this.map.equals(that.asMap());
            }
            return false;
        }

        @Override public int hashCode() {
            return map.hashCode();
        }


        @Override public String toString() {
            return map.toString();
        }

        private static final long serialVersionUID = 2447537837011683357L;
    }
    static abstract class AbstractListMultimap<K, V>
            extends AbstractMultimap<K, V> implements ListMultimap<K, V> {

        protected AbstractListMultimap(Map<K, Collection<V>> map) {
            super(map);
        }

        @Override abstract List<V> createCollection();


        @Override public List<V> get(@Nullable K key) {
            return (List<V>) super.get(key);
        }

        @Override public List<V> removeAll(@Nullable Object key) {
            return (List<V>) super.removeAll(key);
        }

        @Override public List<V> replaceValues(
                @Nullable K key, Iterable<? extends V> values) {
            return (List<V>) super.replaceValues(key, values);
        }


        @Override public boolean put(@Nullable K key, @Nullable V value) {
            return super.put(key, value);
        }

        @Override public Map<K, Collection<V>> asMap() {
            return super.asMap();
        }


        @Override public boolean equals(@Nullable Object object) {
            return super.equals(object);
        }

        private static final long serialVersionUID = 6588350623831699109L;
    }
    abstract static class AbstractSetMultimap<K, V>
            extends AbstractMultimap<K, V> implements SetMultimap<K, V> {

        protected AbstractSetMultimap(Map<K, Collection<V>> map) {
            super(map);
        }

        @Override abstract Set<V> createCollection();

        // Following Javadoc copied from SetMultimap.


        @Override public Set<V> get(@Nullable K key) {
            return (Set<V>) super.get(key);
        }

        @Override public Set<Map.Entry<K, V>> entries() {
            return (Set<Map.Entry<K, V>>) super.entries();
        }

        @Override public Set<V> removeAll(@Nullable Object key) {
            return (Set<V>) super.removeAll(key);
        }

        @Override public Set<V> replaceValues(
                @Nullable K key, Iterable<? extends V> values) {
            return (Set<V>) super.replaceValues(key, values);
        }

        @Override public Map<K, Collection<V>> asMap() {
            return super.asMap();
        }

        @Override public boolean put(K key, V value) {
            return super.put(key, value);
        }

        @Override public boolean equals(@Nullable Object object) {
            return super.equals(object);
        }

        private static final long serialVersionUID = 7431625294878419160L;
    }
    abstract static class AbstractSortedSetMultimap<K, V>
            extends AbstractSetMultimap<K, V> implements SortedSetMultimap<K, V> {

        protected AbstractSortedSetMultimap(Map<K, Collection<V>> map) {
            super(map);
        }

        @Override abstract SortedSet<V> createCollection();


        @Override public SortedSet<V> get(@Nullable K key) {
            return (SortedSet<V>) super.get(key);
        }


        @Override public SortedSet<V> removeAll(@Nullable Object key) {
            return (SortedSet<V>) super.removeAll(key);
        }


        @Override public SortedSet<V> replaceValues(
                K key, Iterable<? extends V> values) {
            return (SortedSet<V>) super.replaceValues(key, values);
        }

        @Override public Map<K, Collection<V>> asMap() {
            return super.asMap();
        }

        @Override public Collection<V> values() {
            return super.values();
        }

        private static final long serialVersionUID = 430848587173315748L;
    }
    static public final class Multimaps {
        private Multimaps() {}

        public static <K, V> Multimap<K, V> newMultimap(Map<K, Collection<V>> map,
                                                        final Supplier<? extends Collection<V>> factory) {
            return new CustomMultimap<K, V>(map, factory);
        }

        private static class CustomMultimap<K, V> extends AbstractMultimap<K, V> {
            transient Supplier<? extends Collection<V>> factory;

            CustomMultimap(Map<K, Collection<V>> map,
                           Supplier<? extends Collection<V>> factory) {
                super(map);
                this.factory = checkNotNull(factory);
            }

            @Override protected Collection<V> createCollection() {
                return factory.get();
            }


            @GwtIncompatible("java.io.ObjectOutputStream")
            private void writeObject(ObjectOutputStream stream) throws IOException {
                stream.defaultWriteObject();
                stream.writeObject(factory);
                stream.writeObject(backingMap());
            }

            @GwtIncompatible("java.io.ObjectInputStream")
            @SuppressWarnings("unchecked") // reading data stored by writeObject
            private void readObject(ObjectInputStream stream)
                    throws IOException, ClassNotFoundException {
                stream.defaultReadObject();
                factory = (Supplier<? extends Collection<V>>) stream.readObject();
                Map<K, Collection<V>> map = (Map<K, Collection<V>>) stream.readObject();
                setMap(map);
            }

            @GwtIncompatible("java serialization not supported")
            private static final long serialVersionUID = 0;
        }

        public static <K, V> ListMultimap<K, V> newListMultimap(
                Map<K, Collection<V>> map, final Supplier<? extends List<V>> factory) {
            return new CustomListMultimap<K, V>(map, factory);
        }

        private static class CustomListMultimap<K, V>
                extends AbstractListMultimap<K, V> {
            transient Supplier<? extends List<V>> factory;

            CustomListMultimap(Map<K, Collection<V>> map,
                               Supplier<? extends List<V>> factory) {
                super(map);
                this.factory = checkNotNull(factory);
            }

            @Override protected List<V> createCollection() {
                return factory.get();
            }

            @GwtIncompatible("java.io.ObjectOutputStream")
            private void writeObject(ObjectOutputStream stream) throws IOException {
                stream.defaultWriteObject();
                stream.writeObject(factory);
                stream.writeObject(backingMap());
            }

            @GwtIncompatible("java.io.ObjectInputStream")
            @SuppressWarnings("unchecked") // reading data stored by writeObject
            private void readObject(ObjectInputStream stream)
                    throws IOException, ClassNotFoundException {
                stream.defaultReadObject();
                factory = (Supplier<? extends List<V>>) stream.readObject();
                Map<K, Collection<V>> map = (Map<K, Collection<V>>) stream.readObject();
                setMap(map);
            }

            @GwtIncompatible("java serialization not supported")
            private static final long serialVersionUID = 0;
        }

        public static <K, V> SetMultimap<K, V> newSetMultimap(
                Map<K, Collection<V>> map, final Supplier<? extends Set<V>> factory) {
            return new CustomSetMultimap<K, V>(map, factory);
        }

        private static class CustomSetMultimap<K, V>
                extends AbstractSetMultimap<K, V> {
            transient Supplier<? extends Set<V>> factory;

            CustomSetMultimap(Map<K, Collection<V>> map,
                              Supplier<? extends Set<V>> factory) {
                super(map);
                this.factory = checkNotNull(factory);
            }

            @Override protected Set<V> createCollection() {
                return factory.get();
            }


            @GwtIncompatible("java.io.ObjectOutputStream")
            private void writeObject(ObjectOutputStream stream) throws IOException {
                stream.defaultWriteObject();
                stream.writeObject(factory);
                stream.writeObject(backingMap());
            }

            @GwtIncompatible("java.io.ObjectInputStream")
            @SuppressWarnings("unchecked") // reading data stored by writeObject
            private void readObject(ObjectInputStream stream)
                    throws IOException, ClassNotFoundException {
                stream.defaultReadObject();
                factory = (Supplier<? extends Set<V>>) stream.readObject();
                Map<K, Collection<V>> map = (Map<K, Collection<V>>) stream.readObject();
                setMap(map);
            }

            @GwtIncompatible("not needed in emulated source")
            private static final long serialVersionUID = 0;
        }

        public static <K, V> SortedSetMultimap<K, V> newSortedSetMultimap(
                Map<K, Collection<V>> map,
                final Supplier<? extends SortedSet<V>> factory) {
            return new CustomSortedSetMultimap<K, V>(map, factory);
        }

        private static class CustomSortedSetMultimap<K, V>
                extends AbstractSortedSetMultimap<K, V> {
            transient Supplier<? extends SortedSet<V>> factory;
            transient Comparator<? super V> valueComparator;

            CustomSortedSetMultimap(Map<K, Collection<V>> map,
                                    Supplier<? extends SortedSet<V>> factory) {
                super(map);
                this.factory = checkNotNull(factory);
                valueComparator = factory.get().comparator();
            }

            @Override protected SortedSet<V> createCollection() {
                return factory.get();
            }

            @Override public Comparator<? super V> valueComparator() {
                return valueComparator;
            }

            @GwtIncompatible("java.io.ObjectOutputStream")
            private void writeObject(ObjectOutputStream stream) throws IOException {
                stream.defaultWriteObject();
                stream.writeObject(factory);
                stream.writeObject(backingMap());
            }

            @GwtIncompatible("java.io.ObjectInputStream")
            @SuppressWarnings("unchecked") // reading data stored by writeObject
            private void readObject(ObjectInputStream stream)
                    throws IOException, ClassNotFoundException {
                stream.defaultReadObject();
                factory = (Supplier<? extends SortedSet<V>>) stream.readObject();
                valueComparator = factory.get().comparator();
                Map<K, Collection<V>> map = (Map<K, Collection<V>>) stream.readObject();
                setMap(map);
            }

            @GwtIncompatible("not needed in emulated source")
            private static final long serialVersionUID = 0;
        }

        public static <K, V, M extends Multimap<K, V>> M invertFrom(
                Multimap<? extends V, ? extends K> source, M dest) {
            checkNotNull(dest);
            for (Map.Entry<? extends V, ? extends K> entry : source.entries()) {
                dest.put(entry.getValue(), entry.getKey());
            }
            return dest;
        }

        public static <K, V> Multimap<K, V> synchronizedMultimap(
                Multimap<K, V> multimap) {
            return Synchronized.multimap(multimap, null);
        }

        public static <K, V> Multimap<K, V> unmodifiableMultimap(
                Multimap<K, V> delegate) {
            return new UnmodifiableMultimap<K, V>(delegate);
        }

        private static class UnmodifiableMultimap<K, V>
                extends ForwardingMultimap<K, V> implements Serializable {
            final Multimap<K, V> delegate;
            transient Collection<Map.Entry<K, V>> entries;
            transient Multiset<K> keys;
            transient Set<K> keySet;
            transient Collection<V> values;
            transient Map<K, Collection<V>> map;

            UnmodifiableMultimap(final Multimap<K, V> delegate) {
                this.delegate = checkNotNull(delegate);
            }

            @Override protected Multimap<K, V> delegate() {
                return delegate;
            }

            @Override public void clear() {
                throw new UnsupportedOperationException();
            }

            @Override public Map<K, Collection<V>> asMap() {
                Map<K, Collection<V>> result = map;
                if (result == null) {
                    final Map<K, Collection<V>> unmodifiableMap
                            = Collections.unmodifiableMap(delegate.asMap());
                    map = result = new ForwardingMap<K, Collection<V>>() {
                        @Override protected Map<K, Collection<V>> delegate() {
                            return unmodifiableMap;
                        }

                        Set<Entry<K, Collection<V>>> entrySet;

                        @Override public Set<Map.Entry<K, Collection<V>>> entrySet() {
                            Set<Entry<K, Collection<V>>> result = entrySet;
                            return (result == null)
                                    ? entrySet
                                    = unmodifiableAsMapEntries(unmodifiableMap.entrySet())
                                    : result;
                        }

                        @Override public Collection<V> get(Object key) {
                            Collection<V> collection = unmodifiableMap.get(key);
                            return (collection == null)
                                    ? null : unmodifiableValueCollection(collection);
                        }

                        Collection<Collection<V>> asMapValues;

                        @Override public Collection<Collection<V>> values() {
                            Collection<Collection<V>> result = asMapValues;
                            return (result == null)
                                    ? asMapValues
                                    = new UnmodifiableAsMapValues<V>(unmodifiableMap.values())
                                    : result;
                        }

                        @Override public boolean containsValue(Object o) {
                            return values().contains(o);
                        }
                    };
                }
                return result;
            }

            @Override public Collection<Map.Entry<K, V>> entries() {
                Collection<Map.Entry<K, V>> result = entries;
                if (result == null) {
                    entries = result = unmodifiableEntries(delegate.entries());
                }
                return result;
            }

            @Override public Collection<V> get(K key) {
                return unmodifiableValueCollection(delegate.get(key));
            }

            @Override public Multiset<K> keys() {
                Multiset<K> result = keys;
                if (result == null) {
                    keys = result = Multisets.unmodifiableMultiset(delegate.keys());
                }
                return result;
            }

            @Override public Set<K> keySet() {
                Set<K> result = keySet;
                if (result == null) {
                    keySet = result = Collections.unmodifiableSet(delegate.keySet());
                }
                return result;
            }

            @Override public boolean put(K key, V value) {
                throw new UnsupportedOperationException();
            }

            @Override public boolean putAll(K key,
                                            @SuppressWarnings("hiding") Iterable<? extends V> values) {
                throw new UnsupportedOperationException();
            }

            @Override
            public boolean putAll(Multimap<? extends K, ? extends V> multimap) {
                throw new UnsupportedOperationException();
            }

            @Override public boolean remove(Object key, Object value) {
                throw new UnsupportedOperationException();
            }

            @Override public Collection<V> removeAll(Object key) {
                throw new UnsupportedOperationException();
            }

            @Override public Collection<V> replaceValues(K key,
                                                         @SuppressWarnings("hiding") Iterable<? extends V> values) {
                throw new UnsupportedOperationException();
            }

            @Override public Collection<V> values() {
                Collection<V> result = values;
                if (result == null) {
                    values = result = Collections.unmodifiableCollection(delegate.values());
                }
                return result;
            }

            private static final long serialVersionUID = 0;
        }

        private static class UnmodifiableAsMapValues<V>
                extends ForwardingCollection<Collection<V>> {
            final Collection<Collection<V>> delegate;
            UnmodifiableAsMapValues(Collection<Collection<V>> delegate) {
                this.delegate = Collections.unmodifiableCollection(delegate);
            }
            @Override protected Collection<Collection<V>> delegate() {
                return delegate;
            }
            @Override public Iterator<Collection<V>> iterator() {
                final Iterator<Collection<V>> iterator = delegate.iterator();
                return new Iterator<Collection<V>>() {
                    public boolean hasNext() {
                        return iterator.hasNext();
                    }
                    public Collection<V> next() {
                        return unmodifiableValueCollection(iterator.next());
                    }
                    public void remove() {
                        throw new UnsupportedOperationException();
                    }
                };
            }
            @Override public Object[] toArray() {
                return standardToArray();
            }
            @Override public <T> T[] toArray(T[] array) {
                return standardToArray(array);
            }
            @Override public boolean contains(Object o) {
                return standardContains(o);
            }
            @Override public boolean containsAll(Collection<?> c) {
                return standardContainsAll(c);
            }
        }

        private static class UnmodifiableListMultimap<K, V>
                extends UnmodifiableMultimap<K, V> implements ListMultimap<K, V> {
            UnmodifiableListMultimap(ListMultimap<K, V> delegate) {
                super(delegate);
            }
            @Override public ListMultimap<K, V> delegate() {
                return (ListMultimap<K, V>) super.delegate();
            }
            @Override public List<V> get(K key) {
                return Collections.unmodifiableList(delegate().get(key));
            }
            @Override public List<V> removeAll(Object key) {
                throw new UnsupportedOperationException();
            }
            @Override public List<V> replaceValues(
                    K key, @SuppressWarnings("hiding") Iterable<? extends V> values) {
                throw new UnsupportedOperationException();
            }
            private static final long serialVersionUID = 0;
        }

        private static class UnmodifiableSetMultimap<K, V>
                extends UnmodifiableMultimap<K, V> implements SetMultimap<K, V> {
            UnmodifiableSetMultimap(SetMultimap<K, V> delegate) {
                super(delegate);
            }
            @Override public SetMultimap<K, V> delegate() {
                return (SetMultimap<K, V>) super.delegate();
            }
            @Override public Set<V> get(K key) {

                return Collections.unmodifiableSet(delegate().get(key));
            }
            @Override public Set<Map.Entry<K, V>> entries() {
                return Maps.unmodifiableEntrySet(delegate().entries());
            }
            @Override public Set<V> removeAll(Object key) {
                throw new UnsupportedOperationException();
            }
            @Override public Set<V> replaceValues(
                    K key, @SuppressWarnings("hiding") Iterable<? extends V> values) {
                throw new UnsupportedOperationException();
            }
            private static final long serialVersionUID = 0;
        }

        private static class UnmodifiableSortedSetMultimap<K, V>
                extends UnmodifiableSetMultimap<K, V> implements SortedSetMultimap<K, V> {
            UnmodifiableSortedSetMultimap(SortedSetMultimap<K, V> delegate) {
                super(delegate);
            }
            @Override public SortedSetMultimap<K, V> delegate() {
                return (SortedSetMultimap<K, V>) super.delegate();
            }
            @Override public SortedSet<V> get(K key) {
                return Collections.unmodifiableSortedSet(delegate().get(key));
            }
            @Override public SortedSet<V> removeAll(Object key) {
                throw new UnsupportedOperationException();
            }
            @Override public SortedSet<V> replaceValues(
                    K key, @SuppressWarnings("hiding") Iterable<? extends V> values) {
                throw new UnsupportedOperationException();
            }
            public Comparator<? super V> valueComparator() {
                return delegate().valueComparator();
            }
            private static final long serialVersionUID = 0;
        }


        public static <K, V> SetMultimap<K, V> synchronizedSetMultimap(
                SetMultimap<K, V> multimap) {
            return Synchronized.setMultimap(multimap, null);
        }


        public static <K, V> SetMultimap<K, V> unmodifiableSetMultimap(
                SetMultimap<K, V> delegate) {
            return new UnmodifiableSetMultimap<K, V>(delegate);
        }

        public static <K, V> SortedSetMultimap<K, V>
        synchronizedSortedSetMultimap(SortedSetMultimap<K, V> multimap) {
            return Synchronized.sortedSetMultimap(multimap, null);
        }


        public static <K, V> SortedSetMultimap<K, V> unmodifiableSortedSetMultimap(
                SortedSetMultimap<K, V> delegate) {
            return new UnmodifiableSortedSetMultimap<K, V>(delegate);
        }

        public static <K, V> ListMultimap<K, V> synchronizedListMultimap(
                ListMultimap<K, V> multimap) {
            return Synchronized.listMultimap(multimap, null);
        }


        public static <K, V> ListMultimap<K, V> unmodifiableListMultimap(
                ListMultimap<K, V> delegate) {
            return new UnmodifiableListMultimap<K, V>(delegate);
        }


        private static <V> Collection<V> unmodifiableValueCollection(
                Collection<V> collection) {
            if (collection instanceof SortedSet) {
                return Collections.unmodifiableSortedSet((SortedSet<V>) collection);
            } else if (collection instanceof Set) {
                return Collections.unmodifiableSet((Set<V>) collection);
            } else if (collection instanceof List) {
                return Collections.unmodifiableList((List<V>) collection);
            }
            return Collections.unmodifiableCollection(collection);
        }

        private static <K, V> Map.Entry<K, Collection<V>> unmodifiableAsMapEntry(
                final Map.Entry<K, Collection<V>> entry) {
            checkNotNull(entry);
            return new AbstractMapEntry<K, Collection<V>>() {
                @Override public K getKey() {
                    return entry.getKey();
                }

                @Override public Collection<V> getValue() {
                    return unmodifiableValueCollection(entry.getValue());
                }
            };
        }


        private static <K, V> Collection<Map.Entry<K, V>> unmodifiableEntries(
                Collection<Map.Entry<K, V>> entries) {
            if (entries instanceof Set) {
                return Maps.unmodifiableEntrySet((Set<Map.Entry<K, V>>) entries);
            }
            return new Maps.UnmodifiableEntries<K, V>(
                    Collections.unmodifiableCollection(entries));
        }


        private static <K, V> Set<Map.Entry<K, Collection<V>>> unmodifiableAsMapEntries(
                Set<Map.Entry<K, Collection<V>>> asMapEntries) {
            return new UnmodifiableAsMapEntries<K, V>(
                    Collections.unmodifiableSet(asMapEntries));
        }


        static class UnmodifiableAsMapEntries<K, V>
                extends ForwardingSet<Map.Entry<K, Collection<V>>> {
            private final Set<Map.Entry<K, Collection<V>>> delegate;
            UnmodifiableAsMapEntries(Set<Map.Entry<K, Collection<V>>> delegate) {
                this.delegate = delegate;
            }

            @Override protected Set<Map.Entry<K, Collection<V>>> delegate() {
                return delegate;
            }

            @Override public Iterator<Map.Entry<K, Collection<V>>> iterator() {
                final Iterator<Map.Entry<K, Collection<V>>> iterator = delegate.iterator();
                return new ForwardingIterator<Map.Entry<K, Collection<V>>>() {
                    @Override protected Iterator<Map.Entry<K, Collection<V>>> delegate() {
                        return iterator;
                    }
                    @Override public Map.Entry<K, Collection<V>> next() {
                        return unmodifiableAsMapEntry(iterator.next());
                    }
                };
            }

            @Override public Object[] toArray() {
                return standardToArray();
            }

            @Override public <T> T[] toArray(T[] array) {
                return standardToArray(array);
            }

            @Override public boolean contains(Object o) {
                return Maps.containsEntryImpl(delegate(), o);
            }

            @Override public boolean containsAll(Collection<?> c) {
                return standardContainsAll(c);
            }

            @Override public boolean equals(@Nullable Object object) {
                return standardEquals(object);
            }
        }


        public static <K, V> SetMultimap<K, V> forMap(Map<K, V> map) {
            return new MapMultimap<K, V>(map);
        }

        private static class MapMultimap<K, V>
                implements SetMultimap<K, V>, Serializable {
            final Map<K, V> map;
            transient Map<K, Collection<V>> asMap;

            MapMultimap(Map<K, V> map) {
                this.map = checkNotNull(map);
            }

            public int size() {
                return map.size();
            }

            public boolean isEmpty() {
                return map.isEmpty();
            }

            public boolean containsKey(Object key) {
                return map.containsKey(key);
            }

            public boolean containsValue(Object value) {
                return map.containsValue(value);
            }

            public boolean containsEntry(Object key, Object value) {
                return map.entrySet().contains(Maps.immutableEntry(key, value));
            }

            public Set<V> get(final K key) {
                return new AbstractSet<V>() {
                    @Override public Iterator<V> iterator() {
                        return new Iterator<V>() {
                            int i;

                            public boolean hasNext() {
                                return (i == 0) && map.containsKey(key);
                            }

                            public V next() {
                                if (!hasNext()) {
                                    throw new NoSuchElementException();
                                }
                                i++;
                                return map.get(key);
                            }

                            public void remove() {
                                checkState(i == 1);
                                i = -1;
                                map.remove(key);
                            }
                        };
                    }

                    @Override public int size() {
                        return map.containsKey(key) ? 1 : 0;
                    }
                };
            }

            public boolean put(K key, V value) {
                throw new UnsupportedOperationException();
            }

            public boolean putAll(K key, Iterable<? extends V> values) {
                throw new UnsupportedOperationException();
            }

            public boolean putAll(Multimap<? extends K, ? extends V> multimap) {
                throw new UnsupportedOperationException();
            }

            public Set<V> replaceValues(K key, Iterable<? extends V> values) {
                throw new UnsupportedOperationException();
            }

            public boolean remove(Object key, Object value) {
                return map.entrySet().remove(Maps.immutableEntry(key, value));
            }

            public Set<V> removeAll(Object key) {
                Set<V> values = new HashSet<V>(2);
                if (!map.containsKey(key)) {
                    return values;
                }
                values.add(map.remove(key));
                return values;
            }

            public void clear() {
                map.clear();
            }

            public Set<K> keySet() {
                return map.keySet();
            }

            public Multiset<K> keys() {
                return Multisets.forSet(map.keySet());
            }

            public Collection<V> values() {
                return map.values();
            }

            public Set<Map.Entry<K, V>> entries() {
                return map.entrySet();
            }

            public Map<K, Collection<V>> asMap() {
                Map<K, Collection<V>> result = asMap;
                if (result == null) {
                    asMap = result = new AsMap();
                }
                return result;
            }

            @Override public boolean equals(@Nullable Object object) {
                if (object == this) {
                    return true;
                }
                if (object instanceof Multimap) {
                    Multimap<?, ?> that = (Multimap<?, ?>) object;
                    return this.size() == that.size() && asMap().equals(that.asMap());
                }
                return false;
            }

            @Override public int hashCode() {
                return map.hashCode();
            }

            private static final Joiner.MapJoiner JOINER
                    = Joiner.on("], ").withKeyValueSeparator("=[").useForNull("null");

            @Override public String toString() {
                if (map.isEmpty()) {
                    return "{}";
                }
                StringBuilder builder
                        = Collections2.newStringBuilderForCollection(map.size()).append('{');
                JOINER.appendTo(builder, map);
                return builder.append("]}").toString();
            }


            class AsMapEntries extends AbstractSet<Map.Entry<K, Collection<V>>> {
                @Override public int size() {
                    return map.size();
                }

                @Override public Iterator<Map.Entry<K, Collection<V>>> iterator() {
                    return new Iterator<Map.Entry<K, Collection<V>>>() {
                        final Iterator<K> keys = map.keySet().iterator();

                        public boolean hasNext() {
                            return keys.hasNext();
                        }
                        public Map.Entry<K, Collection<V>> next() {
                            final K key = keys.next();
                            return new AbstractMapEntry<K, Collection<V>>() {
                                @Override public K getKey() {
                                    return key;
                                }
                                @Override public Collection<V> getValue() {
                                    return get(key);
                                }
                            };
                        }
                        public void remove() {
                            keys.remove();
                        }
                    };
                }

                @Override public boolean contains(Object o) {
                    if (!(o instanceof Map.Entry)) {
                        return false;
                    }
                    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;
                    if (!(entry.getValue() instanceof Set)) {
                        return false;
                    }
                    Set<?> set = (Set<?>) entry.getValue();
                    return (set.size() == 1)
                            && containsEntry(entry.getKey(), set.iterator().next());
                }

                @Override public boolean remove(Object o) {
                    if (!(o instanceof Map.Entry)) {
                        return false;
                    }
                    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;
                    if (!(entry.getValue() instanceof Set)) {
                        return false;
                    }
                    Set<?> set = (Set<?>) entry.getValue();
                    return (set.size() == 1)
                            && map.entrySet().remove(
                            Maps.immutableEntry(entry.getKey(), set.iterator().next()));
                }
            }


            class AsMap extends Maps.ImprovedAbstractMap<K, Collection<V>> {
                @Override protected Set<Entry<K, Collection<V>>> createEntrySet() {
                    return new AsMapEntries();
                }

                // The following methods are included for performance.

                @Override public boolean containsKey(Object key) {
                    return map.containsKey(key);
                }

                @SuppressWarnings("unchecked")
                @Override public Collection<V> get(Object key) {
                    Collection<V> collection = MapMultimap.this.get((K) key);
                    return collection.isEmpty() ? null : collection;
                }

                @Override public Collection<V> remove(Object key) {
                    Collection<V> collection = removeAll(key);
                    return collection.isEmpty() ? null : collection;
                }
            }
            private static final long serialVersionUID = 7845222491160860175L;
        }

        @Beta
        @GwtIncompatible(value = "untested")
        public static <K, V1, V2> Multimap<K, V2> transformValues(
                Multimap<K, V1> fromMultimap, final Function<? super V1, V2> function) {
            checkNotNull(function);
            EntryTransformer<K, V1, V2> transformer =
                    new EntryTransformer<K, V1, V2>() {
                        public V2 transformEntry(K key, V1 value) {
                            return function.apply(value);
                        }
                    };
            return transformEntries(fromMultimap, transformer);
        }

        @Beta
        @GwtIncompatible(value = "untested")
        public static <K, V1, V2> Multimap<K, V2> transformEntries(
                Multimap<K, V1> fromMap,
                EntryTransformer<? super K, ? super V1, V2> transformer) {
            return new TransformedEntriesMultimap<K, V1, V2>(fromMap, transformer);
        }

        @GwtIncompatible(value = "untested")
        private static class TransformedEntriesMultimap<K, V1, V2>
                implements Multimap<K, V2> {
            final Multimap<K, V1> fromMultimap;
            final EntryTransformer<? super K, ? super V1, V2> transformer;

            TransformedEntriesMultimap(Multimap<K, V1> fromMultimap,
                                       final EntryTransformer<? super K, ? super V1, V2> transformer) {
                this.fromMultimap = checkNotNull(fromMultimap);
                this.transformer = checkNotNull(transformer);
            }

            Collection<V2> transform(final K key, Collection<V1> values) {
                return Collections2.transform(values, new Function<V1, V2>() {
                    @Override public V2 apply(V1 value) {
                        return transformer.transformEntry(key, value);
                    }
                });
            }

            private transient Map<K, Collection<V2>> asMap;

            @Override public Map<K, Collection<V2>> asMap() {
                if (asMap == null) {
                    Map<K, Collection<V2>> aM = Maps.transformEntries(fromMultimap.asMap(),
                            new EntryTransformer<K, Collection<V1>, Collection<V2>>() {

                                @Override public Collection<V2> transformEntry(
                                        K key, Collection<V1> value) {
                                    return transform(key, value);
                                }
                            });
                    asMap = aM;
                    return aM;
                }
                return asMap;
            }

            @Override public void clear() {
                fromMultimap.clear();
            }

            @SuppressWarnings("unchecked")
            @Override public boolean containsEntry(Object key, Object value) {
                Collection<V2> values = get((K) key);
                return values.contains(value);
            }

            @Override public boolean containsKey(Object key) {
                return fromMultimap.containsKey(key);
            }

            @Override public boolean containsValue(Object value) {
                return values().contains(value);
            }

            private transient Collection<Map.Entry<K, V2>> entries;

            @Override public Collection<Map.Entry<K, V2>> entries() {
                if (entries == null) {
                    Collection<Map.Entry<K, V2>> es = new TransformedEntries(transformer);
                    entries = es;
                    return es;
                }
                return entries;
            }

            private class TransformedEntries
                    extends Collections2.TransformedCollection<Map.Entry<K, V1>, Map.Entry<K, V2>> {

                TransformedEntries(
                        final EntryTransformer<? super K, ? super V1, V2> transformer) {
                    super(fromMultimap.entries(),
                            new Function<Map.Entry<K, V1>, Map.Entry<K, V2>>() {
                                @Override public Map.Entry<K, V2> apply(final Map.Entry<K, V1> entry) {
                                    return new AbstractMapEntry<K, V2>() {

                                        @Override public K getKey() {
                                            return entry.getKey();
                                        }

                                        @Override public V2 getValue() {
                                            return transformer.transformEntry(
                                                    entry.getKey(), entry.getValue());
                                        }
                                    };
                                }
                            });
                }

                @SuppressWarnings("unchecked")
                @Override public boolean contains(Object o) {
                    if (o instanceof Map.Entry) {
                        Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;
                        return containsEntry(entry.getKey(), entry.getValue());
                    }
                    return false;
                }

                @SuppressWarnings("unchecked")
                @Override public boolean remove(Object o) {
                    if (o instanceof Map.Entry) {
                        Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;
                        Collection<V2> values = get((K) entry.getKey());
                        return values.remove(entry.getValue());
                    }
                    return false;
                }

            }

            @Override public Collection<V2> get(final K key) {
                return transform(key, fromMultimap.get(key));
            }

            @Override public boolean isEmpty() {
                return fromMultimap.isEmpty();
            }

            @Override public Set<K> keySet() {
                return fromMultimap.keySet();
            }

            @Override public Multiset<K> keys() {
                return fromMultimap.keys();
            }

            @Override public boolean put(K key, V2 value) {
                throw new UnsupportedOperationException();
            }

            @Override public boolean putAll(K key, Iterable<? extends V2> values) {
                throw new UnsupportedOperationException();
            }

            @Override public boolean putAll(
                    Multimap<? extends K, ? extends V2> multimap) {
                throw new UnsupportedOperationException();
            }

            @SuppressWarnings("unchecked")
            @Override public boolean remove(Object key, Object value) {
                return get((K) key).remove(value);
            }

            @SuppressWarnings("unchecked")
            @Override public Collection<V2> removeAll(Object key) {
                return transform((K) key, fromMultimap.removeAll(key));
            }

            @Override public Collection<V2> replaceValues(
                    K key, Iterable<? extends V2> values) {
                throw new UnsupportedOperationException();
            }

            @Override public int size() {
                return fromMultimap.size();
            }

            private transient Collection<V2> values;

            @Override public Collection<V2> values() {
                if (values == null) {
                    Collection<V2> vs = Collections2.transform(
                            fromMultimap.entries(), new Function<Map.Entry<K, V1>, V2>() {

                        @Override public V2 apply(Map.Entry<K, V1> entry) {
                            return transformer.transformEntry(
                                    entry.getKey(), entry.getValue());
                        }
                    });
                    values = vs;
                    return vs;
                }
                return values;
            }

            @Override public boolean equals(Object obj) {
                if (obj instanceof Multimap) {
                    Multimap<?, ?> other = (Multimap<?, ?>) obj;
                    return asMap().equals(other.asMap());
                }
                return false;
            }

            @Override public int hashCode() {
                return asMap().hashCode();
            }

            @Override public String toString() {
                return asMap().toString();
            }
        }

        @Beta
        @GwtIncompatible(value = "untested")
        public static <K, V1, V2> ListMultimap<K, V2> transformValues(
                ListMultimap<K, V1> fromMultimap,
                final Function<? super V1, V2> function) {
            checkNotNull(function);
            EntryTransformer<K, V1, V2> transformer =
                    new EntryTransformer<K, V1, V2>() {
                        public V2 transformEntry(K key, V1 value) {
                            return function.apply(value);
                        }
                    };
            return transformEntries(fromMultimap, transformer);
        }

        @Beta
        @GwtIncompatible(value = "untested")
        public static <K, V1, V2> ListMultimap<K, V2> transformEntries(
                ListMultimap<K, V1> fromMap,
                EntryTransformer<? super K, ? super V1, V2> transformer) {
            return new TransformedEntriesListMultimap<K, V1, V2>(fromMap, transformer);
        }

        @GwtIncompatible(value = "untested")
        private static final class TransformedEntriesListMultimap<K, V1, V2>
                extends TransformedEntriesMultimap<K, V1, V2>
                implements ListMultimap<K, V2> {

            TransformedEntriesListMultimap(ListMultimap<K, V1> fromMultimap,
                                           EntryTransformer<? super K, ? super V1, V2> transformer) {
                super(fromMultimap, transformer);
            }

            @Override List<V2> transform(final K key, Collection<V1> values) {
                return Lists.transform((List<V1>) values, new Function<V1, V2>() {
                    @Override public V2 apply(V1 value) {
                        return transformer.transformEntry(key, value);
                    }
                });
            }

            @Override public List<V2> get(K key) {
                return transform(key, fromMultimap.get(key));
            }

            @SuppressWarnings("unchecked")
            @Override public List<V2> removeAll(Object key) {
                return transform((K) key, fromMultimap.removeAll(key));
            }

            @Override public List<V2> replaceValues(
                    K key, Iterable<? extends V2> values) {
                throw new UnsupportedOperationException();
            }
        }

        public static <K, V> ImmutableListMultimap<K, V> index(
                Iterable<V> values, Function<? super V, K> keyFunction) {
            checkNotNull(keyFunction);
            ImmutableListMultimap.Builder<K, V> builder
                    = ImmutableListMultimap.builder();
            for (V value : values) {
                checkNotNull(value, values);
                builder.put(keyFunction.apply(value), value);
            }
            return builder.build();
        }
    }
    public static class ImmutableListMultimap<K, V>
            extends ImmutableMultimap<K, V>
            implements ListMultimap<K, V> {


        @SuppressWarnings("unchecked")
        public static <K, V> ImmutableListMultimap<K, V> of() {
            return (ImmutableListMultimap<K, V>) EmptyImmutableListMultimap.INSTANCE;
        }

        public static <K, V> ImmutableListMultimap<K, V> of(K k1, V v1) {
            ImmutableListMultimap.Builder<K, V> builder
                    = ImmutableListMultimap.builder();
            builder.put(k1, v1);
            return builder.build();
        }


        public static <K, V> ImmutableListMultimap<K, V> of(K k1, V v1, K k2, V v2) {
            ImmutableListMultimap.Builder<K, V> builder
                    = ImmutableListMultimap.builder();
            builder.put(k1, v1);
            builder.put(k2, v2);
            return builder.build();
        }


        public static <K, V> ImmutableListMultimap<K, V> of(
                K k1, V v1, K k2, V v2, K k3, V v3) {
            ImmutableListMultimap.Builder<K, V> builder
                    = ImmutableListMultimap.builder();
            builder.put(k1, v1);
            builder.put(k2, v2);
            builder.put(k3, v3);
            return builder.build();
        }


        public static <K, V> ImmutableListMultimap<K, V> of(
                K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {
            ImmutableListMultimap.Builder<K, V> builder
                    = ImmutableListMultimap.builder();
            builder.put(k1, v1);
            builder.put(k2, v2);
            builder.put(k3, v3);
            builder.put(k4, v4);
            return builder.build();
        }


        public static <K, V> ImmutableListMultimap<K, V> of(
                K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {
            ImmutableListMultimap.Builder<K, V> builder
                    = ImmutableListMultimap.builder();
            builder.put(k1, v1);
            builder.put(k2, v2);
            builder.put(k3, v3);
            builder.put(k4, v4);
            builder.put(k5, v5);
            return builder.build();
        }


        public static <K, V> Builder<K, V> builder() {
            return new Builder<K, V>();
        }


        public static final class Builder<K, V>
                extends ImmutableMultimap.Builder<K, V> {

            public Builder() {}

            @Override public Builder<K, V> put(K key, V value) {
                super.put(key, value);
                return this;
            }

            @Override public Builder<K, V> putAll(K key, Iterable<? extends V> values) {
                super.putAll(key, values);
                return this;
            }

            @Override public Builder<K, V> putAll(K key, V... values) {
                super.putAll(key, values);
                return this;
            }

            @Override public Builder<K, V> putAll(
                    Multimap<? extends K, ? extends V> multimap) {
                super.putAll(multimap);
                return this;
            }


            @Beta @Override
            public Builder<K, V> orderKeysBy(Comparator<? super K> keyComparator) {
                super.orderKeysBy(keyComparator);
                return this;
            }


            @Beta @Override
            public Builder<K, V> orderValuesBy(Comparator<? super V> valueComparator) {
                super.orderValuesBy(valueComparator);
                return this;
            }


            @Override public ImmutableListMultimap<K, V> build() {
                return (ImmutableListMultimap<K, V>) super.build();
            }
        }


        public static <K, V> ImmutableListMultimap<K, V> copyOf(
                Multimap<? extends K, ? extends V> multimap) {
            if (multimap.isEmpty()) {
                return of();
            }

            // TODO(user): copy ImmutableSetMultimap by using asList() on the sets
            if (multimap instanceof ImmutableListMultimap) {
                @SuppressWarnings("unchecked") // safe since multimap is not writable
                        ImmutableListMultimap<K, V> kvMultimap
                        = (ImmutableListMultimap<K, V>) multimap;
                if (!kvMultimap.isPartialView()) {
                    return kvMultimap;
                }
            }

            ImmutableMap.Builder<K, ImmutableList<V>> builder = ImmutableMap.builder();
            int size = 0;

            for (Map.Entry<? extends K, ? extends Collection<? extends V>> entry
                    : multimap.asMap().entrySet()) {
                ImmutableList<V> list = ImmutableList.copyOf(entry.getValue());
                if (!list.isEmpty()) {
                    builder.put(entry.getKey(), list);
                    size += list.size();
                }
            }

            return new ImmutableListMultimap<K, V>(builder.build(), size);
        }

        ImmutableListMultimap(ImmutableMap<K, ImmutableList<V>> map, int size) {
            super(map, size);
        }


        @Override public ImmutableList<V> get(@Nullable K key) {
            // This cast is safe as its type is known in constructor.
            ImmutableList<V> list = (ImmutableList<V>) map.get(key);
            return (list == null) ? ImmutableList.<V>of() : list;
        }

        @Override public ImmutableList<V> removeAll(Object key) {
            throw new UnsupportedOperationException();
        }


        @Override public ImmutableList<V> replaceValues(
                K key, Iterable<? extends V> values) {
            throw new UnsupportedOperationException();
        }

        @GwtIncompatible("java.io.ObjectOutputStream")
        private void writeObject(ObjectOutputStream stream) throws IOException {
            stream.defaultWriteObject();
            Serialization.writeMultimap(this, stream);
        }

        @GwtIncompatible("java.io.ObjectInputStream")
        private void readObject(ObjectInputStream stream)
                throws IOException, ClassNotFoundException {
            stream.defaultReadObject();
            int keyCount = stream.readInt();
            if (keyCount < 0) {
                throw new InvalidObjectException("Invalid key count " + keyCount);
            }
            ImmutableMap.Builder<Object, ImmutableList<Object>> builder
                    = ImmutableMap.builder();
            int tmpSize = 0;

            for (int i = 0; i < keyCount; i++) {
                Object key = stream.readObject();
                int valueCount = stream.readInt();
                if (valueCount <= 0) {
                    throw new InvalidObjectException("Invalid value count " + valueCount);
                }

                Object[] array = new Object[valueCount];
                for (int j = 0; j < valueCount; j++) {
                    array[j] = stream.readObject();
                }
                builder.put(key, ImmutableList.copyOf(array));
                tmpSize += valueCount;
            }

            ImmutableMap<Object, ImmutableList<Object>> tmpMap;
            try {
                tmpMap = builder.build();
            } catch (IllegalArgumentException e) {
                throw (InvalidObjectException)
                        new InvalidObjectException(e.getMessage()).initCause(e);
            }

            FieldSettersHolder.MAP_FIELD_SETTER.set(this, tmpMap);
            FieldSettersHolder.SIZE_FIELD_SETTER.set(this, tmpSize);
        }

        @GwtIncompatible("Not needed in emulated source")
        private static final long serialVersionUID = 0;
    }
    static class EmptyImmutableListMultimap extends ImmutableListMultimap<Object, Object> {
        static final EmptyImmutableListMultimap INSTANCE
                = new EmptyImmutableListMultimap();

        private EmptyImmutableListMultimap() {
            super(ImmutableMap.<Object, ImmutableList<Object>>of(), 0);
        }

        private Object readResolve() {
            return INSTANCE; // preserve singleton property
        }

        private static final long serialVersionUID = 0;
    }

    static abstract class AbstractMapBasedMultiset<E> extends AbstractMultiset<E>
            implements Serializable {

        // TODO(kevinb): test whether a custom IntegerHolder would be faster
        private transient Map<E, AtomicInteger> backingMap;


        private transient long size;

        protected AbstractMapBasedMultiset(Map<E, AtomicInteger> backingMap) {
            this.backingMap = checkNotNull(backingMap);
            this.size = super.size();
        }

        Map<E, AtomicInteger> backingMap() {
            return backingMap;
        }

        void setBackingMap(Map<E, AtomicInteger> backingMap) {
            this.backingMap = backingMap;
        }

        // Required Implementations

        private transient EntrySet entrySet;

        @Override public Set<Multiset.Entry<E>> entrySet() {
            EntrySet result = entrySet;
            if (result == null) {
                entrySet = result = new EntrySet();
            }
            return result;
        }

        private class EntrySet extends AbstractSet<Multiset.Entry<E>> {
            @Override public Iterator<Multiset.Entry<E>> iterator() {
                final Iterator<Map.Entry<E, AtomicInteger>> backingEntries
                        = backingMap.entrySet().iterator();
                return new Iterator<Multiset.Entry<E>>() {
                    Map.Entry<E, AtomicInteger> toRemove;

                    public boolean hasNext() {
                        return backingEntries.hasNext();
                    }

                    public Multiset.Entry<E> next() {
                        final Map.Entry<E, AtomicInteger> mapEntry = backingEntries.next();
                        toRemove = mapEntry;
                        return new Multisets.AbstractEntry<E>() {
                            public E getElement() {
                                return mapEntry.getKey();
                            }
                            public int getCount() {
                                int count = mapEntry.getValue().get();
                                if (count == 0) {
                                    AtomicInteger frequency = backingMap.get(getElement());
                                    if (frequency != null) {
                                        count = frequency.get();
                                    }
                                }
                                return count;
                            }
                        };
                    }

                    public void remove() {
                        checkState(toRemove != null,
                                "no calls to next() since the last call to remove()");
                        size -= toRemove.getValue().getAndSet(0);
                        backingEntries.remove();
                        toRemove = null;
                    }
                };
            }

            @Override public int size() {
                return backingMap.size();
            }

            // The following overrides are for better performance.

            @Override public void clear() {
                for (AtomicInteger frequency : backingMap.values()) {
                    frequency.set(0);
                }
                backingMap.clear();
                size = 0L;
            }

            @Override public boolean contains(Object o) {
                if (o instanceof Entry) {
                    Entry<?> entry = (Entry<?>) o;
                    int count = count(entry.getElement());
                    return (count == entry.getCount()) && (count > 0);
                }
                return false;
            }

            @Override public boolean remove(Object o) {
                if (contains(o)) {
                    Entry<?> entry = (Entry<?>) o;
                    AtomicInteger frequency = backingMap.remove(entry.getElement());
                    int numberRemoved = frequency.getAndSet(0);
                    size -= numberRemoved;
                    return true;
                }
                return false;
            }
        }

        @Override public int size() {
            return Ints.saturatedCast(size);
        }

        @Override public Iterator<E> iterator() {
            return new MapBasedMultisetIterator();
        }


        private class MapBasedMultisetIterator implements Iterator<E> {
            final Iterator<Map.Entry<E, AtomicInteger>> entryIterator;
            Map.Entry<E, AtomicInteger> currentEntry;
            int occurrencesLeft;
            boolean canRemove;

            MapBasedMultisetIterator() {
                this.entryIterator = backingMap.entrySet().iterator();
            }

            public boolean hasNext() {
                return occurrencesLeft > 0 || entryIterator.hasNext();
            }

            public E next() {
                if (occurrencesLeft == 0) {
                    currentEntry = entryIterator.next();
                    occurrencesLeft = currentEntry.getValue().get();
                }
                occurrencesLeft--;
                canRemove = true;
                return currentEntry.getKey();
            }

            public void remove() {
                checkState(canRemove,
                        "no calls to next() since the last call to remove()");
                int frequency = currentEntry.getValue().get();
                if (frequency <= 0) {
                    throw new ConcurrentModificationException();
                }
                if (currentEntry.getValue().addAndGet(-1) == 0) {
                    entryIterator.remove();
                }
                size--;
                canRemove = false;
            }
        }

        @Override public boolean contains(@Nullable Object element) {
            AtomicInteger frequency = backingMap.get(element);
            return frequency != null && frequency.get() > 0;
        }

        @Override public int count(@Nullable Object element) {
            AtomicInteger frequency = backingMap.get(element);
            return (frequency == null) ? 0 : frequency.get();
        }


        @Override public int add(@Nullable E element, int occurrences) {
            if (occurrences == 0) {
                return count(element);
            }
            checkArgument(
                    occurrences > 0, "occurrences cannot be negative: %s", occurrences);
            AtomicInteger frequency = backingMap.get(element);
            int oldCount;
            if (frequency == null) {
                oldCount = 0;
                backingMap.put(element, new AtomicInteger(occurrences));
            } else {
                oldCount = frequency.get();
                long newCount = (long) oldCount + (long) occurrences;
                checkArgument(newCount <= Integer.MAX_VALUE,
                        "too many occurrences: %s", newCount);
                frequency.getAndAdd(occurrences);
            }
            size += occurrences;
            return oldCount;
        }

        @Override public int remove(@Nullable Object element, int occurrences) {
            if (occurrences == 0) {
                return count(element);
            }
            checkArgument(
                    occurrences > 0, "occurrences cannot be negative: %s", occurrences);
            AtomicInteger frequency = backingMap.get(element);
            if (frequency == null) {
                return 0;
            }

            int oldCount = frequency.get();

            int numberRemoved;
            if (oldCount > occurrences) {
                numberRemoved = occurrences;
            } else {
                numberRemoved = oldCount;
                backingMap.remove(element);
            }

            frequency.addAndGet(-numberRemoved);
            size -= numberRemoved;
            return oldCount;
        }

        // Roughly a 33% performance improvement over AbstractMultiset.setCount().
        @Override public int setCount(E element, int count) {
            Multisets.checkNonnegative(count, "count");

            AtomicInteger existingCounter;
            int oldCount;
            if (count == 0) {
                existingCounter = backingMap.remove(element);
                oldCount = getAndSet(existingCounter, count);
            } else {
                existingCounter = backingMap.get(element);
                oldCount = getAndSet(existingCounter, count);

                if (existingCounter == null) {
                    backingMap.put(element, new AtomicInteger(count));
                }
            }

            size += (count - oldCount);
            return oldCount;
        }

        private static int getAndSet(AtomicInteger i, int count) {
            if (i == null) {
                return 0;
            }

            return i.getAndSet(count);
        }

        private int removeAllOccurrences(@Nullable Object element,
                                         Map<E, AtomicInteger> map) {
            AtomicInteger frequency = map.remove(element);
            if (frequency == null) {
                return 0;
            }
            int numberRemoved = frequency.getAndSet(0);
            size -= numberRemoved;
            return numberRemoved;
        }

        // Views

        @Override Set<E> createElementSet() {
            return new MapBasedElementSet(backingMap);
        }

        class MapBasedElementSet extends ForwardingSet<E> {

            // This mapping is the usually the same as {@code backingMap}, but can be a
            // submap in some implementations.
            private final Map<E, AtomicInteger> map;
            private final Set<E> delegate;

            MapBasedElementSet(Map<E, AtomicInteger> map) {
                this.map = map;
                delegate = map.keySet();
            }

            @Override protected Set<E> delegate() {
                return delegate;
            }

            @Override public Iterator<E> iterator() {
                final Iterator<Map.Entry<E, AtomicInteger>> entries
                        = map.entrySet().iterator();
                return new Iterator<E>() {
                    Map.Entry<E, AtomicInteger> toRemove;

                    public boolean hasNext() {
                        return entries.hasNext();
                    }

                    public E next() {
                        toRemove = entries.next();
                        return toRemove.getKey();
                    }

                    public void remove() {
                        checkState(toRemove != null,
                                "no calls to next() since the last call to remove()");
                        size -= toRemove.getValue().getAndSet(0);
                        entries.remove();
                        toRemove = null;
                    }
                };
            }

            @Override public boolean remove(Object element) {
                return removeAllOccurrences(element, map) != 0;
            }

            @Override public boolean removeAll(Collection<?> elementsToRemove) {
                return Iterators.removeAll(iterator(), elementsToRemove);
            }

            @Override public boolean retainAll(Collection<?> elementsToRetain) {
                return Iterators.retainAll(iterator(), elementsToRetain);
            }

            @Override public void clear() {
                if (map == backingMap) {
                    AbstractMapBasedMultiset.this.clear();
                } else {
                    Iterator<E> i = iterator();
                    while (i.hasNext()) {
                        i.next();
                        i.remove();
                    }
                }
            }

            public Map<E, AtomicInteger> getMap() {
                return map;
            }
        }

        // Don't allow default serialization.
        @GwtIncompatible("java.io.ObjectStreamException")
        @SuppressWarnings("unused") // actually used during deserialization
        private void readObjectNoData() throws ObjectStreamException {
            throw new InvalidObjectException("Stream data required");
        }

        @GwtIncompatible("not needed in emulated source.")
        private static final long serialVersionUID = -2250766705698539974L;
    }
    public final static class LinkedHashMultiset<E> extends AbstractMapBasedMultiset<E> {

        public static <E> LinkedHashMultiset<E> create() {
            return new LinkedHashMultiset<E>();
        }


        public static <E> LinkedHashMultiset<E> create(int distinctElements) {
            return new LinkedHashMultiset<E>(distinctElements);
        }


        public static <E> LinkedHashMultiset<E> create(
                Iterable<? extends E> elements) {
            LinkedHashMultiset<E> multiset =
                    create(Multisets.inferDistinctElements(elements));
            Iterables.addAll(multiset, elements);
            return multiset;
        }

        private LinkedHashMultiset() {
            super(new LinkedHashMap<E, AtomicInteger>());
        }

        private LinkedHashMultiset(int distinctElements) {
            // Could use newLinkedHashMapWithExpectedSize() if it existed
            super(new LinkedHashMap<E, AtomicInteger>(Maps.capacity(distinctElements)));
        }


        @GwtIncompatible("java.io.ObjectOutputStream")
        private void writeObject(ObjectOutputStream stream) throws IOException {
            stream.defaultWriteObject();
            Serialization.writeMultiset(this, stream);
        }

        @GwtIncompatible("java.io.ObjectInputStream")
        private void readObject(ObjectInputStream stream)
                throws IOException, ClassNotFoundException {
            stream.defaultReadObject();
            int distinctElements = Serialization.readCount(stream);
            setBackingMap(new LinkedHashMap<E, AtomicInteger>(
                    Maps.capacity(distinctElements)));
            Serialization.populateMultiset(this, stream, distinctElements);
        }

        @GwtIncompatible("not needed in emulated source")
        private static final long serialVersionUID = 0;
    }
    static final class EmptyImmutableMultiset extends ImmutableMultiset<Object> {
        static final EmptyImmutableMultiset INSTANCE = new EmptyImmutableMultiset();

        private EmptyImmutableMultiset() {
            super(ImmutableMap.<Object, Integer>of(), 0);
        }

        Object readResolve() {
            return INSTANCE; // preserve singleton property
        }

        private static final long serialVersionUID = 0;
    }
    static public class ImmutableMultiset<E> extends ImmutableCollection<E>
            implements Multiset<E> {


        @SuppressWarnings("unchecked") // all supported methods are covariant
        public static <E> ImmutableMultiset<E> of() {
            return (ImmutableMultiset<E>) EmptyImmutableMultiset.INSTANCE;
        }


        @SuppressWarnings("unchecked") // generic array created but never written
        public static <E> ImmutableMultiset<E> of(E element) {
            return copyOfInternal(element);
        }


        @SuppressWarnings("unchecked") //
        public static <E> ImmutableMultiset<E> of(E e1, E e2) {
            return copyOfInternal(e1, e2);
        }


        @SuppressWarnings("unchecked") //
        public static <E> ImmutableMultiset<E> of(E e1, E e2, E e3) {
            return copyOfInternal(e1, e2, e3);
        }

        @SuppressWarnings("unchecked") //
        public static <E> ImmutableMultiset<E> of(E e1, E e2, E e3, E e4) {
            return copyOfInternal(e1, e2, e3, e4);
        }

        @SuppressWarnings("unchecked") //
        public static <E> ImmutableMultiset<E> of(E e1, E e2, E e3, E e4, E e5) {
            return copyOfInternal(e1, e2, e3, e4, e5);
        }

        @SuppressWarnings("unchecked") //
        public static <E> ImmutableMultiset<E> of(
                E e1, E e2, E e3, E e4, E e5, E e6, E... others) {
            int size = others.length + 6;
            List<E> all = new ArrayList<E>(size);
            Collections.addAll(all, e1, e2, e3, e4, e5, e6);
            Collections.addAll(all, others);
            return copyOf(all);
        }

        @Deprecated
        public static <E> ImmutableMultiset<E> of(E[] elements) {
            return copyOf(Arrays.asList(elements));
        }

        public static <E> ImmutableMultiset<E> copyOf(E[] elements) {
            return copyOf(Arrays.asList(elements));
        }

        public static <E> ImmutableMultiset<E> copyOf(
                Iterable<? extends E> elements) {
            if (elements instanceof ImmutableMultiset) {
                @SuppressWarnings("unchecked") // all supported methods are covariant
                        ImmutableMultiset<E> result = (ImmutableMultiset<E>) elements;
                if (!result.isPartialView()) {
                    return result;
                }
            }

            Multiset<? extends E> multiset = (elements instanceof Multiset)
                    ? Multisets.cast(elements)
                    : LinkedHashMultiset.create(elements);

            return copyOfInternal(multiset);
        }

        private static <E> ImmutableMultiset<E> copyOfInternal(E... elements) {
            return copyOf(Arrays.asList(elements));
        }

        private static <E> ImmutableMultiset<E> copyOfInternal(
                Multiset<? extends E> multiset) {
            long size = 0;
            ImmutableMap.Builder<E, Integer> builder = ImmutableMap.builder();

            for (Entry<? extends E> entry : multiset.entrySet()) {
                int count = entry.getCount();
                if (count > 0) {
                    // Since ImmutableMap.Builder throws an NPE if an element is null, no
                    // other null checks are needed.
                    builder.put(entry.getElement(), count);
                    size += count;
                }
            }

            if (size == 0) {
                return of();
            }
            return new ImmutableMultiset<E>(builder.build(), Ints.saturatedCast(size));
        }


        public static <E> ImmutableMultiset<E> copyOf(
                Iterator<? extends E> elements) {
            Multiset<E> multiset = LinkedHashMultiset.create();
            Iterators.addAll(multiset, elements);
            return copyOfInternal(multiset);
        }

        private final transient ImmutableMap<E, Integer> map;
        private final transient int size;

        // These constants allow the deserialization code to set final fields. This
        // holder class makes sure they are not initialized unless an instance is
        // deserialized.
        @GwtIncompatible("java serialization is not supported.")
        @SuppressWarnings("unchecked")
        // eclipse doesn't like the raw types here, but they're harmless
        private static class FieldSettersHolder {
            static final Serialization.FieldSetter<ImmutableMultiset> MAP_FIELD_SETTER
                    = Serialization.getFieldSetter(ImmutableMultiset.class, "map");
            static final Serialization.FieldSetter<ImmutableMultiset> SIZE_FIELD_SETTER
                    = Serialization.getFieldSetter(ImmutableMultiset.class, "size");
        }

        ImmutableMultiset(ImmutableMap<E, Integer> map, int size) {
            this.map = map;
            this.size = size;
        }

        @Override boolean isPartialView() {
            return map.isPartialView();
        }

        public int count(@Nullable Object element) {
            Integer value = map.get(element);
            return (value == null) ? 0 : value;
        }

        @Override public UnmodifiableIterator<E> iterator() {
            final Iterator<Map.Entry<E, Integer>> mapIterator
                    = map.entrySet().iterator();

            return new UnmodifiableIterator<E>() {
                int remaining;
                E element;

                public boolean hasNext() {
                    return (remaining > 0) || mapIterator.hasNext();
                }

                public E next() {
                    if (remaining <= 0) {
                        Map.Entry<E, Integer> entry = mapIterator.next();
                        element = entry.getKey();
                        remaining = entry.getValue();
                    }
                    remaining--;
                    return element;
                }
            };
        }

        public int size() {
            return size;
        }

        @Override public boolean contains(@Nullable Object element) {
            return map.containsKey(element);
        }


        public int add(E element, int occurrences) {
            throw new UnsupportedOperationException();
        }

        public int remove(Object element, int occurrences) {
            throw new UnsupportedOperationException();
        }


        public int setCount(E element, int count) {
            throw new UnsupportedOperationException();
        }


        public boolean setCount(E element, int oldCount, int newCount) {
            throw new UnsupportedOperationException();
        }

        @Override public boolean equals(@Nullable Object object) {
            if (object == this) {
                return true;
            }
            if (object instanceof Multiset) {
                Multiset<?> that = (Multiset<?>) object;
                if (this.size() != that.size()) {
                    return false;
                }
                for (Entry<?> entry : that.entrySet()) {
                    if (count(entry.getElement()) != entry.getCount()) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        @Override public int hashCode() {
            // could cache this, but not considered worthwhile to do so
            return map.hashCode();
        }

        @Override public String toString() {
            return entrySet().toString();
        }

        public Set<E> elementSet() {
            return map.keySet();
        }

        private transient ImmutableSet<Entry<E>> entrySet;

        public Set<Entry<E>> entrySet() {
            ImmutableSet<Entry<E>> es = entrySet;
            return (es == null) ? (entrySet = new EntrySet<E>(this)) : es;
        }

        private static class EntrySet<E> extends ImmutableSet<Entry<E>> {
            final ImmutableMultiset<E> multiset;

            public EntrySet(ImmutableMultiset<E> multiset) {
                this.multiset = multiset;
            }

            @Override public UnmodifiableIterator<Entry<E>> iterator() {
                final Iterator<Map.Entry<E, Integer>> mapIterator
                        = multiset.map.entrySet().iterator();
                return new UnmodifiableIterator<Entry<E>>() {
                    public boolean hasNext() {
                        return mapIterator.hasNext();
                    }
                    public Entry<E> next() {
                        Map.Entry<E, Integer> mapEntry = mapIterator.next();
                        return
                                Multisets.immutableEntry(mapEntry.getKey(), mapEntry.getValue());
                    }
                };
            }

            public int size() {
                return multiset.map.size();
            }

            @Override boolean isPartialView() {
                return multiset.isPartialView();
            }

            @Override public boolean contains(Object o) {
                if (o instanceof Entry) {
                    Entry<?> entry = (Entry<?>) o;
                    if (entry.getCount() <= 0) {
                        return false;
                    }
                    int count = multiset.count(entry.getElement());
                    return count == entry.getCount();
                }
                return false;
            }

            // TODO(hhchan): Revert once this class is emulated in GWT.
            @Override public Object[] toArray() {
                Object[] newArray = new Object[size()];
                return toArray(newArray);
            }

            // TODO(hhchan): Revert once this class is emulated in GWT.
            @Override public <T> T[] toArray(T[] other) {
                int size = size();
                if (other.length < size) {
                    other = ObjectArrays.newArray(other, size);
                } else if (other.length > size) {
                    other[size] = null;
                }

                // Writes will produce ArrayStoreException when the toArray() doc requires
                Object[] otherAsObjectArray = other;
                int index = 0;
                for (Entry<?> element : this) {
                    otherAsObjectArray[index++] = element;
                }
                return other;
            }

            @Override public int hashCode() {
                return multiset.map.hashCode();
            }

            @GwtIncompatible("not needed in emulated source.")
            @Override Object writeReplace() {
                return this;
            }

            private static final long serialVersionUID = 0;
        }


        @GwtIncompatible("java.io.ObjectOutputStream")
        private void writeObject(ObjectOutputStream stream) throws IOException {
            stream.defaultWriteObject();
            Serialization.writeMultiset(this, stream);
        }

        @GwtIncompatible("java.io.ObjectInputStream")
        private void readObject(ObjectInputStream stream)
                throws IOException, ClassNotFoundException {
            stream.defaultReadObject();
            int entryCount = stream.readInt();
            ImmutableMap.Builder<E, Integer> builder = ImmutableMap.builder();
            long tmpSize = 0;
            for (int i = 0; i < entryCount; i++) {
                @SuppressWarnings("unchecked") // reading data stored by writeMultiset
                        E element = (E) stream.readObject();
                int count = stream.readInt();
                if (count <= 0) {
                    throw new InvalidObjectException("Invalid count " + count);
                }
                builder.put(element, count);
                tmpSize += count;
            }

            FieldSettersHolder.MAP_FIELD_SETTER.set(this, builder.build());
            FieldSettersHolder.SIZE_FIELD_SETTER.set(this, Ints.saturatedCast(tmpSize));
        }

        @GwtIncompatible("java serialization not supported.")
        @Override Object writeReplace() {
            return this;
        }

        private static final long serialVersionUID = 0;


        public static <E> Builder<E> builder() {
            return new Builder<E>();
        }

        public static final class Builder<E> extends ImmutableCollection.Builder<E> {
            private final Multiset<E> contents = LinkedHashMultiset.create();

            public Builder() {}

            @Override public Builder<E> add(E element) {
                contents.add(checkNotNull(element));
                return this;
            }

            public Builder<E> addCopies(E element, int occurrences) {
                contents.add(checkNotNull(element), occurrences);
                return this;
            }

            public Builder<E> setCount(E element, int count) {
                contents.setCount(checkNotNull(element), count);
                return this;
            }

            @Override public Builder<E> add(E... elements) {
                super.add(elements);
                return this;
            }

            @Override public Builder<E> addAll(Iterable<? extends E> elements) {
                if (elements instanceof Multiset) {
                    Multiset<? extends E> multiset = Multisets.cast(elements);
                    for (Entry<? extends E> entry : multiset.entrySet()) {
                        addCopies(entry.getElement(), entry.getCount());
                    }
                } else {
                    super.addAll(elements);
                }
                return this;
            }

            @Override public Builder<E> addAll(Iterator<? extends E> elements) {
                super.addAll(elements);
                return this;
            }

            @Override public ImmutableMultiset<E> build() {
                return copyOf(contents);
            }
        }
    }
    public static abstract class ImmutableMultimap<K, V>
            implements Multimap<K, V>, Serializable {


        public static <K, V> ImmutableMultimap<K, V> of() {
            return ImmutableListMultimap.of();
        }

        public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1) {
            return ImmutableListMultimap.of(k1, v1);
        }


        public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1, K k2, V v2) {
            return ImmutableListMultimap.of(k1, v1, k2, v2);
        }

        public static <K, V> ImmutableMultimap<K, V> of(
                K k1, V v1, K k2, V v2, K k3, V v3) {
            return ImmutableListMultimap.of(k1, v1, k2, v2, k3, v3);
        }


        public static <K, V> ImmutableMultimap<K, V> of(
                K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {
            return ImmutableListMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4);
        }

        public static <K, V> ImmutableMultimap<K, V> of(
                K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {
            return ImmutableListMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5);
        }


        public static <K, V> Builder<K, V> builder() {
            return new Builder<K, V>();
        }


        private static class BuilderMultimap<K, V> extends AbstractMultimap<K, V> {
            BuilderMultimap() {
                super(new LinkedHashMap<K, Collection<V>>());
            }
            @Override Collection<V> createCollection() {
                return Lists.newArrayList();
            }
            private static final long serialVersionUID = 0;
        }


        private static class SortedKeyBuilderMultimap<K, V>
                extends AbstractMultimap<K, V> {
            SortedKeyBuilderMultimap(
                    Comparator<? super K> keyComparator, Multimap<K, V> multimap) {
                super(new TreeMap<K, Collection<V>>(keyComparator));
                putAll(multimap);
            }
            @Override Collection<V> createCollection() {
                return Lists.newArrayList();
            }
            private static final long serialVersionUID = 0;
        }


        public static class Builder<K, V> {
            Multimap<K, V> builderMultimap = new BuilderMultimap<K, V>();
            Comparator<? super V> valueComparator;


            public Builder() {}


            public Builder<K, V> put(K key, V value) {
                builderMultimap.put(checkNotNull(key), checkNotNull(value));
                return this;
            }

            public Builder<K, V> putAll(K key, Iterable<? extends V> values) {
                Collection<V> valueList = builderMultimap.get(checkNotNull(key));
                for (V value : values) {
                    valueList.add(checkNotNull(value));
                }
                return this;
            }

            public Builder<K, V> putAll(K key, V... values) {
                return putAll(key, Arrays.asList(values));
            }


            public Builder<K, V> putAll(Multimap<? extends K, ? extends V> multimap) {
                for (Map.Entry<? extends K, ? extends Collection<? extends V>> entry
                        : multimap.asMap().entrySet()) {
                    putAll(entry.getKey(), entry.getValue());
                }
                return this;
            }

            @Beta
            public Builder<K, V> orderKeysBy(Comparator<? super K> keyComparator) {
                builderMultimap = new SortedKeyBuilderMultimap<K, V>(
                        checkNotNull(keyComparator), builderMultimap);
                return this;
            }

            @Beta
            public Builder<K, V> orderValuesBy(Comparator<? super V> valueComparator) {
                this.valueComparator = checkNotNull(valueComparator);
                return this;
            }

            public ImmutableMultimap<K, V> build() {
                if (valueComparator != null) {
                    for (Collection<V> values : builderMultimap.asMap().values()) {
                        List<V> list = (List <V>) values;
                        Collections.sort(list, valueComparator);
                    }
                }
                return copyOf(builderMultimap);
            }
        }

        public static <K, V> ImmutableMultimap<K, V> copyOf(
                Multimap<? extends K, ? extends V> multimap) {
            if (multimap instanceof ImmutableMultimap) {
                @SuppressWarnings("unchecked") // safe since multimap is not writable
                        ImmutableMultimap<K, V> kvMultimap
                        = (ImmutableMultimap<K, V>) multimap;
                if (!kvMultimap.isPartialView()) {
                    return kvMultimap;
                }
            }
            return ImmutableListMultimap.copyOf(multimap);
        }

        final transient ImmutableMap<K, ? extends ImmutableCollection<V>> map;
        final transient int size;

        // These constants allow the deserialization code to set final fields. This
        // holder class makes sure they are not initialized unless an instance is
        // deserialized.
        @GwtIncompatible("java serialization is not supported")
        static class FieldSettersHolder {
            // Eclipse doesn't like the raw ImmutableMultimap
            @SuppressWarnings("unchecked")
            static final Serialization.FieldSetter<ImmutableMultimap>
                    MAP_FIELD_SETTER = Serialization.getFieldSetter(
                    ImmutableMultimap.class, "map");
            // Eclipse doesn't like the raw ImmutableMultimap
            @SuppressWarnings("unchecked")
            static final Serialization.FieldSetter<ImmutableMultimap>
                    SIZE_FIELD_SETTER = Serialization.getFieldSetter(
                    ImmutableMultimap.class, "size");
        }

        ImmutableMultimap(ImmutableMap<K, ? extends ImmutableCollection<V>> map,
                          int size) {
            this.map = map;
            this.size = size;
        }


        public ImmutableCollection<V> removeAll(Object key) {
            throw new UnsupportedOperationException();
        }


        public ImmutableCollection<V> replaceValues(K key,
                                                    Iterable<? extends V> values) {
            throw new UnsupportedOperationException();
        }


        public void clear() {
            throw new UnsupportedOperationException();
        }


        public abstract ImmutableCollection<V> get(K key);

        public boolean put(K key, V value) {
            throw new UnsupportedOperationException();
        }


        public boolean putAll(K key, Iterable<? extends V> values) {
            throw new UnsupportedOperationException();
        }

        public boolean putAll(Multimap<? extends K, ? extends V> multimap) {
            throw new UnsupportedOperationException();
        }

        public boolean remove(Object key, Object value) {
            throw new UnsupportedOperationException();
        }

        boolean isPartialView(){
            return map.isPartialView();
        }

        // accessors

        public boolean containsEntry(@Nullable Object key, @Nullable Object value) {
            Collection<V> values = map.get(key);
            return values != null && values.contains(value);
        }

        public boolean containsKey(@Nullable Object key) {
            return map.containsKey(key);
        }

        public boolean containsValue(@Nullable Object value) {
            for (Collection<V> valueCollection : map.values()) {
                if (valueCollection.contains(value)) {
                    return true;
                }
            }
            return false;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        public int size() {
            return size;
        }

        @Override public boolean equals(@Nullable Object object) {
            if (object instanceof Multimap) {
                Multimap<?, ?> that = (Multimap<?, ?>) object;
                return this.map.equals(that.asMap());
            }
            return false;
        }

        @Override public int hashCode() {
            return map.hashCode();
        }

        @Override public String toString() {
            return map.toString();
        }

        public ImmutableSet<K> keySet() {
            return map.keySet();
        }


        @SuppressWarnings("unchecked") // a widening cast
        public ImmutableMap<K, Collection<V>> asMap() {
            return (ImmutableMap) map;
        }

        private transient ImmutableCollection<Map.Entry<K, V>> entries;

        public ImmutableCollection<Map.Entry<K, V>> entries() {
            ImmutableCollection<Map.Entry<K, V>> result = entries;
            return (result == null)
                    ? (entries = new EntryCollection<K, V>(this)) : result;
        }

        private static class EntryCollection<K, V>
                extends ImmutableCollection<Map.Entry<K, V>> {
            final ImmutableMultimap<K, V> multimap;

            EntryCollection(ImmutableMultimap<K, V> multimap) {
                this.multimap = multimap;
            }

            @Override public UnmodifiableIterator<Map.Entry<K, V>> iterator() {
                final Iterator<? extends Map.Entry<K, ? extends ImmutableCollection<V>>>
                        mapIterator = this.multimap.map.entrySet().iterator();

                return new UnmodifiableIterator<Map.Entry<K, V>>() {
                    K key;
                    Iterator<V> valueIterator;

                    public boolean hasNext() {
                        return (key != null && valueIterator.hasNext())
                                || mapIterator.hasNext();
                    }

                    public Map.Entry<K, V> next() {
                        if (key == null || !valueIterator.hasNext()) {
                            Map.Entry<K, ? extends ImmutableCollection<V>> entry
                                    = mapIterator.next();
                            key = entry.getKey();
                            valueIterator = entry.getValue().iterator();
                        }
                        return Maps.immutableEntry(key, valueIterator.next());
                    }
                };
            }

            @Override boolean isPartialView() {
                return multimap.isPartialView();
            }

            public int size() {
                return multimap.size();
            }

            @Override public boolean contains(Object object) {
                if (object instanceof Map.Entry) {
                    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object;
                    return multimap.containsEntry(entry.getKey(), entry.getValue());
                }
                return false;
            }

            private static final long serialVersionUID = 0;
        }

        private transient ImmutableMultiset<K> keys;

        public ImmutableMultiset<K> keys() {
            ImmutableMultiset<K> result = keys;
            return (result == null) ? (keys = createKeys()) : result;
        }

        private ImmutableMultiset<K> createKeys() {
            ImmutableMultiset.Builder<K> builder = ImmutableMultiset.builder();
            for (Map.Entry<K, ? extends ImmutableCollection<V>> entry
                    : map.entrySet()) {
                builder.addCopies(entry.getKey(), entry.getValue().size());
            }
            return builder.build();
        }

        private transient ImmutableCollection<V> values;

        public ImmutableCollection<V> values() {
            ImmutableCollection<V> result = values;
            return (result == null) ? (values = new Values<V>(this)) : result;
        }

        private static class Values<V> extends ImmutableCollection<V> {
            final ImmutableMultimap<?, V> multimap;

            Values(ImmutableMultimap<?, V> multimap) {
                this.multimap = multimap;
            }

            @Override public UnmodifiableIterator<V> iterator() {
                final Iterator<? extends Map.Entry<?, V>> entryIterator
                        = multimap.entries().iterator();
                return new UnmodifiableIterator<V>() {
                    public boolean hasNext() {
                        return entryIterator.hasNext();
                    }
                    public V next() {
                        return entryIterator.next().getValue();
                    }
                };
            }

            public int size() {
                return multimap.size();
            }

            @Override boolean isPartialView() {
                return true;
            }

            private static final long serialVersionUID = 0;
        }

        private static final long serialVersionUID = 0;
    }
    public interface SetMultimap<K, V> extends Multimap<K, V> {

        Set<V> get(@Nullable K key);

        Set<V> removeAll(@Nullable Object key);

        Set<V> replaceValues(K key, Iterable<? extends V> values);

        Set<Map.Entry<K, V>> entries();

        Map<K, Collection<V>> asMap();

        boolean equals(@Nullable Object obj);
    }
    public interface SortedSetMultimap<K, V> extends SetMultimap<K, V> {
        // Following Javadoc copied from Multimap.

        SortedSet<V> get(@Nullable K key);


        SortedSet<V> removeAll(@Nullable Object key);


        SortedSet<V> replaceValues(K key, Iterable<? extends V> values);

        Map<K, Collection<V>> asMap();

        Comparator<? super V> valueComparator();
    }
    public interface ListMultimap<K, V> extends Multimap<K, V> {

        List<V> get(@Nullable K key);

        List<V> removeAll(@Nullable Object key);

        List<V> replaceValues(K key, Iterable<? extends V> values);

        Map<K, Collection<V>> asMap();

        boolean equals(@Nullable Object obj);
    }
    static final class Synchronized {
        private Synchronized() {}

        static class SynchronizedObject implements Serializable {
            final Object delegate;
            final Object mutex;

            SynchronizedObject(Object delegate, @Nullable Object mutex) {
                this.delegate = checkNotNull(delegate);
                this.mutex = (mutex == null) ? this : mutex;
            }

            Object delegate() {
                return delegate;
            }

            // No equals and hashCode; see ForwardingObject for details.

            @Override public String toString() {
                synchronized (mutex) {
                    return delegate.toString();
                }
            }

            // Serialization invokes writeObject only when it's private.
            // The SynchronizedObject subclasses don't need a writeObject method since
            // they don't contain any non-transient member variables, while the
            // following writeObject() handles the SynchronizedObject members.

            @GwtIncompatible("java.io.ObjectOutputStream")
            private void writeObject(ObjectOutputStream stream) throws IOException {
                synchronized (mutex) {
                    stream.defaultWriteObject();
                }
            }

            @GwtIncompatible("not needed in emulated source")
            private static final long serialVersionUID = 0;
        }

        private static <E> Collection<E> collection(
                Collection<E> collection, @Nullable Object mutex) {
            return new SynchronizedCollection<E>(collection, mutex);
        }

        @VisibleForTesting static class SynchronizedCollection<E>
                extends SynchronizedObject implements Collection<E> {
            private SynchronizedCollection(
                    Collection<E> delegate, @Nullable Object mutex) {
                super(delegate, mutex);
            }

            @SuppressWarnings("unchecked")
            @Override Collection<E> delegate() {
                return (Collection<E>) super.delegate();
            }

            public boolean add(E e) {
                synchronized (mutex) {
                    return delegate().add(e);
                }
            }

            public boolean addAll(Collection<? extends E> c) {
                synchronized (mutex) {
                    return delegate().addAll(c);
                }
            }

            public void clear() {
                synchronized (mutex) {
                    delegate().clear();
                }
            }

            public boolean contains(Object o) {
                synchronized (mutex) {
                    return delegate().contains(o);
                }
            }

            public boolean containsAll(Collection<?> c) {
                synchronized (mutex) {
                    return delegate().containsAll(c);
                }
            }

            public boolean isEmpty() {
                synchronized (mutex) {
                    return delegate().isEmpty();
                }
            }

            public Iterator<E> iterator() {
                return delegate().iterator(); // manually synchronized
            }

            public boolean remove(Object o) {
                synchronized (mutex) {
                    return delegate().remove(o);
                }
            }

            public boolean removeAll(Collection<?> c) {
                synchronized (mutex) {
                    return delegate().removeAll(c);
                }
            }

            public boolean retainAll(Collection<?> c) {
                synchronized (mutex) {
                    return delegate().retainAll(c);
                }
            }

            public int size() {
                synchronized (mutex) {
                    return delegate().size();
                }
            }

            public Object[] toArray() {
                synchronized (mutex) {
                    return delegate().toArray();
                }
            }

            public <T> T[] toArray(T[] a) {
                synchronized (mutex) {
                    return delegate().toArray(a);
                }
            }

            private static final long serialVersionUID = 0;
        }

        @VisibleForTesting static <E> Set<E> set(Set<E> set, @Nullable Object mutex) {
            return new SynchronizedSet<E>(set, mutex);
        }

        static class SynchronizedSet<E>
                extends SynchronizedCollection<E> implements Set<E> {

            SynchronizedSet(Set<E> delegate, @Nullable Object mutex) {
                super(delegate, mutex);
            }

            @Override Set<E> delegate() {
                return (Set<E>) super.delegate();
            }

            @Override public boolean equals(Object o) {
                if (o == this) {
                    return true;
                }
                synchronized (mutex) {
                    return delegate().equals(o);
                }
            }

            @Override public int hashCode() {
                synchronized (mutex) {
                    return delegate().hashCode();
                }
            }

            private static final long serialVersionUID = 0;
        }

        private static <E> SortedSet<E> sortedSet(
                SortedSet<E> set, @Nullable Object mutex) {
            return new SynchronizedSortedSet<E>(set, mutex);
        }

        static class SynchronizedSortedSet<E> extends SynchronizedSet<E>
                implements SortedSet<E> {
            SynchronizedSortedSet(SortedSet<E> delegate, @Nullable Object mutex) {
                super(delegate, mutex);
            }

            @Override SortedSet<E> delegate() {
                return (SortedSet<E>) super.delegate();
            }

            public Comparator<? super E> comparator() {
                synchronized (mutex) {
                    return delegate().comparator();
                }
            }

            public SortedSet<E> subSet(E fromElement, E toElement) {
                synchronized (mutex) {
                    return sortedSet(delegate().subSet(fromElement, toElement), mutex);
                }
            }

            public SortedSet<E> headSet(E toElement) {
                synchronized (mutex) {
                    return sortedSet(delegate().headSet(toElement), mutex);
                }
            }

            public SortedSet<E> tailSet(E fromElement) {
                synchronized (mutex) {
                    return sortedSet(delegate().tailSet(fromElement), mutex);
                }
            }

            public E first() {
                synchronized (mutex) {
                    return delegate().first();
                }
            }

            public E last() {
                synchronized (mutex) {
                    return delegate().last();
                }
            }

            private static final long serialVersionUID = 0;
        }

        private static <E> List<E> list(List<E> list, @Nullable Object mutex) {
            return (list instanceof RandomAccess)
                    ? new SynchronizedRandomAccessList<E>(list, mutex)
                    : new SynchronizedList<E>(list, mutex);
        }

        private static class SynchronizedList<E> extends SynchronizedCollection<E>
                implements List<E> {
            SynchronizedList(List<E> delegate, @Nullable Object mutex) {
                super(delegate, mutex);
            }

            @Override List<E> delegate() {
                return (List<E>) super.delegate();
            }

            public void add(int index, E element) {
                synchronized (mutex) {
                    delegate().add(index, element);
                }
            }

            public boolean addAll(int index, Collection<? extends E> c) {
                synchronized (mutex) {
                    return delegate().addAll(index, c);
                }
            }

            public E get(int index) {
                synchronized (mutex) {
                    return delegate().get(index);
                }
            }

            public int indexOf(Object o) {
                synchronized (mutex) {
                    return delegate().indexOf(o);
                }
            }

            public int lastIndexOf(Object o) {
                synchronized (mutex) {
                    return delegate().lastIndexOf(o);
                }
            }

            public ListIterator<E> listIterator() {
                return delegate().listIterator(); // manually synchronized
            }

            public ListIterator<E> listIterator(int index) {
                return delegate().listIterator(index); // manually synchronized
            }

            public E remove(int index) {
                synchronized (mutex) {
                    return delegate().remove(index);
                }
            }

            public E set(int index, E element) {
                synchronized (mutex) {
                    return delegate().set(index, element);
                }
            }

            public List<E> subList(int fromIndex, int toIndex) {
                synchronized (mutex) {
                    return list(delegate().subList(fromIndex, toIndex), mutex);
                }
            }

            @Override public boolean equals(Object o) {
                if (o == this) {
                    return true;
                }
                synchronized (mutex) {
                    return delegate().equals(o);
                }
            }

            @Override public int hashCode() {
                synchronized (mutex) {
                    return delegate().hashCode();
                }
            }

            private static final long serialVersionUID = 0;
        }

        private static class SynchronizedRandomAccessList<E>
                extends SynchronizedList<E> implements RandomAccess {
            SynchronizedRandomAccessList(List<E> list, @Nullable Object mutex) {
                super(list, mutex);
            }
            private static final long serialVersionUID = 0;
        }

        static <E> Multiset<E> multiset(
                Multiset<E> multiset, @Nullable Object mutex) {
            return new SynchronizedMultiset<E>(multiset, mutex);
        }

        private static class SynchronizedMultiset<E> extends SynchronizedCollection<E>
                implements Multiset<E> {
            transient Set<E> elementSet;
            transient Set<Entry<E>> entrySet;

            SynchronizedMultiset(Multiset<E> delegate, @Nullable Object mutex) {
                super(delegate, mutex);
            }

            @Override Multiset<E> delegate() {
                return (Multiset<E>) super.delegate();
            }

            public int count(Object o) {
                synchronized (mutex) {
                    return delegate().count(o);
                }
            }

            public int add(E e, int n) {
                synchronized (mutex) {
                    return delegate().add(e, n);
                }
            }

            public int remove(Object o, int n) {
                synchronized (mutex) {
                    return delegate().remove(o, n);
                }
            }

            public int setCount(E element, int count) {
                synchronized (mutex) {
                    return delegate().setCount(element, count);
                }
            }

            public boolean setCount(E element, int oldCount, int newCount) {
                synchronized (mutex) {
                    return delegate().setCount(element, oldCount, newCount);
                }
            }

            public Set<E> elementSet() {
                synchronized (mutex) {
                    if (elementSet == null) {
                        elementSet = typePreservingSet(delegate().elementSet(), mutex);
                    }
                    return elementSet;
                }
            }

            public Set<Entry<E>> entrySet() {
                synchronized (mutex) {
                    if (entrySet == null) {
                        entrySet = typePreservingSet(delegate().entrySet(), mutex);
                    }
                    return entrySet;
                }
            }

            @Override public boolean equals(Object o) {
                if (o == this) {
                    return true;
                }
                synchronized (mutex) {
                    return delegate().equals(o);
                }
            }

            @Override public int hashCode() {
                synchronized (mutex) {
                    return delegate().hashCode();
                }
            }

            private static final long serialVersionUID = 0;
        }

        static <K, V> Multimap<K, V> multimap(
                Multimap<K, V> multimap, @Nullable Object mutex) {
            return new SynchronizedMultimap<K, V>(multimap, mutex);
        }

        private static class SynchronizedMultimap<K, V> extends SynchronizedObject
                implements Multimap<K, V> {
            transient Set<K> keySet;
            transient Collection<V> valuesCollection;
            transient Collection<Map.Entry<K, V>> entries;
            transient Map<K, Collection<V>> asMap;
            transient Multiset<K> keys;

            @SuppressWarnings("unchecked")
            @Override Multimap<K, V> delegate() {
                return (Multimap<K, V>) super.delegate();
            }

            SynchronizedMultimap(Multimap<K, V> delegate, @Nullable Object mutex) {
                super(delegate, mutex);
            }

            public int size() {
                synchronized (mutex) {
                    return delegate().size();
                }
            }

            public boolean isEmpty() {
                synchronized (mutex) {
                    return delegate().isEmpty();
                }
            }

            public boolean containsKey(Object key) {
                synchronized (mutex) {
                    return delegate().containsKey(key);
                }
            }

            public boolean containsValue(Object value) {
                synchronized (mutex) {
                    return delegate().containsValue(value);
                }
            }

            public boolean containsEntry(Object key, Object value) {
                synchronized (mutex) {
                    return delegate().containsEntry(key, value);
                }
            }

            public Collection<V> get(K key) {
                synchronized (mutex) {
                    return typePreservingCollection(delegate().get(key), mutex);
                }
            }

            public boolean put(K key, V value) {
                synchronized (mutex) {
                    return delegate().put(key, value);
                }
            }

            public boolean putAll(K key, Iterable<? extends V> values) {
                synchronized (mutex) {
                    return delegate().putAll(key, values);
                }
            }

            public boolean putAll(Multimap<? extends K, ? extends V> multimap) {
                synchronized (mutex) {
                    return delegate().putAll(multimap);
                }
            }

            public Collection<V> replaceValues(K key, Iterable<? extends V> values) {
                synchronized (mutex) {
                    return delegate().replaceValues(key, values); // copy not synchronized
                }
            }

            public boolean remove(Object key, Object value) {
                synchronized (mutex) {
                    return delegate().remove(key, value);
                }
            }

            public Collection<V> removeAll(Object key) {
                synchronized (mutex) {
                    return delegate().removeAll(key); // copy not synchronized
                }
            }

            public void clear() {
                synchronized (mutex) {
                    delegate().clear();
                }
            }

            public Set<K> keySet() {
                synchronized (mutex) {
                    if (keySet == null) {
                        keySet = typePreservingSet(delegate().keySet(), mutex);
                    }
                    return keySet;
                }
            }

            public Collection<V> values() {
                synchronized (mutex) {
                    if (valuesCollection == null) {
                        valuesCollection = collection(delegate().values(), mutex);
                    }
                    return valuesCollection;
                }
            }

            public Collection<Map.Entry<K, V>> entries() {
                synchronized (mutex) {
                    if (entries == null) {
                        entries = typePreservingCollection(delegate().entries(), mutex);
                    }
                    return entries;
                }
            }

            public Map<K, Collection<V>> asMap() {
                synchronized (mutex) {
                    if (asMap == null) {
                        asMap = new SynchronizedAsMap<K, V>(delegate().asMap(), mutex);
                    }
                    return asMap;
                }
            }

            public Multiset<K> keys() {
                synchronized (mutex) {
                    if (keys == null) {
                        keys = multiset(delegate().keys(), mutex);
                    }
                    return keys;
                }
            }

            @Override public boolean equals(Object o) {
                if (o == this) {
                    return true;
                }
                synchronized (mutex) {
                    return delegate().equals(o);
                }
            }

            @Override public int hashCode() {
                synchronized (mutex) {
                    return delegate().hashCode();
                }
            }

            private static final long serialVersionUID = 0;
        }

        static <K, V> ListMultimap<K, V> listMultimap(
                ListMultimap<K, V> multimap, @Nullable Object mutex) {
            return new SynchronizedListMultimap<K, V>(multimap, mutex);
        }

        private static class SynchronizedListMultimap<K, V>
                extends SynchronizedMultimap<K, V> implements ListMultimap<K, V> {
            SynchronizedListMultimap(
                    ListMultimap<K, V> delegate, @Nullable Object mutex) {
                super(delegate, mutex);
            }
            @Override ListMultimap<K, V> delegate() {
                return (ListMultimap<K, V>) super.delegate();
            }
            @Override public List<V> get(K key) {
                synchronized (mutex) {
                    return list(delegate().get(key), mutex);
                }
            }
            @Override public List<V> removeAll(Object key) {
                synchronized (mutex) {
                    return delegate().removeAll(key); // copy not synchronized
                }
            }
            @Override public List<V> replaceValues(
                    K key, Iterable<? extends V> values) {
                synchronized (mutex) {
                    return delegate().replaceValues(key, values); // copy not synchronized
                }
            }
            private static final long serialVersionUID = 0;
        }

        static <K, V> SetMultimap<K, V> setMultimap(
                SetMultimap<K, V> multimap, @Nullable Object mutex) {
            return new SynchronizedSetMultimap<K, V>(multimap, mutex);
        }

        private static class SynchronizedSetMultimap<K, V>
                extends SynchronizedMultimap<K, V> implements SetMultimap<K, V> {
            transient Set<Map.Entry<K, V>> entrySet;

            SynchronizedSetMultimap(
                    SetMultimap<K, V> delegate, @Nullable Object mutex) {
                super(delegate, mutex);
            }
            @Override SetMultimap<K, V> delegate() {
                return (SetMultimap<K, V>) super.delegate();
            }
            @Override public Set<V> get(K key) {
                synchronized (mutex) {
                    return set(delegate().get(key), mutex);
                }
            }
            @Override public Set<V> removeAll(Object key) {
                synchronized (mutex) {
                    return delegate().removeAll(key); // copy not synchronized
                }
            }
            @Override public Set<V> replaceValues(
                    K key, Iterable<? extends V> values) {
                synchronized (mutex) {
                    return delegate().replaceValues(key, values); // copy not synchronized
                }
            }
            @Override public Set<Map.Entry<K, V>> entries() {
                synchronized (mutex) {
                    if (entrySet == null) {
                        entrySet = set(delegate().entries(), mutex);
                    }
                    return entrySet;
                }
            }
            private static final long serialVersionUID = 0;
        }

        static <K, V> SortedSetMultimap<K, V> sortedSetMultimap(
                SortedSetMultimap<K, V> multimap, @Nullable Object mutex) {
            return new SynchronizedSortedSetMultimap<K, V>(multimap, mutex);
        }

        private static class SynchronizedSortedSetMultimap<K, V>
                extends SynchronizedSetMultimap<K, V> implements SortedSetMultimap<K, V> {
            SynchronizedSortedSetMultimap(
                    SortedSetMultimap<K, V> delegate, @Nullable Object mutex) {
                super(delegate, mutex);
            }
            @Override SortedSetMultimap<K, V> delegate() {
                return (SortedSetMultimap<K, V>) super.delegate();
            }
            @Override public SortedSet<V> get(K key) {
                synchronized (mutex) {
                    return sortedSet(delegate().get(key), mutex);
                }
            }
            @Override public SortedSet<V> removeAll(Object key) {
                synchronized (mutex) {
                    return delegate().removeAll(key); // copy not synchronized
                }
            }
            @Override public SortedSet<V> replaceValues(
                    K key, Iterable<? extends V> values) {
                synchronized (mutex) {
                    return delegate().replaceValues(key, values); // copy not synchronized
                }
            }
            public Comparator<? super V> valueComparator() {
                synchronized (mutex) {
                    return delegate().valueComparator();
                }
            }
            private static final long serialVersionUID = 0;
        }

        private static <E> Collection<E> typePreservingCollection(
                Collection<E> collection, @Nullable Object mutex) {
            if (collection instanceof SortedSet) {
                return sortedSet((SortedSet<E>) collection, mutex);
            }
            if (collection instanceof Set) {
                return set((Set<E>) collection, mutex);
            }
            if (collection instanceof List) {
                return list((List<E>) collection, mutex);
            }
            return collection(collection, mutex);
        }

        private static <E> Set<E> typePreservingSet(
                Set<E> set, @Nullable Object mutex) {
            if (set instanceof SortedSet) {
                return sortedSet((SortedSet<E>) set, mutex);
            } else {
                return set(set, mutex);
            }
        }

        private static class SynchronizedAsMapEntries<K, V>
                extends SynchronizedSet<Map.Entry<K, Collection<V>>> {
            SynchronizedAsMapEntries(
                    Set<Map.Entry<K, Collection<V>>> delegate, @Nullable Object mutex) {
                super(delegate, mutex);
            }

            @Override public Iterator<Map.Entry<K, Collection<V>>> iterator() {
                // Must be manually synchronized.
                final Iterator<Map.Entry<K, Collection<V>>> iterator = super.iterator();
                return new ForwardingIterator<Map.Entry<K, Collection<V>>>() {
                    @Override protected Iterator<Map.Entry<K, Collection<V>>> delegate() {
                        return iterator;
                    }

                    @Override public Map.Entry<K, Collection<V>> next() {
                        final Map.Entry<K, Collection<V>> entry = iterator.next();
                        return new ForwardingMapEntry<K, Collection<V>>() {
                            @Override protected Map.Entry<K, Collection<V>> delegate() {
                                return entry;
                            }
                            @Override public Collection<V> getValue() {
                                return typePreservingCollection(entry.getValue(), mutex);
                            }
                        };
                    }
                };
            }

            // See Collections.CheckedMap.CheckedEntrySet for details on attacks.

            @Override public Object[] toArray() {
                synchronized (mutex) {
                    return ObjectArrays.toArrayImpl(delegate());
                }
            }
            @Override public <T> T[] toArray(T[] array) {
                synchronized (mutex) {
                    return ObjectArrays.toArrayImpl(delegate(), array);
                }
            }
            @Override public boolean contains(Object o) {
                synchronized (mutex) {
                    return Maps.containsEntryImpl(delegate(), o);
                }
            }
            @Override public boolean containsAll(Collection<?> c) {
                synchronized (mutex) {
                    return Collections2.containsAllImpl(delegate(), c);
                }
            }
            @Override public boolean equals(Object o) {
                if (o == this) {
                    return true;
                }
                synchronized (mutex) {
                    return Sets.equalsImpl(delegate(), o);
                }
            }
            @Override public boolean remove(Object o) {
                synchronized (mutex) {
                    return Maps.removeEntryImpl(delegate(), o);
                }
            }
            @Override public boolean removeAll(Collection<?> c) {
                synchronized (mutex) {
                    return Iterators.removeAll(delegate().iterator(), c);
                }
            }
            @Override public boolean retainAll(Collection<?> c) {
                synchronized (mutex) {
                    return Iterators.retainAll(delegate().iterator(), c);
                }
            }

            private static final long serialVersionUID = 0;
        }

        @VisibleForTesting
        static <K, V> Map<K, V> map(Map<K, V> map, @Nullable Object mutex) {
            return new SynchronizedMap<K, V>(map, mutex);
        }

        private static class SynchronizedMap<K, V> extends SynchronizedObject
                implements Map<K, V> {
            transient Set<K> keySet;
            transient Collection<V> values;
            transient Set<Map.Entry<K, V>> entrySet;

            SynchronizedMap(Map<K, V> delegate, @Nullable Object mutex) {
                super(delegate, mutex);
            }

            @SuppressWarnings("unchecked")
            @Override Map<K, V> delegate() {
                return (Map<K, V>) super.delegate();
            }

            public void clear() {
                synchronized (mutex) {
                    delegate().clear();
                }
            }

            public boolean containsKey(Object key) {
                synchronized (mutex) {
                    return delegate().containsKey(key);
                }
            }

            public boolean containsValue(Object value) {
                synchronized (mutex) {
                    return delegate().containsValue(value);
                }
            }

            public Set<Map.Entry<K, V>> entrySet() {
                synchronized (mutex) {
                    if (entrySet == null) {
                        entrySet = set(delegate().entrySet(), mutex);
                    }
                    return entrySet;
                }
            }

            public V get(Object key) {
                synchronized (mutex) {
                    return delegate().get(key);
                }
            }

            public boolean isEmpty() {
                synchronized (mutex) {
                    return delegate().isEmpty();
                }
            }

            public Set<K> keySet() {
                synchronized (mutex) {
                    if (keySet == null) {
                        keySet = set(delegate().keySet(), mutex);
                    }
                    return keySet;
                }
            }

            public V put(K key, V value) {
                synchronized (mutex) {
                    return delegate().put(key, value);
                }
            }

            public void putAll(Map<? extends K, ? extends V> map) {
                synchronized (mutex) {
                    delegate().putAll(map);
                }
            }

            public V remove(Object key) {
                synchronized (mutex) {
                    return delegate().remove(key);
                }
            }

            public int size() {
                synchronized (mutex) {
                    return delegate().size();
                }
            }

            public Collection<V> values() {
                synchronized (mutex) {
                    if (values == null) {
                        values = collection(delegate().values(), mutex);
                    }
                    return values;
                }
            }

            @Override public boolean equals(Object o) {
                if (o == this) {
                    return true;
                }
                synchronized (mutex) {
                    return delegate().equals(o);
                }
            }

            @Override public int hashCode() {
                synchronized (mutex) {
                    return delegate().hashCode();
                }
            }

            private static final long serialVersionUID = 0;
        }

        static <K, V> SortedMap<K, V> sortedMap(
                SortedMap<K, V> sortedMap, @Nullable Object mutex) {
            return new SynchronizedSortedMap<K, V>(sortedMap, mutex);
        }

        static class SynchronizedSortedMap<K, V> extends SynchronizedMap<K, V>
                implements SortedMap<K, V> {

            SynchronizedSortedMap(SortedMap<K, V> delegate, @Nullable Object mutex) {
                super(delegate, mutex);
            }

            @Override SortedMap<K, V> delegate() {
                return (SortedMap<K, V>) super.delegate();
            }

            @Override public Comparator<? super K> comparator() {
                synchronized (mutex) {
                    return delegate().comparator();
                }
            }

            @Override public K firstKey() {
                synchronized (mutex) {
                    return delegate().firstKey();
                }
            }

            @Override public SortedMap<K, V> headMap(K toKey) {
                synchronized (mutex) {
                    return sortedMap(delegate().headMap(toKey), mutex);
                }
            }

            @Override public K lastKey() {
                synchronized (mutex) {
                    return delegate().lastKey();
                }
            }

            @Override public SortedMap<K, V> subMap(K fromKey, K toKey) {
                synchronized (mutex) {
                    return sortedMap(delegate().subMap(fromKey, toKey), mutex);
                }
            }

            @Override public SortedMap<K, V> tailMap(K fromKey) {
                synchronized (mutex) {
                    return sortedMap(delegate().tailMap(fromKey), mutex);
                }
            }

            private static final long serialVersionUID = 0;
        }

        static <K, V> BiMap<K, V> biMap(BiMap<K, V> bimap, @Nullable Object mutex) {
            return new SynchronizedBiMap<K, V>(bimap, mutex, null);
        }

        @VisibleForTesting static class SynchronizedBiMap<K, V>
                extends SynchronizedMap<K, V> implements BiMap<K, V>, Serializable {
            private transient Set<V> valueSet;
            private transient BiMap<V, K> inverse;

            private SynchronizedBiMap(BiMap<K, V> delegate, @Nullable Object mutex,
                                      @Nullable BiMap<V, K> inverse) {
                super(delegate, mutex);
                this.inverse = inverse;
            }

            @Override BiMap<K, V> delegate() {
                return (BiMap<K, V>) super.delegate();
            }

            @Override public Set<V> values() {
                synchronized (mutex) {
                    if (valueSet == null) {
                        valueSet = set(delegate().values(), mutex);
                    }
                    return valueSet;
                }
            }

            public V forcePut(K key, V value) {
                synchronized (mutex) {
                    return delegate().forcePut(key, value);
                }
            }

            public BiMap<V, K> inverse() {
                synchronized (mutex) {
                    if (inverse == null) {
                        inverse
                                = new SynchronizedBiMap<V, K>(delegate().inverse(), mutex, this);
                    }
                    return inverse;
                }
            }

            private static final long serialVersionUID = 0;
        }

        private static class SynchronizedAsMap<K, V>
                extends SynchronizedMap<K, Collection<V>> {
            transient Set<Map.Entry<K, Collection<V>>> asMapEntrySet;
            transient Collection<Collection<V>> asMapValues;

            SynchronizedAsMap(Map<K, Collection<V>> delegate, @Nullable Object mutex) {
                super(delegate, mutex);
            }

            @Override public Collection<V> get(Object key) {
                synchronized (mutex) {
                    Collection<V> collection = super.get(key);
                    return (collection == null) ? null
                            : typePreservingCollection(collection, mutex);
                }
            }

            @Override public Set<Map.Entry<K, Collection<V>>> entrySet() {
                synchronized (mutex) {
                    if (asMapEntrySet == null) {
                        asMapEntrySet = new SynchronizedAsMapEntries<K, V>(
                                delegate().entrySet(), mutex);
                    }
                    return asMapEntrySet;
                }
            }

            @Override public Collection<Collection<V>> values() {
                synchronized (mutex) {
                    if (asMapValues == null) {
                        asMapValues
                                = new SynchronizedAsMapValues<V>(delegate().values(), mutex);
                    }
                    return asMapValues;
                }
            }

            @Override public boolean containsValue(Object o) {
                // values() and its contains() method are both synchronized.
                return values().contains(o);
            }

            private static final long serialVersionUID = 0;
        }

        private static class SynchronizedAsMapValues<V>
                extends SynchronizedCollection<Collection<V>> {
            SynchronizedAsMapValues(
                    Collection<Collection<V>> delegate, @Nullable Object mutex) {
                super(delegate, mutex);
            }

            @Override public Iterator<Collection<V>> iterator() {
                // Must be manually synchronized.
                final Iterator<Collection<V>> iterator = super.iterator();
                return new ForwardingIterator<Collection<V>>() {
                    @Override protected Iterator<Collection<V>> delegate() {
                        return iterator;
                    }
                    @Override public Collection<V> next() {
                        return typePreservingCollection(iterator.next(), mutex);
                    }
                };
            }

            private static final long serialVersionUID = 0;
        }
    }
    public static abstract class ForwardingIterator<T>
            extends ForwardingObject implements Iterator<T> {

        protected ForwardingIterator() {}

        @Override protected abstract Iterator<T> delegate();

        public boolean hasNext() {
            return delegate().hasNext();
        }

        public T next() {
            return delegate().next();
        }

        public void remove() {
            delegate().remove();
        }
    }
    public static final class Maps {
        private Maps() {}

        public static <K, V> HashMap<K, V> newHashMap() {
            return new HashMap<K, V>();
        }

        public static <K, V> HashMap<K, V> newHashMapWithExpectedSize(
                int expectedSize) {

            return new HashMap<K, V>(capacity(expectedSize));
        }

        static int capacity(int expectedSize) {
            checkArgument(expectedSize >= 0);
            // Avoid the int overflow if expectedSize > (Integer.MAX_VALUE / 2)
            return Ints.saturatedCast(Math.max(expectedSize * 2L, 16L));
        }

        public static <K, V> HashMap<K, V> newHashMap(
                Map<? extends K, ? extends V> map) {
            return new HashMap<K, V>(map);
        }

        public static <K, V> LinkedHashMap<K, V> newLinkedHashMap() {
            return new LinkedHashMap<K, V>();
        }

        public static <K, V> LinkedHashMap<K, V> newLinkedHashMap(
                Map<? extends K, ? extends V> map) {
            return new LinkedHashMap<K, V>(map);
        }

        public static <K, V> ConcurrentMap<K, V> newConcurrentMap() {
            return new MapMaker().<K, V>makeMap();
        }

        @SuppressWarnings("unchecked") // eclipse doesn't like the raw Comparable
        public static <K extends Comparable, V> TreeMap<K, V> newTreeMap() {
            return new TreeMap<K, V>();
        }

        public static <K, V> TreeMap<K, V> newTreeMap(SortedMap<K, ? extends V> map) {
            return new TreeMap<K, V>(map);
        }

        public static <C, K extends C, V> TreeMap<K, V> newTreeMap(
                @Nullable Comparator<C> comparator) {

            return new TreeMap<K, V>(comparator);
        }

        public static <K extends Enum<K>, V> EnumMap<K, V> newEnumMap(Class<K> type) {
            return new EnumMap<K, V>(checkNotNull(type));
        }

        public static <K extends Enum<K>, V> EnumMap<K, V> newEnumMap(
                Map<K, ? extends V> map) {
            return new EnumMap<K, V>(map);
        }

        public static <K, V> IdentityHashMap<K, V> newIdentityHashMap() {
            return new IdentityHashMap<K, V>();
        }

        public static <K, V> BiMap<K, V> synchronizedBiMap(BiMap<K, V> bimap) {
            return Synchronized.biMap(bimap, null);
        }

        public static <K, V> MapDifference<K, V> difference(
                Map<? extends K, ? extends V> left, Map<? extends K, ? extends V> right) {
            Map<K, V> onlyOnLeft = newHashMap();
            Map<K, V> onlyOnRight = new HashMap<K, V>(right); // will whittle it down
            Map<K, V> onBoth = newHashMap();
            Map<K, MapDifference.ValueDifference<V>> differences = newHashMap();
            boolean eq = true;

            for (Map.Entry<? extends K, ? extends V> entry : left.entrySet()) {
                K leftKey = entry.getKey();
                V leftValue = entry.getValue();
                if (right.containsKey(leftKey)) {
                    V rightValue = onlyOnRight.remove(leftKey);
                    if (Objects.equal(leftValue, rightValue)) {
                        onBoth.put(leftKey, leftValue);
                    } else {
                        eq = false;
                        differences.put(
                                leftKey, new ValueDifferenceImpl<V>(leftValue, rightValue));
                    }
                } else {
                    eq = false;
                    onlyOnLeft.put(leftKey, leftValue);
                }
            }

            boolean areEqual = eq && onlyOnRight.isEmpty();
            return mapDifference(
                    areEqual, onlyOnLeft, onlyOnRight, onBoth, differences);
        }

        private static <K, V> MapDifference<K, V> mapDifference(boolean areEqual,
                                                                Map<K, V> onlyOnLeft, Map<K, V> onlyOnRight, Map<K, V> onBoth,
                                                                Map<K, MapDifference.ValueDifference<V>> differences) {
            return new MapDifferenceImpl<K, V>(areEqual,
                    Collections.unmodifiableMap(onlyOnLeft),
                    Collections.unmodifiableMap(onlyOnRight),
                    Collections.unmodifiableMap(onBoth),
                    Collections.unmodifiableMap(differences));
        }

        static class MapDifferenceImpl<K, V> implements MapDifference<K, V> {
            final boolean areEqual;
            final Map<K, V> onlyOnLeft;
            final Map<K, V> onlyOnRight;
            final Map<K, V> onBoth;
            final Map<K, ValueDifference<V>> differences;

            MapDifferenceImpl(boolean areEqual, Map<K, V> onlyOnLeft,
                              Map<K, V> onlyOnRight, Map<K, V> onBoth,
                              Map<K, ValueDifference<V>> differences) {
                this.areEqual = areEqual;
                this.onlyOnLeft = onlyOnLeft;
                this.onlyOnRight = onlyOnRight;
                this.onBoth = onBoth;
                this.differences = differences;
            }

            @Override
            public boolean areEqual() {
                return areEqual;
            }

            @Override
            public Map<K, V> entriesOnlyOnLeft() {
                return onlyOnLeft;
            }

            @Override
            public Map<K, V> entriesOnlyOnRight() {
                return onlyOnRight;
            }

            @Override
            public Map<K, V> entriesInCommon() {
                return onBoth;
            }

            @Override
            public Map<K, ValueDifference<V>> entriesDiffering() {
                return differences;
            }

            @Override public boolean equals(Object object) {
                if (object == this) {
                    return true;
                }
                if (object instanceof MapDifference) {
                    MapDifference<?, ?> other = (MapDifference<?, ?>) object;
                    return entriesOnlyOnLeft().equals(other.entriesOnlyOnLeft())
                            && entriesOnlyOnRight().equals(other.entriesOnlyOnRight())
                            && entriesInCommon().equals(other.entriesInCommon())
                            && entriesDiffering().equals(other.entriesDiffering());
                }
                return false;
            }

            @Override public int hashCode() {
                return Objects.hashCode(entriesOnlyOnLeft(), entriesOnlyOnRight(),
                        entriesInCommon(), entriesDiffering());
            }

            @Override public String toString() {
                if (areEqual) {
                    return "equal";
                }

                StringBuilder result = new StringBuilder("not equal");
                if (!onlyOnLeft.isEmpty()) {
                    result.append(": only on left=").append(onlyOnLeft);
                }
                if (!onlyOnRight.isEmpty()) {
                    result.append(": only on right=").append(onlyOnRight);
                }
                if (!differences.isEmpty()) {
                    result.append(": value differences=").append(differences);
                }
                return result.toString();
            }
        }

        static class ValueDifferenceImpl<V>
                implements MapDifference.ValueDifference<V> {
            private final V left;
            private final V right;

            ValueDifferenceImpl(@Nullable V left, @Nullable V right) {
                this.left = left;
                this.right = right;
            }

            @Override
            public V leftValue() {
                return left;
            }

            @Override
            public V rightValue() {
                return right;
            }

            @Override public boolean equals(@Nullable Object object) {
                if (object instanceof MapDifference.ValueDifference<?>) {
                    MapDifference.ValueDifference<?> that =
                            (MapDifference.ValueDifference<?>) object;
                    return Objects.equal(this.left, that.leftValue())
                            && Objects.equal(this.right, that.rightValue());
                }
                return false;
            }

            @Override public int hashCode() {
                return Objects.hashCode(left, right);
            }

            @Override public String toString() {
                return "(" + left + ", " + right + ")";
            }
        }


        public static <K, V> ImmutableMap<K, V> uniqueIndex(
                Iterable<V> values, Function<? super V, K> keyFunction) {
            checkNotNull(keyFunction);
            ImmutableMap.Builder<K, V> builder = ImmutableMap.builder();
            for (V value : values) {
                builder.put(keyFunction.apply(value), value);
            }
            return builder.build();
        }


        @GwtIncompatible("java.util.Properties")
        public static ImmutableMap<String, String> fromProperties(
                Properties properties) {
            ImmutableMap.Builder<String, String> builder = ImmutableMap.builder();

            for (Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();) {
                String key = (String) e.nextElement();
                builder.put(key, properties.getProperty(key));
            }

            return builder.build();
        }


        @GwtCompatible(serializable = true)
        public static <K, V> Map.Entry<K, V> immutableEntry(
                @Nullable K key, @Nullable V value) {
            return new ImmutableEntry<K, V>(key, value);
        }


        static <K, V> Set<Map.Entry<K, V>> unmodifiableEntrySet(
                Set<Map.Entry<K, V>> entrySet) {
            return new UnmodifiableEntrySet<K, V>(
                    Collections.unmodifiableSet(entrySet));
        }


        static <K, V> Map.Entry<K, V> unmodifiableEntry(final Map.Entry<K, V> entry) {
            checkNotNull(entry);
            return new AbstractMapEntry<K, V>() {
                @Override public K getKey() {
                    return entry.getKey();
                }

                @Override public V getValue() {
                    return entry.getValue();
                }
            };
        }


        static class UnmodifiableEntries<K, V>
                extends ForwardingCollection<Map.Entry<K, V>> {
            private final Collection<Map.Entry<K, V>> entries;

            UnmodifiableEntries(Collection<Map.Entry<K, V>> entries) {
                this.entries = entries;
            }

            @Override protected Collection<Map.Entry<K, V>> delegate() {
                return entries;
            }

            @Override public Iterator<Map.Entry<K, V>> iterator() {
                final Iterator<Map.Entry<K, V>> delegate = super.iterator();
                return new ForwardingIterator<Map.Entry<K, V>>() {
                    @Override public Map.Entry<K, V> next() {
                        return unmodifiableEntry(super.next());
                    }

                    @Override public void remove() {
                        throw new UnsupportedOperationException();
                    }

                    @Override protected Iterator<Map.Entry<K, V>> delegate() {
                        return delegate;
                    }
                };
            }

            // See java.util.Collections.UnmodifiableEntrySet for details on attacks.

            @Override public boolean add(Map.Entry<K, V> element) {
                throw new UnsupportedOperationException();
            }

            @Override public boolean addAll(
                    Collection<? extends Map.Entry<K, V>> collection) {
                throw new UnsupportedOperationException();
            }

            @Override public void clear() {
                throw new UnsupportedOperationException();
            }

            @Override public boolean remove(Object object) {
                throw new UnsupportedOperationException();
            }

            @Override public boolean removeAll(Collection<?> collection) {
                throw new UnsupportedOperationException();
            }

            @Override public boolean retainAll(Collection<?> collection) {
                throw new UnsupportedOperationException();
            }

            @Override public Object[] toArray() {
                return standardToArray();
            }

            @Override public <T> T[] toArray(T[] array) {
                return standardToArray(array);
            }
        }

        static class UnmodifiableEntrySet<K, V>
                extends UnmodifiableEntries<K, V> implements Set<Map.Entry<K, V>> {
            UnmodifiableEntrySet(Set<Map.Entry<K, V>> entries) {
                super(entries);
            }

            // See java.util.Collections.UnmodifiableEntrySet for details on attacks.

            @Override public boolean equals(@Nullable Object object) {
                return Sets.equalsImpl(this, object);
            }

            @Override public int hashCode() {
                return Sets.hashCodeImpl(this);
            }
        }

        public static <K, V> BiMap<K, V> unmodifiableBiMap(
                BiMap<? extends K, ? extends V> bimap) {
            return new UnmodifiableBiMap<K, V>(bimap, null);
        }


        private static class UnmodifiableBiMap<K, V>
                extends ForwardingMap<K, V> implements BiMap<K, V>, Serializable {
            final Map<K, V> unmodifiableMap;
            final BiMap<? extends K, ? extends V> delegate;
            transient BiMap<V, K> inverse;
            transient Set<V> values;

            UnmodifiableBiMap(BiMap<? extends K, ? extends V> delegate,
                              @Nullable BiMap<V, K> inverse) {
                unmodifiableMap = Collections.unmodifiableMap(delegate);
                this.delegate = delegate;
                this.inverse = inverse;
            }

            @Override protected Map<K, V> delegate() {
                return unmodifiableMap;
            }

            @Override
            public V forcePut(K key, V value) {
                throw new UnsupportedOperationException();
            }

            @Override
            public BiMap<V, K> inverse() {
                BiMap<V, K> result = inverse;
                return (result == null)
                        ? inverse = new UnmodifiableBiMap<V, K>(delegate.inverse(), this)
                        : result;
            }

            @Override public Set<V> values() {
                Set<V> result = values;
                return (result == null)
                        ? values = Collections.unmodifiableSet(delegate.values())
                        : result;
            }

            private static final long serialVersionUID = 0;
        }

        public static <K, V1, V2> Map<K, V2> transformValues(
                Map<K, V1> fromMap, final Function<? super V1, V2> function) {
            checkNotNull(function);
            EntryTransformer<K, V1, V2> transformer =
                    new EntryTransformer<K, V1, V2>() {
                        @Override
                        public V2 transformEntry(K key, V1 value) {
                            return function.apply(value);
                        }
                    };
            return transformEntries(fromMap, transformer);
        }

        @Beta
        public static <K, V1, V2> Map<K, V2> transformEntries(
                Map<K, V1> fromMap,
                EntryTransformer<? super K, ? super V1, V2> transformer) {
            return new TransformedEntriesMap<K, V1, V2>(fromMap, transformer);
        }

        @Beta
        public interface EntryTransformer<K, V1, V2> {

            V2 transformEntry(@Nullable K key, @Nullable V1 value);
        }

        static class TransformedEntriesMap<K, V1, V2>
                extends AbstractMap<K, V2> {
            final Map<K, V1> fromMap;
            final EntryTransformer<? super K, ? super V1, V2> transformer;

            TransformedEntriesMap(
                    Map<K, V1> fromMap,
                    EntryTransformer<? super K, ? super V1, V2> transformer) {
                this.fromMap = checkNotNull(fromMap);
                this.transformer = checkNotNull(transformer);
            }

            @Override public int size() {
                return fromMap.size();
            }

            @Override public boolean containsKey(Object key) {
                return fromMap.containsKey(key);
            }

            // safe as long as the user followed the <b>Warning</b> in the javadoc
            @SuppressWarnings("unchecked")
            @Override public V2 get(Object key) {
                V1 value = fromMap.get(key);
                return (value != null || fromMap.containsKey(key))
                        ? transformer.transformEntry((K) key, value)
                        : null;
            }

            // safe as long as the user followed the <b>Warning</b> in the javadoc
            @SuppressWarnings("unchecked")
            @Override public V2 remove(Object key) {
                return fromMap.containsKey(key)
                        ? transformer.transformEntry((K) key, fromMap.remove(key))
                        : null;
            }

            @Override public void clear() {
                fromMap.clear();
            }

            EntrySet entrySet;

            @Override public Set<Entry<K, V2>> entrySet() {
                EntrySet result = entrySet;
                if (result == null) {
                    entrySet = result = new EntrySet();
                }
                return result;
            }

            class EntrySet extends AbstractSet<Entry<K, V2>> {
                @Override public int size() {
                    return TransformedEntriesMap.this.size();
                }

                @Override public Iterator<Entry<K, V2>> iterator() {
                    final Iterator<Entry<K, V1>> mapIterator =
                            fromMap.entrySet().iterator();

                    return new Iterator<Entry<K, V2>>() {
                        @Override
                        public boolean hasNext() {
                            return mapIterator.hasNext();
                        }

                        @Override
                        public Entry<K, V2> next() {
                            final Entry<K, V1> entry = mapIterator.next();
                            return new AbstractMapEntry<K, V2>() {
                                @Override public K getKey() {
                                    return entry.getKey();
                                }

                                @Override public V2 getValue() {
                                    return transformer.transformEntry(
                                            entry.getKey(), entry.getValue());
                                }
                            };
                        }

                        @Override
                        public void remove() {
                            mapIterator.remove();
                        }
                    };
                }

                @Override public void clear() {
                    fromMap.clear();
                }

                @Override public boolean contains(Object o) {
                    if (!(o instanceof Entry)) {
                        return false;
                    }
                    Entry<?, ?> entry = (Entry<?, ?>) o;
                    Object entryKey = entry.getKey();
                    Object entryValue = entry.getValue();
                    V2 mapValue = TransformedEntriesMap.this.get(entryKey);
                    if (mapValue != null) {
                        return mapValue.equals(entryValue);
                    }
                    return entryValue == null && containsKey(entryKey);
                }

                @Override public boolean remove(Object o) {
                    if (contains(o)) {
                        Entry<?, ?> entry = (Entry<?, ?>) o;
                        Object key = entry.getKey();
                        fromMap.remove(key);
                        return true;
                    }
                    return false;
                }
            }
        }

        public static <K, V> Map<K, V> filterKeys(
                Map<K, V> unfiltered, final Predicate<? super K> keyPredicate) {
            checkNotNull(keyPredicate);
            Predicate<Map.Entry<K, V>> entryPredicate =
                    new Predicate<Map.Entry<K, V>>() {
                        @Override
                        public boolean apply(Map.Entry<K, V> input) {
                            return keyPredicate.apply(input.getKey());
                        }
                    };
            return (unfiltered instanceof AbstractFilteredMap)
                    ? filterFiltered((AbstractFilteredMap<K, V>) unfiltered, entryPredicate)
                    : new FilteredKeyMap<K, V>(
                    checkNotNull(unfiltered), keyPredicate, entryPredicate);
        }

        public static <K, V> Map<K, V> filterValues(
                Map<K, V> unfiltered, final Predicate<? super V> valuePredicate) {
            checkNotNull(valuePredicate);
            Predicate<Map.Entry<K, V>> entryPredicate =
                    new Predicate<Map.Entry<K, V>>() {
                        @Override
                        public boolean apply(Map.Entry<K, V> input) {
                            return valuePredicate.apply(input.getValue());
                        }
                    };
            return filterEntries(unfiltered, entryPredicate);
        }

        public static <K, V> Map<K, V> filterEntries(
                Map<K, V> unfiltered, Predicate<? super Map.Entry<K, V>> entryPredicate) {
            checkNotNull(entryPredicate);
            return (unfiltered instanceof AbstractFilteredMap)
                    ? filterFiltered((AbstractFilteredMap<K, V>) unfiltered, entryPredicate)
                    : new FilteredEntryMap<K, V>(checkNotNull(unfiltered), entryPredicate);
        }


        private static <K, V> Map<K, V> filterFiltered(AbstractFilteredMap<K, V> map,
                                                       Predicate<? super Map.Entry<K, V>> entryPredicate) {
            Predicate<Map.Entry<K, V>> predicate =
                    Predicates.and(map.predicate, entryPredicate);
            return new FilteredEntryMap<K, V>(map.unfiltered, predicate);
        }

        private abstract static class AbstractFilteredMap<K, V>
                extends AbstractMap<K, V> {
            final Map<K, V> unfiltered;
            final Predicate<? super Entry<K, V>> predicate;

            AbstractFilteredMap(
                    Map<K, V> unfiltered, Predicate<? super Entry<K, V>> predicate) {
                this.unfiltered = unfiltered;
                this.predicate = predicate;
            }

            boolean apply(Object key, V value) {
                // This method is called only when the key is in the map, implying that
                // key is a K.
                @SuppressWarnings("unchecked")
                K k = (K) key;
                return predicate.apply(Maps.immutableEntry(k, value));
            }

            @Override public V put(K key, V value) {
                checkArgument(apply(key, value));
                return unfiltered.put(key, value);
            }

            @Override public void putAll(Map<? extends K, ? extends V> map) {
                for (Entry<? extends K, ? extends V> entry : map.entrySet()) {
                    checkArgument(apply(entry.getKey(), entry.getValue()));
                }
                unfiltered.putAll(map);
            }

            @Override public boolean containsKey(Object key) {
                return unfiltered.containsKey(key) && apply(key, unfiltered.get(key));
            }

            @Override public V get(Object key) {
                V value = unfiltered.get(key);
                return ((value != null) && apply(key, value)) ? value : null;
            }

            @Override public boolean isEmpty() {
                return entrySet().isEmpty();
            }

            @Override public V remove(Object key) {
                return containsKey(key) ? unfiltered.remove(key) : null;
            }

            Collection<V> values;

            @Override public Collection<V> values() {
                Collection<V> result = values;
                return (result == null) ? values = new Values() : result;
            }

            class Values extends AbstractCollection<V> {
                @Override public Iterator<V> iterator() {
                    final Iterator<Entry<K, V>> entryIterator = entrySet().iterator();
                    return new UnmodifiableIterator<V>() {
                        @Override
                        public boolean hasNext() {
                            return entryIterator.hasNext();
                        }

                        @Override
                        public V next() {
                            return entryIterator.next().getValue();
                        }
                    };
                }

                @Override public int size() {
                    return entrySet().size();
                }

                @Override public void clear() {
                    entrySet().clear();
                }

                @Override public boolean isEmpty() {
                    return entrySet().isEmpty();
                }

                @Override public boolean remove(Object o) {
                    Iterator<Entry<K, V>> iterator = unfiltered.entrySet().iterator();
                    while (iterator.hasNext()) {
                        Entry<K, V> entry = iterator.next();
                        if (Objects.equal(o, entry.getValue()) && predicate.apply(entry)) {
                            iterator.remove();
                            return true;
                        }
                    }
                    return false;
                }

                @Override public boolean removeAll(Collection<?> collection) {
                    checkNotNull(collection);
                    boolean changed = false;
                    Iterator<Entry<K, V>> iterator = unfiltered.entrySet().iterator();
                    while (iterator.hasNext()) {
                        Entry<K, V> entry = iterator.next();
                        if (collection.contains(entry.getValue()) && predicate.apply(entry)) {
                            iterator.remove();
                            changed = true;
                        }
                    }
                    return changed;
                }

                @Override public boolean retainAll(Collection<?> collection) {
                    checkNotNull(collection);
                    boolean changed = false;
                    Iterator<Entry<K, V>> iterator = unfiltered.entrySet().iterator();
                    while (iterator.hasNext()) {
                        Entry<K, V> entry = iterator.next();
                        if (!collection.contains(entry.getValue())
                                && predicate.apply(entry)) {
                            iterator.remove();
                            changed = true;
                        }
                    }
                    return changed;
                }

                @Override public Object[] toArray() {
                    // creating an ArrayList so filtering happens once
                    return Lists.newArrayList(iterator()).toArray();
                }

                @Override public <T> T[] toArray(T[] array) {
                    return Lists.newArrayList(iterator()).toArray(array);
                }
            }
        }

        private static class FilteredKeyMap<K, V> extends AbstractFilteredMap<K, V> {
            Predicate<? super K> keyPredicate;

            FilteredKeyMap(Map<K, V> unfiltered, Predicate<? super K> keyPredicate,
                           Predicate<Entry<K, V>> entryPredicate) {
                super(unfiltered, entryPredicate);
                this.keyPredicate = keyPredicate;
            }

            Set<Entry<K, V>> entrySet;

            @Override public Set<Entry<K, V>> entrySet() {
                Set<Entry<K, V>> result = entrySet;
                return (result == null)
                        ? entrySet = Sets.filter(unfiltered.entrySet(), predicate)
                        : result;
            }

            Set<K> keySet;

            @Override public Set<K> keySet() {
                Set<K> result = keySet;
                return (result == null)
                        ? keySet = Sets.filter(unfiltered.keySet(), keyPredicate)
                        : result;
            }

            // The cast is called only when the key is in the unfiltered map, implying
            // that key is a K.
            @Override
            @SuppressWarnings("unchecked")
            public boolean containsKey(Object key) {
                return unfiltered.containsKey(key) && keyPredicate.apply((K) key);
            }
        }

        static class FilteredEntryMap<K, V> extends AbstractFilteredMap<K, V> {
            /**
             * Entries in this set satisfy the predicate, but they don't validate the
             * input to {@code Entry.setValue()}.
             */
            final Set<Entry<K, V>> filteredEntrySet;

            FilteredEntryMap(
                    Map<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {
                super(unfiltered, entryPredicate);
                filteredEntrySet = Sets.filter(unfiltered.entrySet(), predicate);
            }

            Set<Entry<K, V>> entrySet;

            @Override public Set<Entry<K, V>> entrySet() {
                Set<Entry<K, V>> result = entrySet;
                return (result == null) ? entrySet = new EntrySet() : result;
            }

            private class EntrySet extends ForwardingSet<Entry<K, V>> {
                @Override protected Set<Entry<K, V>> delegate() {
                    return filteredEntrySet;
                }

                @Override public Iterator<Entry<K, V>> iterator() {
                    final Iterator<Entry<K, V>> iterator = filteredEntrySet.iterator();
                    return new UnmodifiableIterator<Entry<K, V>>() {
                        @Override
                        public boolean hasNext() {
                            return iterator.hasNext();
                        }

                        @Override
                        public Entry<K, V> next() {
                            final Entry<K, V> entry = iterator.next();
                            return new ForwardingMapEntry<K, V>() {
                                @Override protected Entry<K, V> delegate() {
                                    return entry;
                                }

                                @Override public V setValue(V value) {
                                    checkArgument(apply(entry.getKey(), value));
                                    return super.setValue(value);
                                }
                            };
                        }
                    };
                }
            }

            Set<K> keySet;

            @Override public Set<K> keySet() {
                Set<K> result = keySet;
                return (result == null) ? keySet = new KeySet() : result;
            }

            private class KeySet extends AbstractSet<K> {
                @Override public Iterator<K> iterator() {
                    final Iterator<Entry<K, V>> iterator = filteredEntrySet.iterator();
                    return new UnmodifiableIterator<K>() {
                        @Override
                        public boolean hasNext() {
                            return iterator.hasNext();
                        }

                        @Override
                        public K next() {
                            return iterator.next().getKey();
                        }
                    };
                }

                @Override public int size() {
                    return filteredEntrySet.size();
                }

                @Override public void clear() {
                    filteredEntrySet.clear();
                }

                @Override public boolean contains(Object o) {
                    return containsKey(o);
                }

                @Override public boolean remove(Object o) {
                    if (containsKey(o)) {
                        unfiltered.remove(o);
                        return true;
                    }
                    return false;
                }

                @Override public boolean removeAll(Collection<?> collection) {
                    checkNotNull(collection); // for GWT
                    boolean changed = false;
                    for (Object obj : collection) {
                        changed |= remove(obj);
                    }
                    return changed;
                }

                @Override public boolean retainAll(Collection<?> collection) {
                    checkNotNull(collection); // for GWT
                    boolean changed = false;
                    Iterator<Entry<K, V>> iterator = unfiltered.entrySet().iterator();
                    while (iterator.hasNext()) {
                        Entry<K, V> entry = iterator.next();
                        if (!collection.contains(entry.getKey()) && predicate.apply(entry)) {
                            iterator.remove();
                            changed = true;
                        }
                    }
                    return changed;
                }

                @Override public Object[] toArray() {
                    // creating an ArrayList so filtering happens once
                    return Lists.newArrayList(iterator()).toArray();
                }

                @Override public <T> T[] toArray(T[] array) {
                    return Lists.newArrayList(iterator()).toArray(array);
                }
            }
        }

        /**
         * {@code AbstractMap} extension that implements {@link #isEmpty()} as {@code
         * entrySet().isEmpty()} instead of {@code size() == 0} to speed up
         * implementations where {@code size()} is O(n), and it delegates the {@code
         * isEmpty()} methods of its key set and value collection to this
         * implementation.
         */
        @GwtCompatible
        abstract static class ImprovedAbstractMap<K, V> extends AbstractMap<K, V> {
            /**
             * Creates the entry set to be returned by {@link #entrySet()}. This method
             * is invoked at most once on a given map, at the time when {@code entrySet}
             * is first called.
             */
            protected abstract Set<Entry<K, V>> createEntrySet();

            private Set<Entry<K, V>> entrySet;

            @Override public Set<Entry<K, V>> entrySet() {
                Set<Entry<K, V>> result = entrySet;
                if (result == null) {
                    entrySet = result = createEntrySet();
                }
                return result;
            }

            private Set<K> keySet;

            @Override public Set<K> keySet() {
                Set<K> result = keySet;
                if (result == null) {
                    final Set<K> delegate = super.keySet();
                    keySet = result = new ForwardingSet<K>() {
                        @Override protected Set<K> delegate() {
                            return delegate;
                        }

                        @Override public boolean isEmpty() {
                            return ImprovedAbstractMap.this.isEmpty();
                        }

                        @Override public boolean remove(Object object) {
                            if (contains(object)) {
                                ImprovedAbstractMap.this.remove(object);
                                return true;
                            }
                            return false;
                        }
                    };
                }
                return result;
            }

            private Collection<V> values;

            @Override public Collection<V> values() {
                Collection<V> result = values;
                if (result == null) {
                    final Collection<V> delegate = super.values();
                    values = result = new ForwardingCollection<V>() {
                        @Override protected Collection<V> delegate() {
                            return delegate;
                        }

                        @Override public boolean isEmpty() {
                            return ImprovedAbstractMap.this.isEmpty();
                        }
                    };
                }
                return result;
            }


            @Override public boolean isEmpty() {
                return entrySet().isEmpty();
            }
        }

        static final Joiner.MapJoiner STANDARD_JOINER =
                Collections2.STANDARD_JOINER.withKeyValueSeparator("=");


        static <V> V safeGet(Map<?, V> map, Object key) {
            try {
                return map.get(key);
            } catch (ClassCastException e) {
                return null;
            }
        }


        static boolean safeContainsKey(Map<?, ?> map, Object key) {
            try {
                return map.containsKey(key);
            } catch (ClassCastException e) {
                return false;
            }
        }

        static <K, V> Set<Map.Entry<K, V>> entrySetImpl(
                Map<K, V> map, Supplier<Iterator<Map.Entry<K, V>>> entryIteratorSupplier) {
            return new EntrySetImpl<K, V>(map, entryIteratorSupplier);
        }

        private static class EntrySetImpl<K, V> extends AbstractSet<Map.Entry<K, V>> {
            private final Map<K, V> map;
            private final Supplier<Iterator<Map.Entry<K, V>>> entryIteratorSupplier;

            EntrySetImpl(
                    Map<K, V> map, Supplier<Iterator<Map.Entry<K, V>>> entryIteratorSupplier) {
                this.map = checkNotNull(map);
                this.entryIteratorSupplier = checkNotNull(entryIteratorSupplier);
            }

            @Override public Iterator<Map.Entry<K, V>> iterator() {
                return entryIteratorSupplier.get();
            }

            @Override public int size() {
                return map.size();
            }

            @Override public void clear() {
                map.clear();
            }

            @Override public boolean contains(Object o) {
                if (o instanceof Map.Entry) {
                    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;
                    Object key = entry.getKey();
                    if (map.containsKey(key)) {
                        V value = map.get(entry.getKey());
                        return Objects.equal(value, entry.getValue());
                    }
                }
                return false;
            }

            @Override public boolean isEmpty() {
                return map.isEmpty();
            }

            @Override public boolean remove(Object o) {
                if (contains(o)) {
                    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;
                    map.remove(entry.getKey());
                    return true;
                }
                return false;
            }

            @Override public int hashCode() {
                return map.hashCode();
            }
        }


        static <K, V> boolean containsEntryImpl(Collection<Map.Entry<K, V>> c, Object o) {
            if (!(o instanceof Map.Entry)) {
                return false;
            }
            return c.contains(unmodifiableEntry((Map.Entry<?, ?>) o));
        }


        static <K, V> boolean removeEntryImpl(Collection<Map.Entry<K, V>> c, Object o) {
            if (!(o instanceof Map.Entry)) {
                return false;
            }
            return c.remove(unmodifiableEntry((Map.Entry<?, ?>) o));
        }


        static boolean equalsImpl(Map<?, ?> map, Object object) {
            if (map == object) {
                return true;
            }
            if (object instanceof Map) {
                Map<?, ?> o = (Map<?, ?>) object;
                return map.entrySet().equals(o.entrySet());
            }
            return false;
        }


        static int hashCodeImpl(Map<?, ?> map) {
            return Sets.hashCodeImpl(map.entrySet());
        }


        static String toStringImpl(Map<?, ?> map) {
            StringBuilder sb
                    = Collections2.newStringBuilderForCollection(map.size()).append('{');
            STANDARD_JOINER.appendTo(sb, map);
            return sb.append('}').toString();
        }


        static <K, V> void putAllImpl(
                Map<K, V> self, Map<? extends K, ? extends V> map) {
            for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {
                self.put(entry.getKey(), entry.getValue());
            }
        }


        static <K, V> Set<K> keySetImpl(final Map<K, V> map) {
            return new AbstractMapWrapper<K, V>(map).keySet();
        }


        static boolean containsKeyImpl(Map<?, ?> map, @Nullable Object key) {
            for (Map.Entry<?, ?> entry : map.entrySet()) {
                if (Objects.equal(entry.getKey(), key)) {
                    return true;
                }
            }
            return false;
        }


        static <K, V> Collection<V> valuesImpl(Map<K, V> map) {
            return new AbstractMapWrapper<K, V>(map).values();
        }


        static boolean containsValueImpl(Map<?, ?> map, @Nullable Object value) {
            for (Map.Entry<?, ?> entry : map.entrySet()) {
                if (Objects.equal(entry.getValue(), value)) {
                    return true;
                }
            }
            return false;
        }


        private static final class AbstractMapWrapper<K, V>
                extends ImprovedAbstractMap<K, V>{
            private final Map<K, V> map;

            AbstractMapWrapper(Map<K, V> map) {
                this.map = checkNotNull(map);
            }

            @Override public void clear() {
                map.clear();
            }

            @Override public boolean containsKey(Object key) {
                return map.containsKey(key);
            }

            @Override public V remove(Object key) {
                return map.remove(key);
            }

            @Override public boolean containsValue(Object value) {
                return map.containsValue(value);
            }

            @Override protected Set<Entry<K, V>> createEntrySet() {
                return map.entrySet();
            }

            @Override public boolean isEmpty() {
                return map.isEmpty();
            }

            @Override public int size() {
                return map.size();
            }
        }
    }
    public static final class Ascii {

        private Ascii() {}

        public static final byte NUL = 0;

        public static final byte SOH = 1;

        public static final byte STX = 2;

        public static final byte ETX = 3;

        public static final byte EOT = 4;

        public static final byte ENQ = 5;

        public static final byte ACK = 6;

        public static final byte BEL = 7;

        public static final byte BS = 8;

        public static final byte HT = 9;

        public static final byte LF = 10;

        public static final byte NL = 10;

        public static final byte VT = 11;

        public static final byte FF = 12;

        public static final byte CR = 13;

        public static final byte SO = 14;

        public static final byte SI = 15;

        public static final byte DLE = 16;

        public static final byte DC1 = 17; // aka XON

        public static final byte XON = 17; // aka DC1

        public static final byte DC2 = 18;

        public static final byte DC3 = 19; // aka XOFF

        public static final byte XOFF = 19; // aka DC3

        public static final byte DC4 = 20;

        public static final byte NAK = 21;


        public static final byte SYN = 22;


        public static final byte ETB = 23;

        public static final byte CAN = 24;

        public static final byte EM = 25;

        public static final byte SUB = 26;


        public static final byte ESC = 27;

        public static final byte FS = 28;

        public static final byte GS = 29;

        public static final byte RS = 30;

        public static final byte US = 31;

        public static final byte SP = 32;

        public static final byte SPACE = 32;

        public static final byte DEL = 127;

        public static final int MIN = 0;

        public static final int MAX = 127;

        public static String toLowerCase(String string) {
            int length = string.length();
            StringBuilder builder = new StringBuilder(length);
            for (int i = 0; i < length; i++) {
                builder.append(toLowerCase(string.charAt(i)));
            }
            return builder.toString();
        }

        public static char toLowerCase(char c) {
            return isUpperCase(c) ? (char) (c ^ 0x20) : c;
        }

        public static String toUpperCase(String string) {
            int length = string.length();
            StringBuilder builder = new StringBuilder(length);
            for (int i = 0; i < length; i++) {
                builder.append(toUpperCase(string.charAt(i)));
            }
            return builder.toString();
        }

        public static char toUpperCase(char c) {
            return isLowerCase(c) ? (char) (c & 0x5f) : c;
        }

        public static boolean isLowerCase(char c) {
            return (c >= 'a') && (c <= 'z');
        }

        public static boolean isUpperCase(char c) {
            return (c >= 'A') && (c <= 'Z');
        }
    }
    public static final class MapMaker extends GenericMapMaker<Object, Object> {
        private static final int DEFAULT_INITIAL_CAPACITY = 16;
        private static final int DEFAULT_CONCURRENCY_LEVEL = 4;
        private static final int DEFAULT_EXPIRATION_NANOS = 0;

        static final Executor DEFAULT_CLEANUP_EXECUTOR =
                new Executor() {
                    @Override
                    public void execute(Runnable r) {
                        r.run();
                    }
                };

        static final Ticker DEFAULT_TICKER =
                new Ticker() {
                    @Override
                    public long read() {
                        return System.nanoTime();
                    }
                };

        @SuppressWarnings("unchecked")
        enum NullListener implements MapEvictionListener {
            INSTANCE;
            @Override public void onEviction(Object key, Object value) {}
        }

        static final int UNSET_INT = -1;

        int initialCapacity = UNSET_INT;
        int concurrencyLevel = UNSET_INT;
        int maximumSize = UNSET_INT;

        Strength keyStrength;
        Strength valueStrength;

        long expireAfterWriteNanos = UNSET_INT;
        long expireAfterAccessNanos = UNSET_INT;

        // TODO(kevinb): dispense with this after benchmarking
        boolean useCustomMap;
        boolean useNullMap;

        Equivalence<Object> keyEquivalence;
        Equivalence<Object> valueEquivalence;

        Executor cleanupExecutor;
        Ticker ticker;


        public MapMaker() {}

        // TODO(kevinb): undo this indirection if keyEquiv gets released
        MapMaker privateKeyEquivalence(Equivalence<Object> equivalence) {
            checkState(keyEquivalence == null,
                    "key equivalence was already set to %s", keyEquivalence);
            keyEquivalence = checkNotNull(equivalence);
            this.useCustomMap = true;
            return this;
        }

        Equivalence<Object> getKeyEquivalence() {
            return firstNonNull(keyEquivalence, getKeyStrength().defaultEquivalence());
        }

        // TODO(kevinb): undo this indirection if valueEquiv gets released
        MapMaker privateValueEquivalence(Equivalence<Object> equivalence) {
            checkState(valueEquivalence == null,
                    "value equivalence was already set to %s", valueEquivalence);
            this.valueEquivalence = checkNotNull(equivalence);
            this.useCustomMap = true;
            return this;
        }

        Equivalence<Object> getValueEquivalence() {
            return firstNonNull(valueEquivalence,
                    getValueStrength().defaultEquivalence());
        }

        @Override
        public MapMaker initialCapacity(int initialCapacity) {
            checkState(this.initialCapacity == UNSET_INT,
                    "initial capacity was already set to %s", this.initialCapacity);
            checkArgument(initialCapacity >= 0);
            this.initialCapacity = initialCapacity;
            return this;
        }

        int getInitialCapacity() {
            return (initialCapacity == UNSET_INT)
                    ? DEFAULT_INITIAL_CAPACITY : initialCapacity;
        }


        @Override
        public MapMaker maximumSize(int size) {
            checkState(this.maximumSize == UNSET_INT,
                    "maximum size was already set to %s", this.maximumSize);
            checkArgument(size >= 0, "maximum size must not be negative");
            this.maximumSize = size;
            this.useCustomMap = true;
            this.useNullMap |= (maximumSize == 0);
            return this;
        }

        @GwtIncompatible("java.util.concurrent.ConcurrentHashMap concurrencyLevel")
        @Override
        public MapMaker concurrencyLevel(int concurrencyLevel) {
            checkState(this.concurrencyLevel == UNSET_INT,
                    "concurrency level was already set to %s", this.concurrencyLevel);
            checkArgument(concurrencyLevel > 0);
            this.concurrencyLevel = concurrencyLevel;
            return this;
        }

        int getConcurrencyLevel() {
            return (concurrencyLevel == UNSET_INT)
                    ? DEFAULT_CONCURRENCY_LEVEL : concurrencyLevel;
        }

        @GwtIncompatible("java.lang.ref.WeakReference")
        @Override
        public MapMaker weakKeys() {
            return setKeyStrength(Strength.WEAK);
        }

        @GwtIncompatible("java.lang.ref.SoftReference")
        @Override
        public MapMaker softKeys() {
            return setKeyStrength(Strength.SOFT);
        }

        MapMaker setKeyStrength(Strength strength) {
            checkState(keyStrength == null,
                    "Key strength was already set to %s", keyStrength);
            keyStrength = checkNotNull(strength);
            if (strength != Strength.STRONG) {
                // STRONG could be used during deserialization.
                useCustomMap = true;
            }
            return this;
        }

        Strength getKeyStrength() {
            return firstNonNull(keyStrength, Strength.STRONG);
        }

        @GwtIncompatible("java.lang.ref.WeakReference")
        @Override
        public MapMaker weakValues() {
            return setValueStrength(Strength.WEAK);
        }

        @GwtIncompatible("java.lang.ref.SoftReference")
        @Override
        public MapMaker softValues() {
            return setValueStrength(Strength.SOFT);
        }

        MapMaker setValueStrength(Strength strength) {
            checkState(valueStrength == null,
                    "Value strength was already set to %s", valueStrength);
            valueStrength = checkNotNull(strength);
            if (strength != Strength.STRONG) {
                // STRONG could be used during deserialization.
                useCustomMap = true;
            }
            return this;
        }

        Strength getValueStrength() {
            return firstNonNull(valueStrength, Strength.STRONG);
        }

        @Deprecated
        @Override
        public MapMaker expiration(long duration, TimeUnit unit) {
            return expireAfterWrite(duration, unit);
        }

        @Override
        public MapMaker expireAfterWrite(long duration, TimeUnit unit) {
            checkExpiration(duration, unit);
            this.expireAfterWriteNanos = unit.toNanos(duration);
            useNullMap |= (duration == 0);
            useCustomMap = true;
            return this;
        }

        private void checkExpiration(long duration, TimeUnit unit) {
            checkState(expireAfterWriteNanos == UNSET_INT,
                    "expireAfterWrite was already set to %s ns",
                    expireAfterWriteNanos);
            checkState(expireAfterAccessNanos == UNSET_INT,
                    "expireAfterAccess was already set to %s ns",
                    expireAfterAccessNanos);
            checkArgument(duration >= 0, "duration cannot be negative: %s %s",
                    duration, unit);
        }

        long getExpireAfterWriteNanos() {
            return (expireAfterWriteNanos == UNSET_INT)
                    ? DEFAULT_EXPIRATION_NANOS : expireAfterWriteNanos;
        }

        @GwtIncompatible("To be supported")
        @Override
        public MapMaker expireAfterAccess(long duration, TimeUnit unit) {
            checkExpiration(duration, unit);
            this.expireAfterAccessNanos = unit.toNanos(duration);
            useNullMap |= (duration == 0);
            useCustomMap = true;
            return this;
        }

        long getExpireAfterAccessNanos() {
            return (expireAfterAccessNanos == UNSET_INT)
                    ? DEFAULT_EXPIRATION_NANOS : expireAfterAccessNanos;
        }

        Executor getCleanupExecutor() {
            return firstNonNull(cleanupExecutor, DEFAULT_CLEANUP_EXECUTOR);
        }

        Ticker getTicker() {
            return firstNonNull(ticker, DEFAULT_TICKER);
        }

        @GwtIncompatible("To be supported")
        public <K, V> GenericMapMaker<K, V> evictionListener(
                MapEvictionListener<K, V> listener) {
            checkState(this.evictionListener == null);

            // safely limiting the kinds of maps this can produce
            @SuppressWarnings("unchecked")
            GenericMapMaker<K, V> me = (GenericMapMaker<K, V>) this;
            me.evictionListener = checkNotNull(listener);
            useCustomMap = true;
            return me;
        }

        // TODO(kevinb): should this go in GenericMapMaker to avoid casts?
        @SuppressWarnings("unchecked")
        <K, V> MapEvictionListener<K, V> getEvictionListener() {
            return evictionListener == null
                    ? (MapEvictionListener<K, V>) NullListener.INSTANCE
                    : (MapEvictionListener<K, V>) evictionListener;
        }

        @Override
        public <K, V> ConcurrentMap<K, V> makeMap() {
            if (!useCustomMap) {
                return new ConcurrentHashMap<K, V>(getInitialCapacity(),
                        0.75f, getConcurrencyLevel());
            }
            return useNullMap
                    ? new NullConcurrentMap<K, V>(this)
                    : new CustomConcurrentHashMap<K, V>(this);
        }


        // TODO(kevinb): figure out the Cache interface before making this public
        <K, V> Cache<K, V> makeCache(
                Function<? super K, ? extends V> computingFunction) {
            return useNullMap
                    ? new NullComputingConcurrentMap<K, V>(this, computingFunction)
                    : new ComputingConcurrentHashMap<K, V>(this, computingFunction);
        }

        @Override
        public <K, V> ConcurrentMap<K, V> makeComputingMap(
                Function<? super K, ? extends V> computingFunction) {
            Cache<K, V> cache = makeCache(computingFunction);
            return new ComputingMapAdapter<K, V>(cache);
        }


        @Override
        public String toString() {
            Objects.ToStringHelper s = Objects.toStringHelper(this);
            if (initialCapacity != UNSET_INT) {
                s.add("initialCapacity", initialCapacity);
            }
            if (concurrencyLevel != UNSET_INT) {
                s.add("concurrencyLevel", concurrencyLevel);
            }
            if (maximumSize != UNSET_INT) {
                s.add("maximumSize", maximumSize);
            }
            if (expireAfterWriteNanos != UNSET_INT) {
                s.add("expireAfterWrite", expireAfterWriteNanos + "ns");
            }
            if (expireAfterAccessNanos != UNSET_INT) {
                s.add("expireAfterAccess", expireAfterAccessNanos + "ns");
            }
            if (keyStrength != null) {
                s.add("keyStrength", Ascii.toLowerCase(keyStrength.toString()));
            }
            if (valueStrength != null) {
                s.add("valueStrength", Ascii.toLowerCase(valueStrength.toString()));
            }
            if (keyEquivalence != null) {
                s.addValue("keyEquivalence");
            }
            if (valueEquivalence != null) {
                s.addValue("valueEquivalence");
            }
            if (evictionListener != null) {
                s.addValue("evictionListener");
            }
            if (cleanupExecutor != null) {
                s.addValue("cleanupExecutor");
            }
            return s.toString();
        }


        interface Cache<K, V> extends Function<K, V> {

            ConcurrentMap<K, V> asMap();
        }


        static class NullConcurrentMap<K, V> extends AbstractMap<K, V>
                implements ConcurrentMap<K, V>, Serializable {
            private static final long serialVersionUID = 0;

            final MapEvictionListener<K, V> evictionListener;

            NullConcurrentMap(MapMaker mapMaker) {
                evictionListener = mapMaker.getEvictionListener();
            }

            @Override
            public boolean containsKey(Object key) {
                checkNotNull(key);
                return false;
            }

            @Override
            public boolean containsValue(Object value) {
                checkNotNull(value);
                return false;
            }

            @Override
            public V get(Object key) {
                checkNotNull(key);
                return null;
            }

            @Override
            public V put(K key, V value) {
                checkNotNull(key);
                checkNotNull(value);
                evictionListener.onEviction(key, value);
                return null;
            }

            @Override
            public V putIfAbsent(K key, V value) {
                return put(key, value);
            }

            @Override
            public V remove(Object key) {
                checkNotNull(key);
                return null;
            }

            @Override
            public boolean remove(Object key, Object value) {
                checkNotNull(key);
                checkNotNull(value);
                return false;
            }

            @Override
            public V replace(K key, V value) {
                checkNotNull(key);
                checkNotNull(value);
                return null;
            }

            @Override
            public boolean replace(K key, V oldValue, V newValue) {
                checkNotNull(key);
                checkNotNull(oldValue);
                checkNotNull(newValue);
                return false;
            }

            @Override
            public Set<Entry<K, V>> entrySet() {
                return Collections.emptySet();
            }
        }


        static final class NullComputingConcurrentMap<K, V>
                extends NullConcurrentMap<K, V> implements Cache<K, V> {
            private static final long serialVersionUID = 0;

            final Function<? super K, ? extends V> computingFunction;

            NullComputingConcurrentMap(MapMaker mapMaker,
                                       Function<? super K, ? extends V> computingFunction) {
                super(mapMaker);
                this.computingFunction = checkNotNull(computingFunction);
            }

            @Override
            public V apply(K key) {
                V value = compute(key);
                checkNotNull(value,
                        computingFunction + " returned null for key " + key + ".");
                evictionListener.onEviction(key, value);
                return value;
            }

            private V compute(K key) {
                checkNotNull(key);
                try {
                    return computingFunction.apply(key);
                } catch (ComputationException e) {
                    throw e;
                } catch (Throwable t) {
                    throw new ComputationException(t);
                }
            }

            @Override
            public ConcurrentMap<K, V> asMap() {
                return this;
            }
        }


        static class ComputingMapAdapter<K, V> extends ForwardingConcurrentMap<K, V>
                implements Serializable {
            private static final long serialVersionUID = 0;

            final Cache<K, V> cache;

            ComputingMapAdapter(Cache<K, V> cache) {
                this.cache = cache;
            }

            @Override protected ConcurrentMap<K, V> delegate() {
                return cache.asMap();
            }

            @SuppressWarnings("unchecked") // unsafe, which is why this is deprecated
            @Override public V get(Object key) {
                return cache.apply((K) key);
            }
        }
    }

    public interface Supplier<T> {

        T get();
    }
    static public abstract class ForwardingSet<E> extends ForwardingCollection<E>
            implements Set<E> {

        protected ForwardingSet() {}

        @Override protected abstract Set<E> delegate();

        @Override public boolean equals(@Nullable Object object) {
            return object == this || delegate().equals(object);
        }

        @Override public int hashCode() {
            return delegate().hashCode();
        }


        @Beta protected boolean standardEquals(@Nullable Object object) {
            return Sets.equalsImpl(this, object);
        }


        @Beta protected int standardHashCode() {
            return Sets.hashCodeImpl(this);
        }
    }
    static public abstract class ForwardingMultimap<K, V> extends ForwardingObject
            implements Multimap<K, V> {


        protected ForwardingMultimap() {}

        @Override protected abstract Multimap<K, V> delegate();

        public Map<K, Collection<V>> asMap() {
            return delegate().asMap();
        }

        public void clear() {
            delegate().clear();
        }

        public boolean containsEntry(@Nullable Object key, @Nullable Object value) {
            return delegate().containsEntry(key, value);
        }

        public boolean containsKey(@Nullable Object key) {
            return delegate().containsKey(key);
        }

        public boolean containsValue(@Nullable Object value) {
            return delegate().containsValue(value);
        }

        public Collection<Map.Entry<K, V>> entries() {
            return delegate().entries();
        }

        public Collection<V> get(@Nullable K key) {
            return delegate().get(key);
        }

        public boolean isEmpty() {
            return delegate().isEmpty();
        }

        public Multiset<K> keys() {
            return delegate().keys();
        }

        public Set<K> keySet() {
            return delegate().keySet();
        }

        public boolean put(K key, V value) {
            return delegate().put(key, value);
        }

        public boolean putAll(K key, Iterable<? extends V> values) {
            return delegate().putAll(key, values);
        }

        public boolean putAll(Multimap<? extends K, ? extends V> multimap) {
            return delegate().putAll(multimap);
        }

        public boolean remove(@Nullable Object key, @Nullable Object value) {
            return delegate().remove(key, value);
        }

        public Collection<V> removeAll(@Nullable Object key) {
            return delegate().removeAll(key);
        }

        public Collection<V> replaceValues(K key, Iterable<? extends V> values) {
            return delegate().replaceValues(key, values);
        }

        public int size() {
            return delegate().size();
        }

        public Collection<V> values() {
            return delegate().values();
        }

        @Override public boolean equals(@Nullable Object object) {
            return object == this || delegate().equals(object);
        }

        @Override public int hashCode() {
            return delegate().hashCode();
        }
    }
    public abstract static class ForwardingMultiset<E> extends ForwardingCollection<E>
            implements Multiset<E> {


        protected ForwardingMultiset() {}

        @Override protected abstract Multiset<E> delegate();

        public int count(Object element) {
            return delegate().count(element);
        }

        public int add(E element, int occurrences) {
            return delegate().add(element, occurrences);
        }

        public int remove(Object element, int occurrences) {
            return delegate().remove(element, occurrences);
        }

        public Set<E> elementSet() {
            return delegate().elementSet();
        }

        public Set<Entry<E>> entrySet() {
            return delegate().entrySet();
        }

        @Override public boolean equals(@Nullable Object object) {
            return object == this || delegate().equals(object);
        }

        @Override public int hashCode() {
            return delegate().hashCode();
        }

        public int setCount(E element, int count) {
            return delegate().setCount(element, count);
        }

        public boolean setCount(E element, int oldCount, int newCount) {
            return delegate().setCount(element, oldCount, newCount);
        }


        @Override @Beta protected boolean standardContains(@Nullable Object object) {
            return count(object) > 0;
        }


        @Override @Beta protected void standardClear() {
            Iterator<Entry<E>> entryIterator = entrySet().iterator();
            while (entryIterator.hasNext()) {
                entryIterator.next();
                entryIterator.remove();
            }
        }


        @Beta protected int standardCount(@Nullable Object object) {
            for (Entry<?> entry : this.entrySet()) {
                if (Objects.equal(entry.getElement(), object)) {
                    return entry.getCount();
                }
            }
            return 0;
        }


        @Beta protected boolean standardAdd(E element) {
            add(element, 1);
            return true;
        }


        @Beta @Override protected boolean standardAddAll(
                Collection<? extends E> elementsToAdd) {
            return Multisets.addAllImpl(this, elementsToAdd);
        }


        @Beta @Override protected boolean standardRemove(Object element) {
            return remove(element, 1) > 0;
        }


        @Beta @Override protected boolean standardRemoveAll(
                Collection<?> elementsToRemove) {
            return Multisets.removeAllImpl(this, elementsToRemove);
        }

        @Beta @Override protected boolean standardRetainAll(
                Collection<?> elementsToRetain) {
            return Multisets.retainAllImpl(this, elementsToRetain);
        }


        @Beta protected int standardSetCount(E element, int count) {
            return setCountImpl(this, element, count);
        }


        @Beta protected boolean standardSetCount(
                E element, int oldCount, int newCount) {
            return setCountImpl(this, element, oldCount, newCount);
        }


        @Beta protected Set<E> standardElementSet() {
            return Multisets.elementSetImpl(this);
        }


        @Beta protected Iterator<E> standardIterator() {
            return Multisets.iteratorImpl(this);
        }


        @Beta protected int standardSize() {
            return Multisets.sizeImpl(this);
        }


        @Beta protected boolean standardEquals(@Nullable Object object) {
            return Multisets.equalsImpl(this, object);
        }

        @Beta protected int standardHashCode() {
            return entrySet().hashCode();
        }

        @Beta @Override protected String standardToString() {
            return entrySet().toString();
        }
    }
    public static abstract class ForwardingObject {

        protected ForwardingObject() {}

        protected abstract Object delegate();

        @Override public String toString() {
            return delegate().toString();
        }

  /* No equals or hashCode. See class comments for details. */
    }
    static public abstract class ForwardingCollection<E> extends ForwardingObject
            implements Collection<E> {
        // TODO(user): identify places where thread safety is actually lost


        protected ForwardingCollection() {}

        @Override protected abstract Collection<E> delegate();

        public Iterator<E> iterator() {
            return delegate().iterator();
        }

        public int size() {
            return delegate().size();
        }

        public boolean removeAll(Collection<?> collection) {
            return delegate().removeAll(collection);
        }

        public boolean isEmpty() {
            return delegate().isEmpty();
        }

        public boolean contains(Object object) {
            return delegate().contains(object);
        }

        public boolean add(E element) {
            return delegate().add(element);
        }

        public boolean remove(Object object) {
            return delegate().remove(object);
        }

        public boolean containsAll(Collection<?> collection) {
            return delegate().containsAll(collection);
        }

        public boolean addAll(Collection<? extends E> collection) {
            return delegate().addAll(collection);
        }

        public boolean retainAll(Collection<?> collection) {
            return delegate().retainAll(collection);
        }

        public void clear() {
            delegate().clear();
        }

        public Object[] toArray() {
            return delegate().toArray();
        }

        public <T> T[] toArray(T[] array) {
            return delegate().toArray(array);
        }

        @Beta protected boolean standardContains(@Nullable Object object) {
            return Iterators.contains(iterator(), object);
        }

        @Beta protected boolean standardContainsAll(Collection<?> collection) {
            for (Object o : collection) {
                if (!contains(o)) {
                    return false;
                }
            }
            return true;
        }

        @Beta protected boolean standardAddAll(Collection<? extends E> collection) {
            return Iterators.addAll(this, collection.iterator());
        }


        @Beta protected boolean standardRemove(@Nullable Object object) {
            Iterator<E> iterator = iterator();
            while (iterator.hasNext()) {
                if (Objects.equal(iterator.next(), object)) {
                    iterator.remove();
                    return true;
                }
            }
            return false;
        }

        @Beta protected boolean standardRemoveAll(Collection<?> collection) {
            return Iterators.removeAll(iterator(), collection);
        }

        @Beta protected boolean standardRetainAll(Collection<?> collection) {
            return Iterators.retainAll(iterator(), collection);
        }

        @Beta protected void standardClear() {
            Iterator<E> iterator = iterator();
            while (iterator.hasNext()) {
                iterator.next();
                iterator.remove();
            }
        }

        @Beta protected boolean standardIsEmpty() {
            return !iterator().hasNext();
        }


        @Beta protected String standardToString() {
            return Collections2.toStringImpl(this);
        }

        @Beta protected Object[] standardToArray() {
            Object[] newArray = new Object[size()];
            return toArray(newArray);
        }

        @Beta protected <T> T[] standardToArray(T[] array) {
            return ObjectArrays.toArrayImpl(this, array);
        }
    }
    static public abstract class ForwardingMapEntry<K, V>
            extends ForwardingObject implements Map.Entry<K, V> {
        // TODO(user): identify places where thread safety is actually lost

        protected ForwardingMapEntry() {}

        @Override protected abstract Map.Entry<K, V> delegate();

        public K getKey() {
            return delegate().getKey();
        }

        public V getValue() {
            return delegate().getValue();
        }

        public V setValue(V value) {
            return delegate().setValue(value);
        }

        @Override public boolean equals(@Nullable Object object) {
            return delegate().equals(object);
        }

        @Override public int hashCode() {
            return delegate().hashCode();
        }

        @Beta protected boolean standardEquals(@Nullable Object object) {
            if (object instanceof Map.Entry) {
                Map.Entry<?, ?> that = (Map.Entry<?, ?>) object;
                return Objects.equal(this.getKey(), that.getKey())
                        && Objects.equal(this.getValue(), that.getValue());
            }
            return false;
        }

        @Beta protected int standardHashCode() {
            K k = getKey();
            V v = getValue();
            return ((k == null) ? 0 : k.hashCode()) ^ ((v == null) ? 0 : v.hashCode());
        }

        @Beta protected String standardToString() {
            return getKey() + "=" + getValue();
        }
    }
    public static abstract class ForwardingMap<K, V> extends ForwardingObject
            implements Map<K, V> {
        // TODO(user): identify places where thread safety is actually lost

        protected ForwardingMap() {}

        @Override protected abstract Map<K, V> delegate();

        @Override
        public int size() {
            return delegate().size();
        }

        @Override
        public boolean isEmpty() {
            return delegate().isEmpty();
        }

        @Override
        public V remove(Object object) {
            return delegate().remove(object);
        }

        @Override
        public void clear() {
            delegate().clear();
        }

        @Override
        public boolean containsKey(Object key) {
            return delegate().containsKey(key);
        }

        @Override
        public boolean containsValue(Object value) {
            return delegate().containsValue(value);
        }

        @Override
        public V get(Object key) {
            return delegate().get(key);
        }

        @Override
        public V put(K key, V value) {
            return delegate().put(key, value);
        }

        @Override
        public void putAll(Map<? extends K, ? extends V> map) {
            delegate().putAll(map);
        }

        @Override
        public Set<K> keySet() {
            return delegate().keySet();
        }

        @Override
        public Collection<V> values() {
            return delegate().values();
        }

        @Override
        public Set<Entry<K, V>> entrySet() {
            return delegate().entrySet();
        }

        @Override public boolean equals(@Nullable Object object) {
            return object == this || delegate().equals(object);
        }

        @Override public int hashCode() {
            return delegate().hashCode();
        }

         protected void standardPutAll(Map<? extends K, ? extends V> map) {
            Maps.putAllImpl(this, map);
        }

         protected V standardRemove(@Nullable Object key) {
            Iterator<Entry<K, V>> entryIterator = entrySet().iterator();
            while (entryIterator.hasNext()) {
                Entry<K, V> entry = entryIterator.next();
                if (Objects.equal(entry.getKey(), key)) {
                    V value = entry.getValue();
                    entryIterator.remove();
                    return value;
                }
            }
            return null;
        }

         protected void standardClear() {
            Iterator<Entry<K, V>> entryIterator = entrySet().iterator();
            while (entryIterator.hasNext()) {
                entryIterator.next();
                entryIterator.remove();
            }
        }

        protected Set<K> standardKeySet() {
            return Maps.keySetImpl(this);
        }

         protected boolean standardContainsKey(@Nullable Object key) {
            return Maps.containsKeyImpl(this, key);
        }

         protected Collection<V> standardValues() {
            return Maps.valuesImpl(this);
        }

         protected boolean standardContainsValue(@Nullable Object value) {
            return Maps.containsValueImpl(this, value);
        }

        protected Set<Entry<K, V>> standardEntrySet(
                Supplier<Iterator<Entry<K, V>>> entryIteratorSupplier) {
            return Maps.entrySetImpl(this, entryIteratorSupplier);
        }

        protected boolean standardIsEmpty() {
            return !entrySet().iterator().hasNext();
        }

        protected boolean standardEquals(@Nullable Object object) {
            return Maps.equalsImpl(this, object);
        }

        protected int standardHashCode() {
            return Sets.hashCodeImpl(entrySet());
        }

        protected String standardToString() {
            return Maps.toStringImpl(this);
        }
    }

    public static abstract class ForwardingConcurrentMap<K, V> extends ForwardingMap<K, V>
            implements ConcurrentMap<K, V> {


        protected ForwardingConcurrentMap() {}

        @Override protected abstract ConcurrentMap<K, V> delegate();

        @Override
        public V putIfAbsent(K key, V value) {
            return delegate().putIfAbsent(key, value);
        }

        @Override
        public boolean remove(Object key, Object value) {
            return delegate().remove(key, value);
        }

        @Override
        public V replace(K key, V value) {
            return delegate().replace(key, value);
        }

        @Override
        public boolean replace(K key, V oldValue, V newValue) {
            return delegate().replace(key, oldValue, newValue);
        }

    }

    public abstract static class CharMatcher implements Predicate<Character> {
        // Constants

        // Excludes 2000-2000a, which is handled as a range
        private static final String BREAKING_WHITESPACE_CHARS =
                "\t\n\013\f\r \u0085\u1680\u2028\u2029\u205f\u3000";

        // Excludes 2007, which is handled as a gap in a pair of ranges
        private static final String NON_BREAKING_WHITESPACE_CHARS =
                "\u00a0\u180e\u202f";


        public static final CharMatcher WHITESPACE =
                anyOf(BREAKING_WHITESPACE_CHARS + NON_BREAKING_WHITESPACE_CHARS)
                        .or(inRange('\u2000', '\u200a'))
                        .precomputed();


        public static final CharMatcher BREAKING_WHITESPACE =
                anyOf(BREAKING_WHITESPACE_CHARS)
                        .or(inRange('\u2000', '\u2006'))
                        .or(inRange('\u2008', '\u200a'))
                        .precomputed();


        public static final CharMatcher ASCII = inRange('\0', '\u007f');


        public static final CharMatcher DIGIT;

        static {
            CharMatcher digit = inRange('0', '9');
            String zeroes =
                    "\u0660\u06f0\u07c0\u0966\u09e6\u0a66\u0ae6\u0b66\u0be6\u0c66"
                            + "\u0ce6\u0d66\u0e50\u0ed0\u0f20\u1040\u1090\u17e0\u1810\u1946"
                            + "\u19d0\u1b50\u1bb0\u1c40\u1c50\ua620\ua8d0\ua900\uaa50\uff10";
            for (char base : zeroes.toCharArray()) {
                digit = digit.or(inRange(base, (char) (base + 9)));
            }
            DIGIT = digit.precomputed();
        }


        public static final CharMatcher JAVA_WHITESPACE =
                inRange('\u0009', (char) 13)  // \\u000d doesn't work as a char literal
                        .or(inRange('\u001c', '\u0020'))
                        .or(is('\u1680'))
                        .or(is('\u180e'))
                        .or(inRange('\u2000', '\u2006'))
                        .or(inRange('\u2008', '\u200b'))
                        .or(inRange('\u2028', '\u2029'))
                        .or(is('\u205f'))
                        .or(is('\u3000'))
                        .precomputed();


        public static final CharMatcher JAVA_DIGIT = new CharMatcher() {
            @Override public boolean matches(char c) {
                return Character.isDigit(c);
            }
        };


        public static final CharMatcher JAVA_LETTER = new CharMatcher() {
            @Override public boolean matches(char c) {
                return Character.isLetter(c);
            }
        };


        public static final CharMatcher JAVA_LETTER_OR_DIGIT = new CharMatcher() {
            @Override public boolean matches(char c) {
                return Character.isLetterOrDigit(c);
            }
        };


        public static final CharMatcher JAVA_UPPER_CASE = new CharMatcher() {
            @Override public boolean matches(char c) {
                return Character.isUpperCase(c);
            }
        };


        public static final CharMatcher JAVA_LOWER_CASE = new CharMatcher() {
            @Override public boolean matches(char c) {
                return Character.isLowerCase(c);
            }
        };

        public static final CharMatcher JAVA_ISO_CONTROL =
                inRange('\u0000', '\u001f').or(inRange('\u007f', '\u009f'));


        public static final CharMatcher INVISIBLE = inRange('\u0000', '\u0020')
                .or(inRange('\u007f', '\u00a0'))
                .or(is('\u00ad'))
                .or(inRange('\u0600', '\u0603'))
                .or(anyOf("\u06dd\u070f\u1680\u17b4\u17b5\u180e"))
                .or(inRange('\u2000', '\u200f'))
                .or(inRange('\u2028', '\u202f'))
                .or(inRange('\u205f', '\u2064'))
                .or(inRange('\u206a', '\u206f'))
                .or(is('\u3000'))
                .or(inRange('\ud800', '\uf8ff'))
                .or(anyOf("\ufeff\ufff9\ufffa\ufffb"))
                .precomputed();

        public static final CharMatcher SINGLE_WIDTH = inRange('\u0000', '\u04f9')
                .or(is('\u05be'))
                .or(inRange('\u05d0', '\u05ea'))
                .or(is('\u05f3'))
                .or(is('\u05f4'))
                .or(inRange('\u0600', '\u06ff'))
                .or(inRange('\u0750', '\u077f'))
                .or(inRange('\u0e00', '\u0e7f'))
                .or(inRange('\u1e00', '\u20af'))
                .or(inRange('\u2100', '\u213a'))
                .or(inRange('\ufb50', '\ufdff'))
                .or(inRange('\ufe70', '\ufeff'))
                .or(inRange('\uff61', '\uffdc'))
                .precomputed();

        public static final CharMatcher ANY =
                new CharMatcher() {
                    @Override public boolean matches(char c) {
                        return true;
                    }

                    @Override public int indexIn(CharSequence sequence) {
                        return (sequence.length() == 0) ? -1 : 0;
                    }

                    @Override public int indexIn(CharSequence sequence, int start) {
                        int length = sequence.length();
                        Preconditions.checkPositionIndex(start, length);
                        return (start == length) ? -1 : start;
                    }

                    @Override public int lastIndexIn(CharSequence sequence) {
                        return sequence.length() - 1;
                    }

                    @Override public boolean matchesAllOf(CharSequence sequence) {
                        checkNotNull(sequence);
                        return true;
                    }

                    @Override public boolean matchesNoneOf(CharSequence sequence) {
                        return sequence.length() == 0;
                    }

                    @Override public String removeFrom(CharSequence sequence) {
                        checkNotNull(sequence);
                        return "";
                    }

                    @Override public String replaceFrom(CharSequence sequence, char replacement) {
                        char[] array = new char[sequence.length()];
                        Arrays.fill(array, replacement);
                        return new String(array);
                    }

                    @Override public String replaceFrom(CharSequence sequence, CharSequence replacement) {
                        StringBuilder retval = new StringBuilder(sequence.length() * replacement.length());
                        for (int i = 0; i < sequence.length(); i++) {
                            retval.append(replacement);
                        }
                        return retval.toString();
                    }

                    @Override public String collapseFrom(CharSequence sequence, char replacement) {
                        return (sequence.length() == 0) ? "" : String.valueOf(replacement);
                    }

                    @Override public String trimFrom(CharSequence sequence) {
                        checkNotNull(sequence);
                        return "";
                    }

                    @Override public int countIn(CharSequence sequence) {
                        return sequence.length();
                    }

                    @Override public CharMatcher and(CharMatcher other) {
                        return checkNotNull(other);
                    }

                    @Override public CharMatcher or(CharMatcher other) {
                        checkNotNull(other);
                        return this;
                    }

                    @Override public CharMatcher negate() {
                        return NONE;
                    }

                    @Override public CharMatcher precomputed() {
                        return this;
                    }
                };


        public static final CharMatcher NONE =
                new CharMatcher() {
                    @Override public boolean matches(char c) {
                        return false;
                    }

                    @Override public int indexIn(CharSequence sequence) {
                        checkNotNull(sequence);
                        return -1;
                    }

                    @Override public int indexIn(CharSequence sequence, int start) {
                        int length = sequence.length();
                        Preconditions.checkPositionIndex(start, length);
                        return -1;
                    }

                    @Override public int lastIndexIn(CharSequence sequence) {
                        checkNotNull(sequence);
                        return -1;
                    }

                    @Override public boolean matchesAllOf(CharSequence sequence) {
                        return sequence.length() == 0;
                    }

                    @Override public boolean matchesNoneOf(CharSequence sequence) {
                        checkNotNull(sequence);
                        return true;
                    }

                    @Override public String removeFrom(CharSequence sequence) {
                        return sequence.toString();
                    }

                    @Override public String replaceFrom(CharSequence sequence, char replacement) {
                        return sequence.toString();
                    }

                    @Override public String replaceFrom(CharSequence sequence, CharSequence replacement) {
                        checkNotNull(replacement);
                        return sequence.toString();
                    }

                    @Override public String collapseFrom(CharSequence sequence, char replacement) {
                        return sequence.toString();
                    }

                    @Override public String trimFrom(CharSequence sequence) {
                        return sequence.toString();
                    }

                    @Override public int countIn(CharSequence sequence) {
                        checkNotNull(sequence);
                        return 0;
                    }

                    @Override public CharMatcher and(CharMatcher other) {
                        checkNotNull(other);
                        return this;
                    }

                    @Override public CharMatcher or(CharMatcher other) {
                        return checkNotNull(other);
                    }

                    @Override public CharMatcher negate() {
                        return ANY;
                    }

                    @Override void setBits(LookupTable table) {}

                    @Override public CharMatcher precomputed() {
                        return this;
                    }
                };


        public static CharMatcher is(final char match) {
            return new CharMatcher() {
                @Override public boolean matches(char c) {
                    return c == match;
                }

                @Override public String replaceFrom(CharSequence sequence, char replacement) {
                    return sequence.toString().replace(match, replacement);
                }

                @Override public CharMatcher and(CharMatcher other) {
                    return other.matches(match) ? this : NONE;
                }

                @Override public CharMatcher or(CharMatcher other) {
                    return other.matches(match) ? other : super.or(other);
                }

                @Override public CharMatcher negate() {
                    return isNot(match);
                }

                @Override void setBits(LookupTable table) {
                    table.set(match);
                }

                @Override public CharMatcher precomputed() {
                    return this;
                }
            };
        }

        public static CharMatcher isNot(final char match) {
            return new CharMatcher() {
                @Override public boolean matches(char c) {
                    return c != match;
                }

                @Override public CharMatcher and(CharMatcher other) {
                    return other.matches(match) ? super.and(other) : other;
                }

                @Override public CharMatcher or(CharMatcher other) {
                    return other.matches(match) ? ANY : this;
                }

                @Override public CharMatcher negate() {
                    return is(match);
                }
            };
        }


        public static CharMatcher anyOf(final CharSequence sequence) {
            switch (sequence.length()) {
                case 0:
                    return NONE;
                case 1:
                    return is(sequence.charAt(0));
                case 2:
                    final char match1 = sequence.charAt(0);
                    final char match2 = sequence.charAt(1);
                    return new CharMatcher() {
                        @Override public boolean matches(char c) {
                            return c == match1 || c == match2;
                        }

                        @Override void setBits(LookupTable table) {
                            table.set(match1);
                            table.set(match2);
                        }

                        @Override public CharMatcher precomputed() {
                            return this;
                        }
                    };
            }

            final char[] chars = sequence.toString().toCharArray();
            Arrays.sort(chars); // not worth collapsing duplicates

            return new CharMatcher() {
                @Override public boolean matches(char c) {
                    return Arrays.binarySearch(chars, c) >= 0;
                }

                @Override void setBits(LookupTable table) {
                    for (char c : chars) {
                        table.set(c);
                    }
                }
            };
        }

        public static CharMatcher noneOf(CharSequence sequence) {
            return anyOf(sequence).negate();
        }

        public static CharMatcher inRange(final char startInclusive, final char endInclusive) {
            checkArgument(endInclusive >= startInclusive);
            return new CharMatcher() {
                @Override public boolean matches(char c) {
                    return startInclusive <= c && c <= endInclusive;
                }

                @Override void setBits(LookupTable table) {
                    char c = startInclusive;
                    while (true) {
                        table.set(c);
                        if (c++ == endInclusive) {
                            break;
                        }
                    }
                }

                @Override public CharMatcher precomputed() {
                    return this;
                }
            };
        }


        public static CharMatcher forPredicate(final Predicate<? super Character> predicate) {
            checkNotNull(predicate);
            if (predicate instanceof CharMatcher) {
                return (CharMatcher) predicate;
            }
            return new CharMatcher() {
                @Override public boolean matches(char c) {
                    return predicate.apply(c);
                }

                @Override public boolean apply(Character character) {
                    return predicate.apply(checkNotNull(character));
                }
            };
        }


        public abstract boolean matches(char c);

        // Non-static factories


        public CharMatcher negate() {
            final CharMatcher original = this;
            return new CharMatcher() {
                @Override public boolean matches(char c) {
                    return !original.matches(c);
                }

                @Override public boolean matchesAllOf(CharSequence sequence) {
                    return original.matchesNoneOf(sequence);
                }

                @Override public boolean matchesNoneOf(CharSequence sequence) {
                    return original.matchesAllOf(sequence);
                }

                @Override public int countIn(CharSequence sequence) {
                    return sequence.length() - original.countIn(sequence);
                }

                @Override public CharMatcher negate() {
                    return original;
                }
            };
        }


        public CharMatcher and(CharMatcher other) {
            return new And(Arrays.asList(this, checkNotNull(other)));
        }

        private static class And extends CharMatcher {
            List<CharMatcher> components;

            And(List<CharMatcher> components) {
                this.components = components; // Skip defensive copy (private)
            }

            @Override public boolean matches(char c) {
                for (CharMatcher matcher : components) {
                    if (!matcher.matches(c)) {
                        return false;
                    }
                }
                return true;
            }

            @Override public CharMatcher and(CharMatcher other) {
                List<CharMatcher> newComponents = new ArrayList<CharMatcher>(components);
                newComponents.add(checkNotNull(other));
                return new And(newComponents);
            }
        }


        public CharMatcher or(CharMatcher other) {
            return new Or(Arrays.asList(this, checkNotNull(other)));
        }

        private static class Or extends CharMatcher {
            List<CharMatcher> components;

            Or(List<CharMatcher> components) {
                this.components = components; // Skip defensive copy (private)
            }

            @Override public boolean matches(char c) {
                for (CharMatcher matcher : components) {
                    if (matcher.matches(c)) {
                        return true;
                    }
                }
                return false;
            }

            @Override public CharMatcher or(CharMatcher other) {
                List<CharMatcher> newComponents = new ArrayList<CharMatcher>(components);
                newComponents.add(checkNotNull(other));
                return new Or(newComponents);
            }

            @Override void setBits(LookupTable table) {
                for (CharMatcher matcher : components) {
                    matcher.setBits(table);
                }
            }
        }

        public CharMatcher precomputed() {
            return Platform.precomputeCharMatcher(this);
        }

        CharMatcher precomputedInternal() {
            final LookupTable table = new LookupTable();
            setBits(table);

            return new CharMatcher() {
                @Override public boolean matches(char c) {
                    return table.get(c);
                }

                // TODO(kevinb): make methods like negate() smart?

                @Override public CharMatcher precomputed() {
                    return this;
                }
            };
        }


        void setBits(LookupTable table) {
            char c = Character.MIN_VALUE;
            while (true) {
                if (matches(c)) {
                    table.set(c);
                }
                if (c++ == Character.MAX_VALUE) {
                    break;
                }
            }
        }

        private static final class LookupTable {
            int[] data = new int[2048];

            void set(char index) {
                data[index >> 5] |= (1 << index);
            }

            boolean get(char index) {
                return (data[index >> 5] & (1 << index)) != 0;
            }
        }

        // Text processing routines

        public boolean matchesAnyOf(CharSequence sequence) {
            return !matchesNoneOf(sequence);
        }


        public boolean matchesAllOf(CharSequence sequence) {
            for (int i = sequence.length() - 1; i >= 0; i--) {
                if (!matches(sequence.charAt(i))) {
                    return false;
                }
            }
            return true;
        }

        public boolean matchesNoneOf(CharSequence sequence) {
            return indexIn(sequence) == -1;
        }

        // TODO(kevinb): add matchesAnyOf()


        public int indexIn(CharSequence sequence) {
            int length = sequence.length();
            for (int i = 0; i < length; i++) {
                if (matches(sequence.charAt(i))) {
                    return i;
                }
            }
            return -1;
        }

        public int indexIn(CharSequence sequence, int start) {
            int length = sequence.length();
            Preconditions.checkPositionIndex(start, length);
            for (int i = start; i < length; i++) {
                if (matches(sequence.charAt(i))) {
                    return i;
                }
            }
            return -1;
        }

        public int lastIndexIn(CharSequence sequence) {
            for (int i = sequence.length() - 1; i >= 0; i--) {
                if (matches(sequence.charAt(i))) {
                    return i;
                }
            }
            return -1;
        }


        public int countIn(CharSequence sequence) {
            int count = 0;
            for (int i = 0; i < sequence.length(); i++) {
                if (matches(sequence.charAt(i))) {
                    count++;
                }
            }
            return count;
        }

        public String removeFrom(CharSequence sequence) {
            String string = sequence.toString();
            int pos = indexIn(string);
            if (pos == -1) {
                return string;
            }

            char[] chars = string.toCharArray();
            int spread = 1;

            // This unusual loop comes from extensive benchmarking
            OUT: while (true) {
                pos++;
                while (true) {
                    if (pos == chars.length) {
                        break OUT;
                    }
                    if (matches(chars[pos])) {
                        break;
                    }
                    chars[pos - spread] = chars[pos];
                    pos++;
                }
                spread++;
            }
            return new String(chars, 0, pos - spread);
        }

        public String retainFrom(CharSequence sequence) {
            return negate().removeFrom(sequence);
        }


        public String replaceFrom(CharSequence sequence, char replacement) {
            String string = sequence.toString();
            int pos = indexIn(string);
            if (pos == -1) {
                return string;
            }
            char[] chars = string.toCharArray();
            chars[pos] = replacement;
            for (int i = pos + 1; i < chars.length; i++) {
                if (matches(chars[i])) {
                    chars[i] = replacement;
                }
            }
            return new String(chars);
        }


        public String replaceFrom(CharSequence sequence, CharSequence replacement) {
            int replacementLen = replacement.length();
            if (replacementLen == 0) {
                return removeFrom(sequence);
            }
            if (replacementLen == 1) {
                return replaceFrom(sequence, replacement.charAt(0));
            }

            String string = sequence.toString();
            int pos = indexIn(string);
            if (pos == -1) {
                return string;
            }

            int len = string.length();
            StringBuilder buf = new StringBuilder((len * 3 / 2) + 16);

            int oldpos = 0;
            do {
                buf.append(string, oldpos, pos);
                buf.append(replacement);
                oldpos = pos + 1;
                pos = indexIn(string, oldpos);
            } while (pos != -1);

            buf.append(string, oldpos, len);
            return buf.toString();
        }


        public String trimFrom(CharSequence sequence) {
            int len = sequence.length();
            int first;
            int last;

            for (first = 0; first < len; first++) {
                if (!matches(sequence.charAt(first))) {
                    break;
                }
            }
            for (last = len - 1; last > first; last--) {
                if (!matches(sequence.charAt(last))) {
                    break;
                }
            }

            return sequence.subSequence(first, last + 1).toString();
        }

        public String trimLeadingFrom(CharSequence sequence) {
            int len = sequence.length();
            int first;

            for (first = 0; first < len; first++) {
                if (!matches(sequence.charAt(first))) {
                    break;
                }
            }

            return sequence.subSequence(first, len).toString();
        }

        public String trimTrailingFrom(CharSequence sequence) {
            int len = sequence.length();
            int last;

            for (last = len - 1; last >= 0; last--) {
                if (!matches(sequence.charAt(last))) {
                    break;
                }
            }

            return sequence.subSequence(0, last + 1).toString();
        }

        public String collapseFrom(CharSequence sequence, char replacement) {
            int first = indexIn(sequence);
            if (first == -1) {
                return sequence.toString();
            }

            // TODO(kevinb): see if this implementation can be made faster
            StringBuilder builder = new StringBuilder(sequence.length())
                    .append(sequence.subSequence(0, first))
                    .append(replacement);
            boolean in = true;
            for (int i = first + 1; i < sequence.length(); i++) {
                char c = sequence.charAt(i);
                if (apply(c)) {
                    if (!in) {
                        builder.append(replacement);
                        in = true;
                    }
                } else {
                    builder.append(c);
                    in = false;
                }
            }
            return builder.toString();
        }

        public String trimAndCollapseFrom(CharSequence sequence, char replacement) {
            int first = negate().indexIn(sequence);
            if (first == -1) {
                return ""; // everything matches. nothing's left.
            }
            StringBuilder builder = new StringBuilder(sequence.length());
            boolean inMatchingGroup = false;
            for (int i = first; i < sequence.length(); i++) {
                char c = sequence.charAt(i);
                if (apply(c)) {
                    inMatchingGroup = true;
                } else {
                    if (inMatchingGroup) {
                        builder.append(replacement);
                        inMatchingGroup = false;
                    }
                    builder.append(c);
                }
            }
            return builder.toString();
        }


        @Override public boolean apply(Character character) {
            return matches(character);
        }
    }

    public interface Function<F, T> {

        T apply(@Nullable F input);

        boolean equals(@Nullable Object object);
    }

    @GwtCompatible
    public static final class Functions {
        private Functions() {}

        public static Function<Object, String> toStringFunction() {
            return ToStringFunction.INSTANCE;
        }

        // enum singleton pattern
        private enum ToStringFunction implements Function<Object, String> {
            INSTANCE;

            public String apply(Object o) {
                checkNotNull(o);  // eager for GWT.
                return o.toString();
            }

            @Override public String toString() {
                return "toString";
            }
        }


        @SuppressWarnings("unchecked")
        public static <E> Function<E, E> identity() {
            return (Function<E, E>) IdentityFunction.INSTANCE;
        }

        // enum singleton pattern
        private enum IdentityFunction implements Function<Object, Object> {
            INSTANCE;

            public Object apply(Object o) {
                return o;
            }

            @Override public String toString() {
                return "identity";
            }
        }


        public static <K, V> Function<K, V> forMap(Map<K, V> map) {
            return new FunctionForMapNoDefault<K, V>(map);
        }

        private static class FunctionForMapNoDefault<K, V> implements Function<K, V>, Serializable {
            final Map<K, V> map;

            FunctionForMapNoDefault(Map<K, V> map) {
                this.map = checkNotNull(map);
            }

            public V apply(K key) {
                V result = map.get(key);
                checkArgument(result != null || map.containsKey(key), "Key '%s' not present in map", key);
                return result;
            }

            @Override public boolean equals(@Nullable Object o) {
                if (o instanceof FunctionForMapNoDefault) {
                    FunctionForMapNoDefault<?, ?> that = (FunctionForMapNoDefault<?, ?>) o;
                    return map.equals(that.map);
                }
                return false;
            }

            @Override public int hashCode() {
                return map.hashCode();
            }

            @Override public String toString() {
                return "forMap(" + map + ")";
            }

            private static final long serialVersionUID = 0;
        }


        public static <K, V> Function<K, V> forMap(Map<K, ? extends V> map, @Nullable V defaultValue) {
            return new ForMapWithDefault<K, V>(map, defaultValue);
        }

        private static class ForMapWithDefault<K, V> implements Function<K, V>, Serializable {
            final Map<K, ? extends V> map;
            final V defaultValue;

            ForMapWithDefault(Map<K, ? extends V> map, @Nullable V defaultValue) {
                this.map = checkNotNull(map);
                this.defaultValue = defaultValue;
            }

            public V apply(K key) {
                V result = map.get(key);
                return (result != null || map.containsKey(key)) ? result : defaultValue;
            }

            @Override public boolean equals(@Nullable Object o) {
                if (o instanceof ForMapWithDefault) {
                    ForMapWithDefault<?, ?> that = (ForMapWithDefault<?, ?>) o;
                    return map.equals(that.map) && Objects.equal(defaultValue, that.defaultValue);
                }
                return false;
            }

            @Override public int hashCode() {
                return Objects.hashCode(map, defaultValue);
            }

            @Override public String toString() {
                return "forMap(" + map + ", defaultValue=" + defaultValue + ")";
            }

            private static final long serialVersionUID = 0;
        }


        public static <A, B, C> Function<A, C> compose(Function<B, C> g, Function<A, ? extends B> f) {
            return new FunctionComposition<A, B, C>(g, f);
        }

        private static class FunctionComposition<A, B, C> implements Function<A, C>, Serializable {
            private final Function<B, C> g;
            private final Function<A, ? extends B> f;

            public FunctionComposition(Function<B, C> g, Function<A, ? extends B> f) {
                this.g = checkNotNull(g);
                this.f = checkNotNull(f);
            }

            public C apply(A a) {
                return g.apply(f.apply(a));
            }

            @Override public boolean equals(@Nullable Object obj) {
                if (obj instanceof FunctionComposition) {
                    FunctionComposition<?, ?, ?> that = (FunctionComposition<?, ?, ?>) obj;
                    return f.equals(that.f) && g.equals(that.g);
                }
                return false;
            }

            @Override public int hashCode() {
                return f.hashCode() ^ g.hashCode();
            }

            @Override public String toString() {
                return g.toString() + "(" + f.toString() + ")";
            }

            private static final long serialVersionUID = 0;
        }


        public static <T> Function<T, Boolean> forPredicate(Predicate<T> predicate) {
            return new PredicateFunction<T>(predicate);
        }


        private static class PredicateFunction<T> implements Function<T, Boolean>, Serializable {
            private final Predicate<T> predicate;

            private PredicateFunction(Predicate<T> predicate) {
                this.predicate = checkNotNull(predicate);
            }

            public Boolean apply(T t) {
                return predicate.apply(t);
            }

            @Override public boolean equals(@Nullable Object obj) {
                if (obj instanceof PredicateFunction) {
                    PredicateFunction<?> that = (PredicateFunction<?>) obj;
                    return predicate.equals(that.predicate);
                }
                return false;
            }

            @Override public int hashCode() {
                return predicate.hashCode();
            }

            @Override public String toString() {
                return "forPredicate(" + predicate + ")";
            }

            private static final long serialVersionUID = 0;
        }


        public static <E> Function<Object, E> constant(@Nullable E value) {
            return new ConstantFunction<E>(value);
        }

        private static class ConstantFunction<E> implements Function<Object, E>, Serializable {
            private final E value;

            public ConstantFunction(@Nullable E value) {
                this.value = value;
            }

            public E apply(@Nullable Object from) {
                return value;
            }

            @Override public boolean equals(@Nullable Object obj) {
                if (obj instanceof ConstantFunction) {
                    ConstantFunction<?> that = (ConstantFunction<?>) obj;
                    return Objects.equal(value, that.value);
                }
                return false;
            }

            @Override public int hashCode() {
                return (value == null) ? 0 : value.hashCode();
            }

            @Override public String toString() {
                return "constant(" + value + ")";
            }

            private static final long serialVersionUID = 0;
        }
    }

    public static final class Predicates {
        private Predicates() {}

        // TODO(kevinb): considering having these implement a VisitablePredicate
        // interface which specifies an accept(PredicateVisitor) method.


        @GwtCompatible(serializable = true)
        public static <T> Predicate<T> alwaysTrue() {
            return ObjectPredicate.ALWAYS_TRUE.withNarrowedType();
        }


        @GwtCompatible(serializable = true)
        public static <T> Predicate<T> alwaysFalse() {
            return ObjectPredicate.ALWAYS_FALSE.withNarrowedType();
        }


        @GwtCompatible(serializable = true)
        public static <T> Predicate<T> isNull() {
            return ObjectPredicate.IS_NULL.withNarrowedType();
        }

        @GwtCompatible(serializable = true)
        public static <T> Predicate<T> notNull() {
            return ObjectPredicate.NOT_NULL.withNarrowedType();
        }

        public static <T> Predicate<T> not(Predicate<T> predicate) {
            return new NotPredicate<T>(predicate);
        }


        public static <T> Predicate<T> and(
                Iterable<? extends Predicate<? super T>> components) {
            return new AndPredicate<T>(defensiveCopy(components));
        }


        public static <T> Predicate<T> and(Predicate<? super T>... components) {
            return new AndPredicate<T>(defensiveCopy(components));
        }


        public static <T> Predicate<T> and(Predicate<? super T> first,
                                           Predicate<? super T> second) {
            return new AndPredicate<T>(Predicates.<T>asList(
                    checkNotNull(first), checkNotNull(second)));
        }


        public static <T> Predicate<T> or(
                Iterable<? extends Predicate<? super T>> components) {
            return new OrPredicate<T>(defensiveCopy(components));
        }


        public static <T> Predicate<T> or(Predicate<? super T>... components) {
            return new OrPredicate<T>(defensiveCopy(components));
        }


        public static <T> Predicate<T> or(
                Predicate<? super T> first, Predicate<? super T> second) {
            return new OrPredicate<T>(Predicates.<T>asList(
                    checkNotNull(first), checkNotNull(second)));
        }

        public static <T> Predicate<T> equalTo(@Nullable T target) {
            return (target == null)
                    ? Predicates.<T>isNull()
                    : new IsEqualToPredicate<T>(target);
        }


        @GwtIncompatible("Class.isInstance")
        public static Predicate<Object> instanceOf(Class<?> clazz) {
            return new InstanceOfPredicate(clazz);
        }


        public static <T> Predicate<T> in(Collection<? extends T> target) {
            return new InPredicate<T>(target);
        }


        public static <A, B> Predicate<A> compose(
                Predicate<B> predicate, Function<A, ? extends B> function) {
            return new CompositionPredicate<A, B>(predicate, function);
        }


        @GwtIncompatible(value = "java.util.regex.Pattern")
        public static Predicate<CharSequence> containsPattern(String pattern) {
            return new ContainsPatternPredicate(pattern);
        }


        @GwtIncompatible(value = "java.util.regex.Pattern")
        public static Predicate<CharSequence> contains(Pattern pattern) {
            return new ContainsPatternPredicate(pattern);
        }

        // End public API, begin private implementation classes.

        // Package private for GWT serialization.
        enum ObjectPredicate implements Predicate<Object> {
            ALWAYS_TRUE {
                @Override public boolean apply(@Nullable Object o) {
                    return true;
                }
            },
            ALWAYS_FALSE {
                @Override public boolean apply(@Nullable Object o) {
                    return false;
                }
            },
            IS_NULL {
                @Override public boolean apply(@Nullable Object o) {
                    return o == null;
                }
            },
            NOT_NULL {
                @Override public boolean apply(@Nullable Object o) {
                    return o != null;
                }
            };

            @SuppressWarnings("unchecked") // these Object predicates work for any T
            <T> Predicate<T> withNarrowedType() {
                return (Predicate<T>) this;
            }
        }


        private static class NotPredicate<T> implements Predicate<T>, Serializable {
            final Predicate<T> predicate;

            NotPredicate(Predicate<T> predicate) {
                this.predicate = checkNotNull(predicate);
            }
            public boolean apply(T t) {
                return !predicate.apply(t);
            }
            @Override public int hashCode() {
                return ~predicate.hashCode();
            }
            @Override public boolean equals(@Nullable Object obj) {
                if (obj instanceof NotPredicate) {
                    NotPredicate<?> that = (NotPredicate<?>) obj;
                    return predicate.equals(that.predicate);
                }
                return false;
            }
            @Override public String toString() {
                return "Not(" + predicate.toString() + ")";
            }
            private static final long serialVersionUID = 0;
        }

        private static final Joiner COMMA_JOINER = Joiner.on(",");


        private static class AndPredicate<T> implements Predicate<T>, Serializable {
            private final List<? extends Predicate<? super T>> components;

            private AndPredicate(List<? extends Predicate<? super T>> components) {
                this.components = components;
            }
            public boolean apply(T t) {
                for (Predicate<? super T> predicate : components) {
                    if (!predicate.apply(t)) {
                        return false;
                    }
                }
                return true;
            }
            @Override public int hashCode() {
                // 0x12472c2c is a random number to help avoid collisions with OrPredicate
                return components.hashCode() + 0x12472c2c;
            }
            @Override public boolean equals(@Nullable Object obj) {
                if (obj instanceof AndPredicate) {
                    AndPredicate<?> that = (AndPredicate<?>) obj;
                    return components.equals(that.components);
                }
                return false;
            }
            @Override public String toString() {
                return "And(" + COMMA_JOINER.join(components) + ")";
            }
            private static final long serialVersionUID = 0;
        }


        private static class OrPredicate<T> implements Predicate<T>, Serializable {
            private final List<? extends Predicate<? super T>> components;

            private OrPredicate(List<? extends Predicate<? super T>> components) {
                this.components = components;
            }
            public boolean apply(T t) {
                for (Predicate<? super T> predicate : components) {
                    if (predicate.apply(t)) {
                        return true;
                    }
                }
                return false;
            }
            @Override public int hashCode() {
                // 0x053c91cf is a random number to help avoid collisions with AndPredicate
                return components.hashCode() + 0x053c91cf;
            }
            @Override public boolean equals(@Nullable Object obj) {
                if (obj instanceof OrPredicate) {
                    OrPredicate<?> that = (OrPredicate<?>) obj;
                    return components.equals(that.components);
                }
                return false;
            }
            @Override public String toString() {
                return "Or(" + COMMA_JOINER.join(components) + ")";
            }
            private static final long serialVersionUID = 0;
        }


        private static class IsEqualToPredicate<T>
                implements Predicate<T>, Serializable {
            private final T target;

            private IsEqualToPredicate(T target) {
                this.target = target;
            }
            public boolean apply(T t) {
                return target.equals(t);
            }
            @Override public int hashCode() {
                return target.hashCode();
            }
            @Override public boolean equals(@Nullable Object obj) {
                if (obj instanceof IsEqualToPredicate) {
                    IsEqualToPredicate<?> that = (IsEqualToPredicate<?>) obj;
                    return target.equals(that.target);
                }
                return false;
            }
            @Override public String toString() {
                return "IsEqualTo(" + target + ")";
            }
            private static final long serialVersionUID = 0;
        }

        private static class InstanceOfPredicate
                implements Predicate<Object>, Serializable {
            private final Class<?> clazz;

            private InstanceOfPredicate(Class<?> clazz) {
                this.clazz = checkNotNull(clazz);
            }
            public boolean apply(@Nullable Object o) {
                return Platform.isInstance(clazz, o);
            }
            @Override public int hashCode() {
                return clazz.hashCode();
            }
            @Override public boolean equals(@Nullable Object obj) {
                if (obj instanceof InstanceOfPredicate) {
                    InstanceOfPredicate that = (InstanceOfPredicate) obj;
                    return clazz == that.clazz;
                }
                return false;
            }
            @Override public String toString() {
                return "IsInstanceOf(" + clazz.getName() + ")";
            }
            private static final long serialVersionUID = 0;
        }

        private static class InPredicate<T> implements Predicate<T>, Serializable {
            private final Collection<?> target;

            private InPredicate(Collection<?> target) {
                this.target = checkNotNull(target);
            }

            public boolean apply(T t) {
                try {
                    return target.contains(t);
                } catch (NullPointerException e) {
                    return false;
                } catch (ClassCastException e) {
                    return false;
                }
            }

            @Override public boolean equals(@Nullable Object obj) {
                if (obj instanceof InPredicate) {
                    InPredicate<?> that = (InPredicate<?>) obj;
                    return target.equals(that.target);
                }
                return false;
            }

            @Override public int hashCode() {
                return target.hashCode();
            }

            @Override public String toString() {
                return "In(" + target + ")";
            }
            private static final long serialVersionUID = 0;
        }

        private static class CompositionPredicate<A, B>
                implements Predicate<A>, Serializable {
            final Predicate<B> p;
            final Function<A, ? extends B> f;

            private CompositionPredicate(Predicate<B> p, Function<A, ? extends B> f) {
                this.p = checkNotNull(p);
                this.f = checkNotNull(f);
            }

            public boolean apply(A a) {
                return p.apply(f.apply(a));
            }

            @Override public boolean equals(@Nullable Object obj) {
                if (obj instanceof CompositionPredicate) {
                    CompositionPredicate<?, ?> that = (CompositionPredicate<?, ?>) obj;
                    return f.equals(that.f) && p.equals(that.p);
                }
                return false;
            }

            @Override public int hashCode() {
                return f.hashCode() ^ p.hashCode();
            }

            @Override public String toString() {
                return p.toString() + "(" + f.toString() + ")";
            }

            private static final long serialVersionUID = 0;
        }


        @GwtIncompatible("Only used by other GWT-incompatible code.")
        private static class ContainsPatternPredicate
                implements Predicate<CharSequence>, Serializable {
            final Pattern pattern;

            ContainsPatternPredicate(Pattern pattern) {
                this.pattern = checkNotNull(pattern);
            }

            ContainsPatternPredicate(String patternStr) {
                this(Pattern.compile(patternStr));
            }

            public boolean apply(CharSequence t) {
                return pattern.matcher(t).find();
            }

            @Override public int hashCode() {
                // Pattern uses Object.hashCode, so we have to reach
                // inside to build a hashCode consistent with equals.

                return Objects.hashCode(pattern.pattern(), pattern.flags());
            }

            @Override public boolean equals(@Nullable Object obj) {
                if (obj instanceof ContainsPatternPredicate) {
                    ContainsPatternPredicate that = (ContainsPatternPredicate) obj;

                    // Pattern uses Object (identity) equality, so we have to reach
                    // inside to compare individual fields.
                    return Objects.equal(pattern.pattern(), that.pattern.pattern())
                            && Objects.equal(pattern.flags(), that.pattern.flags());
                }
                return false;
            }

            @Override public String toString() {
                return Objects.toStringHelper(this)
                        .add("pattern", pattern)
                        .add("pattern.flags", Integer.toHexString(pattern.flags()))
                        .toString();
            }

            private static final long serialVersionUID = 0;
        }

        @SuppressWarnings("unchecked")
        private static <T> List<Predicate<? super T>> asList(
                Predicate<? super T> first, Predicate<? super T> second) {
            return Arrays.<Predicate<? super T>>asList(first, second);
        }

        private static <T> List<T> defensiveCopy(T... array) {
            return defensiveCopy(Arrays.asList(array));
        }

        static <T> List<T> defensiveCopy(Iterable<T> iterable) {
            ArrayList<T> list = new ArrayList<T>();
            for (T element : iterable) {
                list.add(checkNotNull(element));
            }
            return list;
        }
    }

    public static abstract class UnmodifiableIterator<E> implements Iterator<E> {

        protected UnmodifiableIterator() {}

        @Override
        public final void remove() {
            throw new UnsupportedOperationException();
        }
    }

    public static abstract class AbstractIterator<T> extends UnmodifiableIterator<T> {
        private State state = State.NOT_READY;


        protected AbstractIterator() {}

        private enum State {

            READY,


            NOT_READY,


            DONE,


            FAILED,
        }

        private T next;

        protected abstract T computeNext();

        protected final T endOfData() {
            state = State.DONE;
            return null;
        }

        @Override
        public final boolean hasNext() {
            checkState(state != State.FAILED);
            switch (state) {
                case DONE:
                    return false;
                case READY:
                    return true;
                default:
            }
            return tryToComputeNext();
        }

        private boolean tryToComputeNext() {
            state = State.FAILED; // temporary pessimism
            next = computeNext();
            if (state != State.DONE) {
                state = State.READY;
                return true;
            }
            return false;
        }

        @Override
        public final T next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            state = State.NOT_READY;
            return next;
        }


        public final T peek() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            return next;
        }
    }

    public static abstract class UnmodifiableListIterator<E>
            extends UnmodifiableIterator<E> implements ListIterator<E> {

        protected UnmodifiableListIterator(){}

        @Override public final void add(E e) {
            throw new UnsupportedOperationException();
        }

        @Override public final void set(E e) {
            throw new UnsupportedOperationException();
        }
    }

    abstract static class AbstractIndexedListIterator<E>
            extends UnmodifiableListIterator<E> {
        private final int size;
        private int position;


        protected abstract E get(int index);


        protected AbstractIndexedListIterator(int size) {
            this(size, 0);
        }


        protected AbstractIndexedListIterator(int size, int position) {
            checkPositionIndex(position, size);
            this.size = size;
            this.position = position;
        }

        @Override
        public final boolean hasNext() {
            return position < size;
        }

        @Override
        public final E next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            return get(position++);
        }

        @Override
        public final int nextIndex() {
            return position;
        }

        @Override
        public final boolean hasPrevious() {
            return position > 0;
        }

        @Override
        public final E previous() {
            if (!hasPrevious()) {
                throw new NoSuchElementException();
            }
            return get(--position);
        }

        @Override
        public final int previousIndex() {
            return position - 1;
        }
    }

    public static final class ObjectArrays {
        private ObjectArrays() {}

        @SuppressWarnings("unchecked")
        @GwtIncompatible("Array.newInstance(Class, int)")
        public static <T> T[] newArray(Class<T> type, int length) {
            return Platform.newArray(type, length);
        }

        public static <T> T[] newArray(T[] reference, int length) {
            return Platform.newArray(reference, length);
        }


        @GwtIncompatible("Array.newInstance(Class, int)")
        public static <T> T[] concat(T[] first, T[] second, Class<T> type) {
            T[] result = newArray(type, first.length + second.length);
            Platform.unsafeArrayCopy(first, 0, result, 0, first.length);
            Platform.unsafeArrayCopy(second, 0, result, first.length, second.length);
            return result;
        }


        public static <T> T[] concat(@Nullable T element, T[] array) {
            T[] result = newArray(array, array.length + 1);
            result[0] = element;
            Platform.unsafeArrayCopy(array, 0, result, 1, array.length);
            return result;
        }


        public static <T> T[] concat(T[] array, @Nullable T element) {
            T[] result = arraysCopyOf(array, array.length + 1);
            result[array.length] = element;
            return result;
        }


        private static <T> T[] arraysCopyOf(T[] original, int newLength) {
            T[] copy = newArray(original, newLength);
            Platform.unsafeArrayCopy(
                    original, 0, copy, 0, Math.min(original.length, newLength));
            return copy;
        }


        static <T> T[] toArrayImpl(Collection<?> c, T[] array) {
            int size = c.size();
            if (array.length < size) {
                array = newArray(array, size);
            }
            fillArray(c, array);
            if (array.length > size) {
                array[size] = null;
            }
            return array;
        }


        static Object[] toArrayImpl(Collection<?> c) {
            return fillArray(c, new Object[c.size()]);
        }

        private static Object[] fillArray(Iterable<?> elements, Object[] array) {
            int i = 0;
            for (Object element : elements) {
                array[i++] = element;
            }
            return array;
        }

        static void swap(Object[] array, int i, int j) {
            Object temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
    }

    public static abstract class ImmutableCollection<E>
            implements Collection<E>, Serializable {
        static final ImmutableCollection<Object> EMPTY_IMMUTABLE_COLLECTION
                = new EmptyImmutableCollection();

        ImmutableCollection() {}


        @Override
        public abstract UnmodifiableIterator<E> iterator();

        @Override
        public Object[] toArray() {
            return ObjectArrays.toArrayImpl(this);
        }

        @Override
        public <T> T[] toArray(T[] other) {
            return ObjectArrays.toArrayImpl(this, other);
        }

        @Override
        public boolean contains(@Nullable Object object) {
            return object != null && Iterators.contains(iterator(), object);
        }

        @Override
        public boolean containsAll(Collection<?> targets) {
            return Collections2.containsAllImpl(this, targets);
        }

        @Override
        public boolean isEmpty() {
            return size() == 0;
        }

        @Override public String toString() {
            return Collections2.toStringImpl(this);
        }


        @Override
        public final boolean add(E e) {
            throw new UnsupportedOperationException();
        }


        @Override
        public final boolean remove(Object object) {
            throw new UnsupportedOperationException();
        }


        @Override
        public final boolean addAll(Collection<? extends E> newElements) {
            throw new UnsupportedOperationException();
        }


        @Override
        public final boolean removeAll(Collection<?> oldElements) {
            throw new UnsupportedOperationException();
        }


        @Override
        public final boolean retainAll(Collection<?> elementsToKeep) {
            throw new UnsupportedOperationException();
        }


        @Override
        public final void clear() {
            throw new UnsupportedOperationException();
        }

        /*
         * TODO(kevinb): Restructure code so ImmutableList doesn't contain this
         * variable, which it doesn't use.
         */
        private transient ImmutableList<E> asList;


        public ImmutableList<E> asList() {
            ImmutableList<E> list = asList;
            return (list == null) ? (asList = createAsList()) : list;
        }

        ImmutableList<E> createAsList() {
            switch (size()) {
                case 0:
                    return ImmutableList.of();
                case 1:
                    return ImmutableList.of(iterator().next());
                default:
                    return new ImmutableAsList<E>(toArray(), this);
            }
        }

        abstract boolean isPartialView();

        private static class EmptyImmutableCollection
                extends ImmutableCollection<Object> {
            @Override
            public int size() {
                return 0;
            }

            @Override public boolean isEmpty() {
                return true;
            }

            @Override public boolean contains(@Nullable Object object) {
                return false;
            }

            @Override public UnmodifiableIterator<Object> iterator() {
                return Iterators.EMPTY_ITERATOR;
            }

            private static final Object[] EMPTY_ARRAY = new Object[0];

            @Override public Object[] toArray() {
                return EMPTY_ARRAY;
            }

            @Override public <T> T[] toArray(T[] array) {
                if (array.length > 0) {
                    array[0] = null;
                }
                return array;
            }

            @Override ImmutableList<Object> createAsList() {
                return ImmutableList.of();
            }

            @Override boolean isPartialView() {
                return false;
            }
        }


        private static class ArrayImmutableCollection<E>
                extends ImmutableCollection<E> {
            private final E[] elements;

            ArrayImmutableCollection(E[] elements) {
                this.elements = elements;
            }

            @Override
            public int size() {
                return elements.length;
            }

            @Override public boolean isEmpty() {
                return false;
            }

            @Override public UnmodifiableIterator<E> iterator() {
                return Iterators.forArray(elements);
            }

            @Override ImmutableList<E> createAsList() {
                return elements.length == 1 ? new SingletonImmutableList<E>(elements[0])
                        : new RegularImmutableList<E>(elements);
            }

            @Override boolean isPartialView() {
                return false;
            }
        }

        /*
         * Serializes ImmutableCollections as their logical contents. This ensures
         * that implementation types do not leak into the serialized representation.
         */
        private static class SerializedForm implements Serializable {
            final Object[] elements;
            SerializedForm(Object[] elements) {
                this.elements = elements;
            }
            Object readResolve() {
                return elements.length == 0
                        ? EMPTY_IMMUTABLE_COLLECTION
                        : new ArrayImmutableCollection<Object>(Platform.clone(elements));
            }
            private static final long serialVersionUID = 0;
        }

        Object writeReplace() {
            return new SerializedForm(toArray());
        }


        abstract static class Builder<E> {

            public abstract Builder<E> add(E element);


            public Builder<E> add(E... elements) {
                for (E element : elements) {
                    add(element);
                }
                return this;
            }


            public Builder<E> addAll(Iterable<? extends E> elements) {
                for (E element : elements) {
                    add(element);
                }
                return this;
            }


            public Builder<E> addAll(Iterator<? extends E> elements) {
                while (elements.hasNext()) {
                    add(elements.next());
                }
                return this;
            }


            public abstract ImmutableCollection<E> build();
        }
    }
    static final class EmptyImmutableList extends ImmutableList<Object> {
        static final EmptyImmutableList INSTANCE = new EmptyImmutableList();
        static final UnmodifiableListIterator<Object> ITERATOR =
                new UnmodifiableListIterator<Object>() {

                    @Override public boolean hasNext() {
                        return false;
                    }

                    @Override public boolean hasPrevious() {
                        return false;
                    }

                    @Override public Object next() {
                        throw new NoSuchElementException();
                    }

                    @Override public int nextIndex() {
                        return 0;
                    }

                    @Override public Object previous() {
                        throw new NoSuchElementException();
                    }

                    @Override public int previousIndex() {
                        return -1;
                    }
                };

        private EmptyImmutableList() {}

        public int size() {
            return 0;
        }

        @Override public boolean isEmpty() {
            return true;
        }

        @Override boolean isPartialView() {
            return false;
        }

        @Override public boolean contains(Object target) {
            return false;
        }

        @Override public UnmodifiableIterator<Object> iterator() {
            return Iterators.emptyIterator();
        }

        private static final Object[] EMPTY_ARRAY = new Object[0];

        @Override public Object[] toArray() {
            return EMPTY_ARRAY;
        }

        @Override public <T> T[] toArray(T[] a) {
            if (a.length > 0) {
                a[0] = null;
            }
            return a;
        }

        public Object get(int index) {
            // guaranteed to fail, but at least we get a consistent message
            checkElementIndex(index, 0);
            throw new AssertionError("unreachable");
        }

        @Override public int indexOf(Object target) {
            return -1;
        }

        @Override public int lastIndexOf(Object target) {
            return -1;
        }

        @Override public ImmutableList<Object> subList(int fromIndex, int toIndex) {
            checkPositionIndexes(fromIndex, toIndex, 0);
            return this;
        }

        @Override public ImmutableList<Object> reverse() {
            return this;
        }

        @Override public UnmodifiableListIterator<Object> listIterator(){
            return ITERATOR;
        }

        @Override public UnmodifiableListIterator<Object> listIterator(int start) {
            checkPositionIndex(start, 0);
            return ITERATOR;
        }

        @Override public boolean containsAll(Collection<?> targets) {
            return targets.isEmpty();
        }

        @Override public boolean equals(@Nullable Object object) {
            if (object instanceof List) {
                List<?> that = (List<?>) object;
                return that.isEmpty();
            }
            return false;
        }

        @Override public int hashCode() {
            return 1;
        }

        @Override public String toString() {
            return "[]";
        }

        Object readResolve() {
            return INSTANCE; // preserve singleton property
        }

        private static final long serialVersionUID = 0;
    }
    public static abstract class ImmutableList<E> extends ImmutableCollection<E>
            implements List<E>, RandomAccess {

        // Casting to any type is safe because the list will never hold any elements.
        @SuppressWarnings("unchecked")
        public static <E> ImmutableList<E> of() {
            return (ImmutableList<E>) EmptyImmutableList.INSTANCE;
        }

        public static <E> ImmutableList<E> of(E element) {
            return new SingletonImmutableList<E>(element);
        }

        public static <E> ImmutableList<E> of(E e1, E e2) {
            return construct(e1, e2);
        }

        public static <E> ImmutableList<E> of(E e1, E e2, E e3) {
            return construct(e1, e2, e3);
        }


        public static <E> ImmutableList<E> of(E e1, E e2, E e3, E e4) {
            return construct(e1, e2, e3, e4);
        }


        public static <E> ImmutableList<E> of(E e1, E e2, E e3, E e4, E e5) {
            return construct(e1, e2, e3, e4, e5);
        }


        public static <E> ImmutableList<E> of(E e1, E e2, E e3, E e4, E e5, E e6) {
            return construct(e1, e2, e3, e4, e5, e6);
        }

        public static <E> ImmutableList<E> of(
                E e1, E e2, E e3, E e4, E e5, E e6, E e7) {
            return construct(e1, e2, e3, e4, e5, e6, e7);
        }


        public static <E> ImmutableList<E> of(
                E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) {
            return construct(e1, e2, e3, e4, e5, e6, e7, e8);
        }

        public static <E> ImmutableList<E> of(
                E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) {
            return construct(e1, e2, e3, e4, e5, e6, e7, e8, e9);
        }


        public static <E> ImmutableList<E> of(
                E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) {
            return construct(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10);
        }


        public static <E> ImmutableList<E> of(
                E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11) {
            return construct(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11);
        }

        // These go up to eleven. After that, you just get the varargs form, and
        // whatever warnings might come along with it. :(


        public static <E> ImmutableList<E> of(
                E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11, E e12,
                E... others) {
            Object[] array = new Object[12 + others.length];
            array[0] = e1;
            array[1] = e2;
            array[2] = e3;
            array[3] = e4;
            array[4] = e5;
            array[5] = e6;
            array[6] = e7;
            array[7] = e8;
            array[8] = e9;
            array[9] = e10;
            array[10] = e11;
            array[11] = e12;
            System.arraycopy(others, 0, array, 12, others.length);
            return construct(array);
        }


        @Deprecated
        public static <E> ImmutableList<E> of(E[] elements) {
            return copyOf(elements);
        }


        public static <E> ImmutableList<E> copyOf(Iterable<? extends E> elements) {
            checkNotNull(elements); // TODO(kevinb): is this here only for GWT?
            return (elements instanceof Collection)
                    ? copyOf(Collections2.cast(elements))
                    : copyOf(elements.iterator());
        }


        public static <E> ImmutableList<E> copyOf(Collection<? extends E> elements) {
            if (elements instanceof ImmutableCollection) {
                @SuppressWarnings("unchecked") // all supported methods are covariant
                        ImmutableList<E> list = ((ImmutableCollection<E>) elements).asList();
                return list.isPartialView() ? copyFromCollection(list) : list;
            }
            return copyFromCollection(elements);
        }


        public static <E> ImmutableList<E> copyOf(Iterator<? extends E> elements) {
            return copyFromCollection(Lists.newArrayList(elements));
        }


        public static <E> ImmutableList<E> copyOf(E[] elements) {
            switch (elements.length) {
                case 0:
                    return ImmutableList.of();
                case 1:
                    return new SingletonImmutableList<E>(elements[0]);
                default:
                    return construct(elements.clone());
            }
        }

        private static <E> ImmutableList<E> copyFromCollection(
                Collection<? extends E> collection) {
            Object[] elements = collection.toArray();
            switch (elements.length) {
                case 0:
                    return of();
                case 1:
                    @SuppressWarnings("unchecked") // collection had only Es in it
                            ImmutableList<E> list = new SingletonImmutableList<E>((E) elements[0]);
                    return list;
                default:
                    // safe to use the array without copying it
                    // as specified by Collection.toArray().
                    return construct(elements);
            }
        }


        private static <E> ImmutableList<E> construct(Object... elements) {
            for (int i = 0; i < elements.length; i++) {
                checkElementNotNull(elements[i], i);
            }
            return new RegularImmutableList<E>(elements);
        }

        // We do this instead of Preconditions.checkNotNull to save boxing and array
        // creation cost.
        private static Object checkElementNotNull(Object element, int index) {
            if (element == null) {
                throw new NullPointerException("at index " + index);
            }
            return element;
        }

        ImmutableList() {}

        // This declaration is needed to make List.iterator() and
        // ImmutableCollection.iterator() consistent.
        @Override public UnmodifiableIterator<E> iterator() {
            return listIterator();
        }

        @Override public UnmodifiableListIterator<E> listIterator() {
            return listIterator(0);
        }

        @Override public abstract UnmodifiableListIterator<E> listIterator(int index);

        // Mark these two methods with @Nullable

        @Override
        public abstract int indexOf(@Nullable Object object);

        @Override
        public abstract int lastIndexOf(@Nullable Object object);

        // constrain the return type to ImmutableList<E>


        @Override
        public abstract ImmutableList<E> subList(int fromIndex, int toIndex);


        @Override
        public final boolean addAll(int index, Collection<? extends E> newElements) {
            throw new UnsupportedOperationException();
        }

        @Override
        public final E set(int index, E element) {
            throw new UnsupportedOperationException();
        }


        @Override
        public final void add(int index, E element) {
            throw new UnsupportedOperationException();
        }


        @Override
        public final E remove(int index) {
            throw new UnsupportedOperationException();
        }


        @Override public ImmutableList<E> asList() {
            return this;
        }


        public ImmutableList<E> reverse() {
            return new ReverseImmutableList<E>(this);
        }

        private static class ReverseImmutableList<E> extends ImmutableList<E> {
            private transient final ImmutableList<E> forwardList;
            private transient final int size;

            ReverseImmutableList(ImmutableList<E> backingList) {
                this.forwardList = backingList;
                this.size = backingList.size();
            }

            private int reverseIndex(int index) {
                return (size - 1) - index;
            }

            private int reversePosition(int index) {
                return size - index;
            }

            @Override public ImmutableList<E> reverse() {
                return forwardList;
            }

            @Override public boolean contains(@Nullable Object object) {
                return forwardList.contains(object);
            }

            @Override public boolean containsAll(Collection<?> targets) {
                return forwardList.containsAll(targets);
            }

            @Override public int indexOf(@Nullable Object object) {
                int index = forwardList.lastIndexOf(object);
                return (index >= 0) ? reverseIndex(index) : -1;
            }

            @Override public int lastIndexOf(@Nullable Object object) {
                int index = forwardList.indexOf(object);
                return (index >= 0) ? reverseIndex(index) : -1;
            }

            @Override public ImmutableList<E> subList(int fromIndex, int toIndex) {
                Preconditions.checkPositionIndexes(fromIndex, toIndex, size);
                return forwardList.subList(
                        reversePosition(toIndex), reversePosition(fromIndex)).reverse();
            }

            @Override public E get(int index) {
                Preconditions.checkElementIndex(index, size);
                return forwardList.get(reverseIndex(index));
            }

            @Override public UnmodifiableListIterator<E> listIterator(int index) {
                Preconditions.checkPositionIndex(index, size);
                final UnmodifiableListIterator<E> forward =
                        forwardList.listIterator(reversePosition(index));
                return new UnmodifiableListIterator<E>() {
                    @Override public boolean hasNext() {
                        return forward.hasPrevious();
                    }

                    @Override public boolean hasPrevious() {
                        return forward.hasNext();
                    }

                    @Override public E next() {
                        return forward.previous();
                    }

                    @Override public int nextIndex() {
                        return reverseIndex(forward.previousIndex());
                    }

                    @Override public E previous() {
                        return forward.next();
                    }

                    @Override public int previousIndex() {
                        return reverseIndex(forward.nextIndex());
                    }
                };
            }

            @Override public int size() {
                return size;
            }

            @Override public boolean isEmpty() {
                return forwardList.isEmpty();
            }

            @Override boolean isPartialView() {
                return forwardList.isPartialView();
            }
        }

        @Override public boolean equals(Object obj) {
            return Lists.equalsImpl(this, obj);
        }

        @Override public int hashCode() {
            return Lists.hashCodeImpl(this);
        }

        /*
         * Serializes ImmutableLists as their logical contents. This ensures that
         * implementation types do not leak into the serialized representation.
         */
        private static class SerializedForm implements Serializable {
            final Object[] elements;
            SerializedForm(Object[] elements) {
                this.elements = elements;
            }
            Object readResolve() {
                return copyOf(elements);
            }
            private static final long serialVersionUID = 0;
        }

        private void readObject(ObjectInputStream stream)
                throws InvalidObjectException {
            throw new InvalidObjectException("Use SerializedForm");
        }

        @Override Object writeReplace() {
            return new SerializedForm(toArray());
        }


        public static <E> Builder<E> builder() {
            return new Builder<E>();
        }


        public static final class Builder<E> extends ImmutableCollection.Builder<E> {
            private final ArrayList<E> contents = Lists.newArrayList();

            public Builder() {}

            @Override public Builder<E> add(E element) {
                contents.add(checkNotNull(element));
                return this;
            }


            @Override public Builder<E> addAll(Iterable<? extends E> elements) {
                if (elements instanceof Collection) {
                    Collection<?> collection = (Collection<?>) elements;
                    contents.ensureCapacity(contents.size() + collection.size());
                }
                super.addAll(elements);
                return this;
            }


            @Override public Builder<E> add(E... elements) {
                contents.ensureCapacity(contents.size() + elements.length);
                super.add(elements);
                return this;
            }


            @Override public Builder<E> addAll(Iterator<? extends E> elements) {
                super.addAll(elements);
                return this;
            }

            @Override public ImmutableList<E> build() {
                return copyOf(contents);
            }
        }
    }

    public static final class Iterators {
        private Iterators() {}

        static final UnmodifiableIterator<Object> EMPTY_ITERATOR
                = new UnmodifiableIterator<Object>() {
            @Override
            public boolean hasNext() {
                return false;
            }
            @Override
            public Object next() {
                throw new NoSuchElementException();
            }
        };


        // Casting to any type is safe since there are no actual elements.
        @SuppressWarnings("unchecked")
        public static <T> UnmodifiableIterator<T> emptyIterator() {
            return (UnmodifiableIterator<T>) EMPTY_ITERATOR;
        }

        private static final Iterator<Object> EMPTY_MODIFIABLE_ITERATOR =
                new Iterator<Object>() {
                    @Override public boolean hasNext() {
                        return false;
                    }

                    @Override public Object next() {
                        throw new NoSuchElementException();
                    }

                    @Override public void remove() {
                        throw new IllegalStateException();
                    }
                };


        // Casting to any type is safe since there are no actual elements.
        @SuppressWarnings("unchecked")
        static <T> Iterator<T> emptyModifiableIterator() {
            return (Iterator<T>) EMPTY_MODIFIABLE_ITERATOR;
        }


        public static <T> UnmodifiableIterator<T> unmodifiableIterator(
                final Iterator<T> iterator) {
            checkNotNull(iterator);
            return new UnmodifiableIterator<T>() {
                @Override
                public boolean hasNext() {
                    return iterator.hasNext();
                }
                @Override
                public T next() {
                    return iterator.next();
                }
            };
        }


        public static int size(Iterator<?> iterator) {
            int count = 0;
            while (iterator.hasNext()) {
                iterator.next();
                count++;
            }
            return count;
        }


        public static boolean contains(Iterator<?> iterator, @Nullable Object element)
        {
            if (element == null) {
                while (iterator.hasNext()) {
                    if (iterator.next() == null) {
                        return true;
                    }
                }
            } else {
                while (iterator.hasNext()) {
                    if (element.equals(iterator.next())) {
                        return true;
                    }
                }
            }
            return false;
        }


        public static boolean removeAll(
                Iterator<?> removeFrom, Collection<?> elementsToRemove) {
            checkNotNull(elementsToRemove);
            boolean modified = false;
            while (removeFrom.hasNext()) {
                if (elementsToRemove.contains(removeFrom.next())) {
                    removeFrom.remove();
                    modified = true;
                }
            }
            return modified;
        }


        public static <T> boolean removeIf(
                Iterator<T> removeFrom, Predicate<? super T> predicate) {
            checkNotNull(predicate);
            boolean modified = false;
            while (removeFrom.hasNext()) {
                if (predicate.apply(removeFrom.next())) {
                    removeFrom.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public static boolean retainAll(
                Iterator<?> removeFrom, Collection<?> elementsToRetain) {
            checkNotNull(elementsToRetain);
            boolean modified = false;
            while (removeFrom.hasNext()) {
                if (!elementsToRetain.contains(removeFrom.next())) {
                    removeFrom.remove();
                    modified = true;
                }
            }
            return modified;
        }


        public static boolean elementsEqual(
                Iterator<?> iterator1, Iterator<?> iterator2) {
            while (iterator1.hasNext()) {
                if (!iterator2.hasNext()) {
                    return false;
                }
                Object o1 = iterator1.next();
                Object o2 = iterator2.next();
                if (!Objects.equal(o1, o2)) {
                    return false;
                }
            }
            return !iterator2.hasNext();
        }


        public static String toString(Iterator<?> iterator) {
            if (!iterator.hasNext()) {
                return "[]";
            }
            StringBuilder builder = new StringBuilder();
            builder.append('[').append(iterator.next());
            while (iterator.hasNext()) {
                builder.append(", ").append(iterator.next());
            }
            return builder.append(']').toString();
        }


        public static <T> T getOnlyElement(Iterator<T> iterator) {
            T first = iterator.next();
            if (!iterator.hasNext()) {
                return first;
            }

            StringBuilder sb = new StringBuilder();
            sb.append("expected one element but was: <" + first);
            for (int i = 0; i < 4 && iterator.hasNext(); i++) {
                sb.append(", " + iterator.next());
            }
            if (iterator.hasNext()) {
                sb.append(", ...");
            }
            sb.append('>');

            throw new IllegalArgumentException(sb.toString());
        }


        public static <T> T getOnlyElement(
                Iterator<T> iterator, @Nullable T defaultValue) {
            return iterator.hasNext() ? getOnlyElement(iterator) : defaultValue;
        }


        @GwtIncompatible("Array.newInstance(Class, int)")
        public static <T> T[] toArray(
                Iterator<? extends T> iterator, Class<T> type) {
            List<T> list = Lists.newArrayList(iterator);
            return Iterables.toArray(list, type);
        }


        public static <T> boolean addAll(
                Collection<T> addTo, Iterator<? extends T> iterator) {
            checkNotNull(addTo);
            boolean wasModified = false;
            while (iterator.hasNext()) {
                wasModified |= addTo.add(iterator.next());
            }
            return wasModified;
        }


        public static int frequency(Iterator<?> iterator, @Nullable Object element) {
            int result = 0;
            if (element == null) {
                while (iterator.hasNext()) {
                    if (iterator.next() == null) {
                        result++;
                    }
                }
            } else {
                while (iterator.hasNext()) {
                    if (element.equals(iterator.next())) {
                        result++;
                    }
                }
            }
            return result;
        }


        public static <T> Iterator<T> cycle(final Iterable<T> iterable) {
            checkNotNull(iterable);
            return new Iterator<T>() {
                Iterator<T> iterator = emptyIterator();
                Iterator<T> removeFrom;

                @Override
                public boolean hasNext() {
                    if (!iterator.hasNext()) {
                        iterator = iterable.iterator();
                    }
                    return iterator.hasNext();
                }
                @Override
                public T next() {
                    if (!hasNext()) {
                        throw new NoSuchElementException();
                    }
                    removeFrom = iterator;
                    return iterator.next();
                }
                @Override
                public void remove() {
                    checkState(removeFrom != null,
                            "no calls to next() since last call to remove()");
                    removeFrom.remove();
                    removeFrom = null;
                }
            };
        }


        public static <T> Iterator<T> cycle(T... elements) {
            return cycle(Lists.newArrayList(elements));
        }


        @SuppressWarnings("unchecked")
        public static <T> Iterator<T> concat(Iterator<? extends T> a,
                                             Iterator<? extends T> b) {
            checkNotNull(a);
            checkNotNull(b);
            return concat(Arrays.asList(a, b).iterator());
        }


        @SuppressWarnings("unchecked")
        public static <T> Iterator<T> concat(Iterator<? extends T> a,
                                             Iterator<? extends T> b, Iterator<? extends T> c) {
            checkNotNull(a);
            checkNotNull(b);
            checkNotNull(c);
            return concat(Arrays.asList(a, b, c).iterator());
        }


        @SuppressWarnings("unchecked")
        public static <T> Iterator<T> concat(Iterator<? extends T> a,
                                             Iterator<? extends T> b, Iterator<? extends T> c,
                                             Iterator<? extends T> d) {
            checkNotNull(a);
            checkNotNull(b);
            checkNotNull(c);
            checkNotNull(d);
            return concat(Arrays.asList(a, b, c, d).iterator());
        }


        public static <T> Iterator<T> concat(Iterator<? extends T>... inputs) {
            return concat(ImmutableList.copyOf(inputs).iterator());
        }


        public static <T> Iterator<T> concat(
                final Iterator<? extends Iterator<? extends T>> inputs) {
            checkNotNull(inputs);
            return new Iterator<T>() {
                Iterator<? extends T> current = emptyIterator();
                Iterator<? extends T> removeFrom;

                @Override
                public boolean hasNext() {
                    // http://code.google.com/p/google-collections/issues/detail?id=151
                    // current.hasNext() might be relatively expensive, worth minimizing.
                    boolean currentHasNext;
                    // checkNotNull eager for GWT
                    // note: it must be here & not where 'current' is assigned,
                    // because otherwise we'll have called inputs.next() before throwing
                    // the first NPE, and the next time around we'll call inputs.next()
                    // again, incorrectly moving beyond the error.
                    while (!(currentHasNext = checkNotNull(current).hasNext())
                            && inputs.hasNext()) {
                        current = inputs.next();
                    }
                    return currentHasNext;
                }
                @Override
                public T next() {
                    if (!hasNext()) {
                        throw new NoSuchElementException();
                    }
                    removeFrom = current;
                    return current.next();
                }
                @Override
                public void remove() {
                    checkState(removeFrom != null,
                            "no calls to next() since last call to remove()");
                    removeFrom.remove();
                    removeFrom = null;
                }
            };
        }

        public static <T> UnmodifiableIterator<List<T>> partition(
                Iterator<T> iterator, int size) {
            return partitionImpl(iterator, size, false);
        }

        public static <T> UnmodifiableIterator<List<T>> paddedPartition(
                Iterator<T> iterator, int size) {
            return partitionImpl(iterator, size, true);
        }

        private static <T> UnmodifiableIterator<List<T>> partitionImpl(
                final Iterator<T> iterator, final int size, final boolean pad) {
            checkNotNull(iterator);
            checkArgument(size > 0);
            return new UnmodifiableIterator<List<T>>() {
                @Override
                public boolean hasNext() {
                    return iterator.hasNext();
                }
                @Override
                public List<T> next() {
                    if (!hasNext()) {
                        throw new NoSuchElementException();
                    }
                    Object[] array = new Object[size];
                    int count = 0;
                    for (; count < size && iterator.hasNext(); count++) {
                        array[count] = iterator.next();
                    }

                    @SuppressWarnings("unchecked") // we only put Ts in it
                            List<T> list = Collections.unmodifiableList(
                            (List<T>) Arrays.asList(array));
                    return (pad || count == size) ? list : list.subList(0, count);
                }
            };
        }

        public static <T> UnmodifiableIterator<T> filter(
                final Iterator<T> unfiltered, final Predicate<? super T> predicate) {
            checkNotNull(unfiltered);
            checkNotNull(predicate);
            return new AbstractIterator<T>() {
                @Override protected T computeNext() {
                    while (unfiltered.hasNext()) {
                        T element = unfiltered.next();
                        if (predicate.apply(element)) {
                            return element;
                        }
                    }
                    return endOfData();
                }
            };
        }


        @SuppressWarnings("unchecked") // can cast to <T> because non-Ts are removed
        @GwtIncompatible("Class.isInstance")
        public static <T> UnmodifiableIterator<T> filter(
                Iterator<?> unfiltered, Class<T> type) {
            return (UnmodifiableIterator<T>)
                    filter(unfiltered, Predicates.instanceOf(type));
        }

        public static <T> boolean any(
                Iterator<T> iterator, Predicate<? super T> predicate) {
            checkNotNull(predicate);
            while (iterator.hasNext()) {
                T element = iterator.next();
                if (predicate.apply(element)) {
                    return true;
                }
            }
            return false;
        }

        public static <T> boolean all(
                Iterator<T> iterator, Predicate<? super T> predicate) {
            checkNotNull(predicate);
            while (iterator.hasNext()) {
                T element = iterator.next();
                if (!predicate.apply(element)) {
                    return false;
                }
            }
            return true;
        }


        public static <T> T find(
                Iterator<T> iterator, Predicate<? super T> predicate) {
            return filter(iterator, predicate).next();
        }


        public static <T> T find(Iterator<T> iterator, Predicate<? super T> predicate,
                                 @Nullable T defaultValue) {
            UnmodifiableIterator<T> filteredIterator = filter(iterator, predicate);
            return filteredIterator.hasNext() ? filteredIterator.next() : defaultValue;
        }


        public static <T> int indexOf(
                Iterator<T> iterator, Predicate<? super T> predicate) {
            checkNotNull(predicate, "predicate");
            int i = 0;
            while (iterator.hasNext()) {
                T current = iterator.next();
                if (predicate.apply(current)) {
                    return i;
                }
                i++;
            }
            return -1;
        }

        public static <F, T> Iterator<T> transform(final Iterator<F> fromIterator,
                                                   final Function<? super F, ? extends T> function) {
            checkNotNull(fromIterator);
            checkNotNull(function);
            return new Iterator<T>() {
                @Override
                public boolean hasNext() {
                    return fromIterator.hasNext();
                }
                @Override
                public T next() {
                    F from = fromIterator.next();
                    return function.apply(from);
                }
                @Override
                public void remove() {
                    fromIterator.remove();
                }
            };
        }

        public static <T> T get(Iterator<T> iterator, int position) {
            checkNonnegative(position);

            int skipped = 0;
            while (iterator.hasNext()) {
                T t = iterator.next();
                if (skipped++ == position) {
                    return t;
                }
            }

            throw new IndexOutOfBoundsException("position (" + position
                    + ") must be less than the number of elements that remained ("
                    + skipped + ")");
        }

        private static void checkNonnegative(int position) {
            if (position < 0) {
                throw new IndexOutOfBoundsException("position (" + position
                        + ") must not be negative");
            }
        }

        public static <T> T get(Iterator<T> iterator, int position,
                                @Nullable T defaultValue) {
            checkNonnegative(position);

            try {
                return get(iterator, position);
            } catch (IndexOutOfBoundsException e) {
                return defaultValue;
            }
        }


        public static <T> T getNext(Iterator<T> iterator, @Nullable T defaultValue) {
            return iterator.hasNext() ? iterator.next() : defaultValue;
        }


        public static <T> T getLast(Iterator<T> iterator) {
            while (true) {
                T current = iterator.next();
                if (!iterator.hasNext()) {
                    return current;
                }
            }
        }


        public static <T> T getLast(Iterator<T> iterator, @Nullable T defaultValue) {
            return iterator.hasNext() ? getLast(iterator) : defaultValue;
        }


        public static <T> int skip(Iterator<T> iterator, int numberToSkip) {
            checkNotNull(iterator);
            checkArgument(numberToSkip >= 0, "number to skip cannot be negative");

            int i;
            for (i = 0; i < numberToSkip && iterator.hasNext(); i++) {
                iterator.next();
            }
            return i;
        }

        public static <T> Iterator<T> limit(
                final Iterator<T> iterator, final int limitSize) {
            checkNotNull(iterator);
            checkArgument(limitSize >= 0, "limit is negative");
            return new Iterator<T>() {
                private int count;

                @Override
                public boolean hasNext() {
                    return count < limitSize && iterator.hasNext();
                }

                @Override
                public T next() {
                    if (!hasNext()) {
                        throw new NoSuchElementException();
                    }
                    count++;
                    return iterator.next();
                }

                @Override
                public void remove() {
                    iterator.remove();
                }
            };
        }


        public static <T> Iterator<T> consumingIterator(final Iterator<T> iterator) {
            checkNotNull(iterator);
            return new UnmodifiableIterator<T>() {
                @Override
                public boolean hasNext() {
                    return iterator.hasNext();
                }

                @Override
                public T next() {
                    T next = iterator.next();
                    iterator.remove();
                    return next;
                }
            };
        }

        // Methods only in Iterators, not in Iterables


        public static <T> UnmodifiableIterator<T> forArray(final T... array) {
            // TODO(kevinb): compare performance with Arrays.asList(array).iterator().
            checkNotNull(array);  // eager for GWT.
            return new AbstractIndexedListIterator<T>(array.length) {
                @Override protected T get(int index) {
                    return array[index];
                }
            };
        }


        static <T> UnmodifiableIterator<T> forArray(
                final T[] array, final int offset, int length) {
            checkArgument(length >= 0);
            int end = offset + length;

            // Technically we should give a slightly more descriptive error on overflow
            Preconditions.checkPositionIndexes(offset, end, array.length);


            return new AbstractIndexedListIterator<T>(length) {
                @Override protected T get(int index) {
                    return array[offset + index];
                }
            };
        }

        public static <T> UnmodifiableIterator<T> singletonIterator(
                @Nullable final T value) {
            return new UnmodifiableIterator<T>() {
                boolean done;
                @Override
                public boolean hasNext() {
                    return !done;
                }
                @Override
                public T next() {
                    if (done) {
                        throw new NoSuchElementException();
                    }
                    done = true;
                    return value;
                }
            };
        }


        public static <T> UnmodifiableIterator<T> forEnumeration(
                final Enumeration<T> enumeration) {
            checkNotNull(enumeration);
            return new UnmodifiableIterator<T>() {
                @Override
                public boolean hasNext() {
                    return enumeration.hasMoreElements();
                }
                @Override
                public T next() {
                    return enumeration.nextElement();
                }
            };
        }


        public static <T> Enumeration<T> asEnumeration(final Iterator<T> iterator) {
            checkNotNull(iterator);
            return new Enumeration<T>() {
                @Override
                public boolean hasMoreElements() {
                    return iterator.hasNext();
                }
                @Override
                public T nextElement() {
                    return iterator.next();
                }
            };
        }


        private static class PeekingImpl<E> implements PeekingIterator<E> {

            private final Iterator<? extends E> iterator;
            private boolean hasPeeked;
            private E peekedElement;

            public PeekingImpl(Iterator<? extends E> iterator) {
                this.iterator = checkNotNull(iterator);
            }

            @Override
            public boolean hasNext() {
                return hasPeeked || iterator.hasNext();
            }

            @Override
            public E next() {
                if (!hasPeeked) {
                    return iterator.next();
                }
                E result = peekedElement;
                hasPeeked = false;
                peekedElement = null;
                return result;
            }

            @Override
            public void remove() {
                checkState(!hasPeeked, "Can't remove after you've peeked at next");
                iterator.remove();
            }

            @Override
            public E peek() {
                if (!hasPeeked) {
                    peekedElement = iterator.next();
                    hasPeeked = true;
                }
                return peekedElement;
            }
        }


        public static <T> PeekingIterator<T> peekingIterator(
                Iterator<? extends T> iterator) {
            if (iterator instanceof PeekingImpl) {
                // Safe to cast <? extends T> to <T> because PeekingImpl only uses T
                // covariantly (and cannot be subclassed to add non-covariant uses).
                @SuppressWarnings("unchecked")
                PeekingImpl<T> peeking = (PeekingImpl<T>) iterator;
                return peeking;
            }
            return new PeekingImpl<T>(iterator);
        }
    }
    public interface PeekingIterator<E> extends Iterator<E> {

        E peek();

        E next();

        void remove();
    }
    public static final class Iterables {
        private Iterables() {}


        public static <T> Iterable<T> unmodifiableIterable(final Iterable<T> iterable)
        {
            checkNotNull(iterable);
            return new Iterable<T>() {
                public Iterator<T> iterator() {
                    return Iterators.unmodifiableIterator(iterable.iterator());
                }
                @Override public String toString() {
                    return iterable.toString();
                }
                // no equals and hashCode; it would break the contract!
            };
        }

        public static int size(Iterable<?> iterable) {
            return (iterable instanceof Collection)
                    ? ((Collection<?>) iterable).size()
                    : Iterators.size(iterable.iterator());
        }

        public static boolean contains(Iterable<?> iterable, @Nullable Object element)
        {
            if (iterable instanceof Collection) {
                Collection<?> collection = (Collection<?>) iterable;
                try {
                    return collection.contains(element);
                } catch (NullPointerException e) {
                    return false;
                } catch (ClassCastException e) {
                    return false;
                }
            }
            return Iterators.contains(iterable.iterator(), element);
        }


        public static boolean removeAll(
                Iterable<?> removeFrom, Collection<?> elementsToRemove) {
            return (removeFrom instanceof Collection)
                    ? ((Collection<?>) removeFrom).removeAll(checkNotNull(elementsToRemove))
                    : Iterators.removeAll(removeFrom.iterator(), elementsToRemove);
        }


        public static boolean retainAll(
                Iterable<?> removeFrom, Collection<?> elementsToRetain) {
            return (removeFrom instanceof Collection)
                    ? ((Collection<?>) removeFrom).retainAll(checkNotNull(elementsToRetain))
                    : Iterators.retainAll(removeFrom.iterator(), elementsToRetain);
        }

        public static <T> boolean removeIf(
                Iterable<T> removeFrom, Predicate<? super T> predicate) {
            if (removeFrom instanceof RandomAccess && removeFrom instanceof List) {
                return removeIfFromRandomAccessList(
                        (List<T>) removeFrom, checkNotNull(predicate));
            }
            return Iterators.removeIf(removeFrom.iterator(), predicate);
        }

        private static <T> boolean removeIfFromRandomAccessList(
                List<T> list, Predicate<? super T> predicate) {
            int from = 0;
            int to = 0;

            for (; from < list.size(); from++) {
                T element = list.get(from);
                if (!predicate.apply(element)) {
                    if (from > to) {
                        list.set(to, element);
                    }
                    to++;
                }
            }

            // Clear the tail of any remaining items
            list.subList(to, list.size()).clear();
            return from != to;
        }

        public static boolean elementsEqual(
                Iterable<?> iterable1, Iterable<?> iterable2) {
            return Iterators.elementsEqual(iterable1.iterator(), iterable2.iterator());
        }

        public static String toString(Iterable<?> iterable) {
            return Iterators.toString(iterable.iterator());
        }

        public static <T> T getOnlyElement(Iterable<T> iterable) {
            return Iterators.getOnlyElement(iterable.iterator());
        }

        public static <T> T getOnlyElement(
                Iterable<T> iterable, @Nullable T defaultValue) {
            return Iterators.getOnlyElement(iterable.iterator(), defaultValue);
        }

        @GwtIncompatible("Array.newInstance(Class, int)")
        public static <T> T[] toArray(Iterable<? extends T> iterable, Class<T> type) {
            Collection<? extends T> collection = toCollection(iterable);
            T[] array = ObjectArrays.newArray(type, collection.size());
            return collection.toArray(array);
        }

        static Object[] toArray(Iterable<?> iterable) {
            return toCollection(iterable).toArray();
        }

        private static <E> Collection<E> toCollection(Iterable<E> iterable) {
            return (iterable instanceof Collection)
                    ? (Collection<E>) iterable
                    : Lists.newArrayList(iterable.iterator());
        }

        public static <T> boolean addAll(
                Collection<T> addTo, Iterable<? extends T> elementsToAdd) {
            if (elementsToAdd instanceof Collection) {
                Collection<? extends T> c = Collections2.cast(elementsToAdd);
                return addTo.addAll(c);
            }
            return Iterators.addAll(addTo, elementsToAdd.iterator());
        }

        public static int frequency(Iterable<?> iterable, @Nullable Object element) {
            if ((iterable instanceof Multiset)) {
                return ((Multiset<?>) iterable).count(element);
            }
            if ((iterable instanceof Set)) {
                return ((Set<?>) iterable).contains(element) ? 1 : 0;
            }
            return Iterators.frequency(iterable.iterator(), element);
        }

        public static <T> Iterable<T> cycle(final Iterable<T> iterable) {
            checkNotNull(iterable);
            return new Iterable<T>() {
                public Iterator<T> iterator() {
                    return Iterators.cycle(iterable);
                }
                @Override public String toString() {
                    return iterable.toString() + " (cycled)";
                }
            };
        }


        public static <T> Iterable<T> cycle(T... elements) {
            return cycle(Lists.newArrayList(elements));
        }

        @SuppressWarnings("unchecked")
        public static <T> Iterable<T> concat(
                Iterable<? extends T> a, Iterable<? extends T> b) {
            checkNotNull(a);
            checkNotNull(b);
            return concat(Arrays.asList(a, b));
        }


        @SuppressWarnings("unchecked")
        public static <T> Iterable<T> concat(Iterable<? extends T> a,
                                             Iterable<? extends T> b, Iterable<? extends T> c) {
            checkNotNull(a);
            checkNotNull(b);
            checkNotNull(c);
            return concat(Arrays.asList(a, b, c));
        }


        @SuppressWarnings("unchecked")
        public static <T> Iterable<T> concat(Iterable<? extends T> a,
                                             Iterable<? extends T> b, Iterable<? extends T> c,
                                             Iterable<? extends T> d) {
            checkNotNull(a);
            checkNotNull(b);
            checkNotNull(c);
            checkNotNull(d);
            return concat(Arrays.asList(a, b, c, d));
        }


        public static <T> Iterable<T> concat(Iterable<? extends T>... inputs) {
            return concat(ImmutableList.copyOf(inputs));
        }


        public static <T> Iterable<T> concat(
                final Iterable<? extends Iterable<? extends T>> inputs) {
            checkNotNull(inputs);
            return new IterableWithToString<T>() {
                public Iterator<T> iterator() {
                    return Iterators.concat(iterators(inputs));
                }
            };
        }

        private static <T> UnmodifiableIterator<Iterator<? extends T>> iterators(
                Iterable<? extends Iterable<? extends T>> iterables) {
            final Iterator<? extends Iterable<? extends T>> iterableIterator =
                    iterables.iterator();
            return new UnmodifiableIterator<Iterator<? extends T>>() {
                public boolean hasNext() {
                    return iterableIterator.hasNext();
                }
                public Iterator<? extends T> next() {
                    return iterableIterator.next().iterator();
                }
            };
        }

        public static <T> Iterable<List<T>> partition(
                final Iterable<T> iterable, final int size) {
            checkNotNull(iterable);
            checkArgument(size > 0);
            return new IterableWithToString<List<T>>() {
                public Iterator<List<T>> iterator() {
                    return Iterators.partition(iterable.iterator(), size);
                }
            };
        }

        public static <T> Iterable<List<T>> paddedPartition(
                final Iterable<T> iterable, final int size) {
            checkNotNull(iterable);
            checkArgument(size > 0);
            return new IterableWithToString<List<T>>() {
                public Iterator<List<T>> iterator() {
                    return Iterators.paddedPartition(iterable.iterator(), size);
                }
            };
        }

        public static <T> Iterable<T> filter(
                final Iterable<T> unfiltered, final Predicate<? super T> predicate) {
            checkNotNull(unfiltered);
            checkNotNull(predicate);
            return new IterableWithToString<T>() {
                public Iterator<T> iterator() {
                    return Iterators.filter(unfiltered.iterator(), predicate);
                }
            };
        }

        @GwtIncompatible("Class.isInstance")
        public static <T> Iterable<T> filter(
                final Iterable<?> unfiltered, final Class<T> type) {
            checkNotNull(unfiltered);
            checkNotNull(type);
            return new IterableWithToString<T>() {
                public Iterator<T> iterator() {
                    return Iterators.filter(unfiltered.iterator(), type);
                }
            };
        }

        public static <T> boolean any(
                Iterable<T> iterable, Predicate<? super T> predicate) {
            return Iterators.any(iterable.iterator(), predicate);
        }

        public static <T> boolean all(
                Iterable<T> iterable, Predicate<? super T> predicate) {
            return Iterators.all(iterable.iterator(), predicate);
        }


        public static <T> T find(Iterable<T> iterable,
                                 Predicate<? super T> predicate) {
            return Iterators.find(iterable.iterator(), predicate);
        }

        public static <T> T find(Iterable<T> iterable,
                                 Predicate<? super T> predicate, @Nullable T defaultValue) {
            return Iterators.find(iterable.iterator(), predicate, defaultValue);
        }


        public static <T> int indexOf(
                Iterable<T> iterable, Predicate<? super T> predicate) {
            return Iterators.indexOf(iterable.iterator(), predicate);
        }

        public static <F, T> Iterable<T> transform(final Iterable<F> fromIterable,
                                                   final Function<? super F, ? extends T> function) {
            checkNotNull(fromIterable);
            checkNotNull(function);
            return new IterableWithToString<T>() {
                public Iterator<T> iterator() {
                    return Iterators.transform(fromIterable.iterator(), function);
                }
            };
        }

        public static <T> T get(Iterable<T> iterable, int position) {
            checkNotNull(iterable);
            if (iterable instanceof List) {
                return ((List<T>) iterable).get(position);
            }

            if (iterable instanceof Collection) {
                // Can check both ends
                Collection<T> collection = (Collection<T>) iterable;
                Preconditions.checkElementIndex(position, collection.size());
            } else {
                // Can only check the lower end
                checkNonnegativeIndex(position);
            }
            return Iterators.get(iterable.iterator(), position);
        }

        private static void checkNonnegativeIndex(int position) {
            if (position < 0) {
                throw new IndexOutOfBoundsException(
                        "position cannot be negative: " + position);
            }
        }

        public static <T> T get(Iterable<T> iterable, int position,
                                @Nullable T defaultValue) {
            checkNotNull(iterable);
            checkNonnegativeIndex(position);

            try {
                return get(iterable, position);
            } catch (IndexOutOfBoundsException e) {
                return defaultValue;
            }
        }

        public static <T> T getFirst(Iterable<T> iterable, @Nullable T defaultValue) {
            return Iterators.getNext(iterable.iterator(), defaultValue);
        }


        public static <T> T getLast(Iterable<T> iterable) {
            // TODO(kevinb): Support a concurrently modified collection?
            if (iterable instanceof List) {
                List<T> list = (List<T>) iterable;
                if (list.isEmpty()) {
                    throw new NoSuchElementException();
                }
                return getLastInNonemptyList(list);
            }

    /*
     * TODO(kevinb): consider whether this "optimization" is worthwhile. Users
     * with SortedSets tend to know they are SortedSets and probably would not
     * call this method.
     */
            if (iterable instanceof SortedSet) {
                SortedSet<T> sortedSet = (SortedSet<T>) iterable;
                return sortedSet.last();
            }

            return Iterators.getLast(iterable.iterator());
        }

        public static <T> T getLast(Iterable<T> iterable, @Nullable T defaultValue) {
            if (iterable instanceof Collection) {
                Collection<T> collection = (Collection<T>) iterable;
                if (collection.isEmpty()) {
                    return defaultValue;
                }
            }

            if (iterable instanceof List) {
                List<T> list = (List<T>) iterable;
                return getLastInNonemptyList(list);
            }

    /*
     * TODO(kevinb): consider whether this "optimization" is worthwhile. Users
     * with SortedSets tend to know they are SortedSets and probably would not
     * call this method.
     */
            if (iterable instanceof SortedSet) {
                SortedSet<T> sortedSet = (SortedSet<T>) iterable;
                return sortedSet.last();
            }

            return Iterators.getLast(iterable.iterator(), defaultValue);
        }

        private static <T> T getLastInNonemptyList(List<T> list) {
            return list.get(list.size() - 1);
        }

        public static <T> Iterable<T> skip(final Iterable<T> iterable,
                                           final int numberToSkip) {
            checkNotNull(iterable);
            checkArgument(numberToSkip >= 0, "number to skip cannot be negative");

            if (iterable instanceof List) {
                final List<T> list = (List<T>) iterable;
                return new IterableWithToString<T>() {
                    public Iterator<T> iterator() {
                        // TODO(kevinb): Support a concurrently modified collection?
                        return (numberToSkip >= list.size())
                                ? Iterators.<T>emptyIterator()
                                : list.subList(numberToSkip, list.size()).iterator();
                    }
                };
            }

            return new IterableWithToString<T>() {
                public Iterator<T> iterator() {
                    final Iterator<T> iterator = iterable.iterator();

                    Iterators.skip(iterator, numberToSkip);

        /*
         * We can't just return the iterator because an immediate call to its
         * remove() method would remove one of the skipped elements instead of
         * throwing an IllegalStateException.
         */
                    return new Iterator<T>() {
                        boolean atStart = true;

                        public boolean hasNext() {
                            return iterator.hasNext();
                        }

                        public T next() {
                            if (!hasNext()) {
                                throw new NoSuchElementException();
                            }

                            try {
                                return iterator.next();
                            } finally {
                                atStart = false;
                            }
                        }

                        public void remove() {
                            if (atStart) {
                                throw new IllegalStateException();
                            }
                            iterator.remove();
                        }
                    };
                }
            };
        }


        public static <T> Iterable<T> limit(
                final Iterable<T> iterable, final int limitSize) {
            checkNotNull(iterable);
            checkArgument(limitSize >= 0, "limit is negative");
            return new IterableWithToString<T>() {
                public Iterator<T> iterator() {
                    return Iterators.limit(iterable.iterator(), limitSize);
                }
            };
        }


        public static <T> Iterable<T> consumingIterable(final Iterable<T> iterable) {
            if (iterable instanceof Queue) {
                return new Iterable<T>() {
                    public Iterator<T> iterator() {
                        return new ConsumingQueueIterator<T>((Queue<T>) iterable);
                    }
                };
            }

            checkNotNull(iterable);

            return new Iterable<T>() {
                public Iterator<T> iterator() {
                    return Iterators.consumingIterator(iterable.iterator());
                }
            };
        }

        private static class ConsumingQueueIterator<T> extends AbstractIterator<T> {
            private final Queue<T> queue;

            private ConsumingQueueIterator(Queue<T> queue) {
                this.queue = queue;
            }

            @Override public T computeNext() {
                try {
                    return queue.remove();
                } catch (NoSuchElementException e) {
                    return endOfData();
                }
            }
        }

        // Methods only in Iterables, not in Iterators

        @Deprecated
        public static <T> Iterable<T> reverse(final List<T> list) {
            return Lists.reverse(list);
        }

        public static <T> boolean isEmpty(Iterable<T> iterable) {
            return !iterable.iterator().hasNext();
        }

        // Non-public

        static boolean remove(Iterable<?> iterable, @Nullable Object o) {
            Iterator<?> i = iterable.iterator();
            while (i.hasNext()) {
                if (Objects.equal(i.next(), o)) {
                    i.remove();
                    return true;
                }
            }
            return false;
        }

        abstract static class IterableWithToString<E> implements Iterable<E> {
            @Override public String toString() {
                return Iterables.toString(this);
            }
        }
    }

    public static final class Collections2 {
        private Collections2() {}

        public static <E> Collection<E> filter(
                Collection<E> unfiltered, Predicate<? super E> predicate) {
            if (unfiltered instanceof FilteredCollection) {
                // Support clear(), removeAll(), and retainAll() when filtering a filtered
                // collection.
                return ((FilteredCollection<E>) unfiltered).createCombined(predicate);
            }

            return new FilteredCollection<E>(
                    checkNotNull(unfiltered), checkNotNull(predicate));
        }

        static boolean safeContains(Collection<?> collection, Object object) {
            try {
                return collection.contains(object);
            } catch (ClassCastException e) {
                return false;
            }
        }

        static class FilteredCollection<E> implements Collection<E> {
            final Collection<E> unfiltered;
            final Predicate<? super E> predicate;

            FilteredCollection(Collection<E> unfiltered,
                               Predicate<? super E> predicate) {
                this.unfiltered = unfiltered;
                this.predicate = predicate;
            }

            FilteredCollection<E> createCombined(Predicate<? super E> newPredicate) {
                return new FilteredCollection<E>(unfiltered,
                        Predicates.<E>and(predicate, newPredicate));
                // .<E> above needed to compile in JDK 5
            }

            public boolean add(E element) {
                checkArgument(predicate.apply(element));
                return unfiltered.add(element);
            }

            public boolean addAll(Collection<? extends E> collection) {
                for (E element : collection) {
                    checkArgument(predicate.apply(element));
                }
                return unfiltered.addAll(collection);
            }

            public void clear() {
                Iterables.removeIf(unfiltered, predicate);
            }

            public boolean contains(Object element) {
                try {
                    // unsafe cast can result in a CCE from predicate.apply(), which we
                    // will catch
                    @SuppressWarnings("unchecked")
                    E e = (E) element;

        /*
         * We check whether e satisfies the predicate, when we really mean to
         * check whether the element contained in the set does. This is ok as
         * long as the predicate is consistent with equals, as required.
         */
                    return predicate.apply(e) && unfiltered.contains(element);
                } catch (NullPointerException e) {
                    return false;
                } catch (ClassCastException e) {
                    return false;
                }
            }

            public boolean containsAll(Collection<?> collection) {
                for (Object element : collection) {
                    if (!contains(element)) {
                        return false;
                    }
                }
                return true;
            }

            public boolean isEmpty() {
                return !Iterators.any(unfiltered.iterator(), predicate);
            }

            public Iterator<E> iterator() {
                return Iterators.filter(unfiltered.iterator(), predicate);
            }

            public boolean remove(Object element) {
                try {
                    // unsafe cast can result in a CCE from predicate.apply(), which we
                    // will catch
                    @SuppressWarnings("unchecked")
                    E e = (E) element;

                    // See comment in contains() concerning predicate.apply(e)
                    return predicate.apply(e) && unfiltered.remove(element);
                } catch (NullPointerException e) {
                    return false;
                } catch (ClassCastException e) {
                    return false;
                }
            }

            public boolean removeAll(final Collection<?> collection) {
                checkNotNull(collection);
                Predicate<E> combinedPredicate = new Predicate<E>() {
                    public boolean apply(E input) {
                        return predicate.apply(input) && collection.contains(input);
                    }
                };
                return Iterables.removeIf(unfiltered, combinedPredicate);
            }

            public boolean retainAll(final Collection<?> collection) {
                checkNotNull(collection);
                Predicate<E> combinedPredicate = new Predicate<E>() {
                    public boolean apply(E input) {
                        // See comment in contains() concerning predicate.apply(e)
                        return predicate.apply(input) && !collection.contains(input);
                    }
                };
                return Iterables.removeIf(unfiltered, combinedPredicate);
            }

            public int size() {
                return Iterators.size(iterator());
            }

            public Object[] toArray() {
                // creating an ArrayList so filtering happens once
                return Lists.newArrayList(iterator()).toArray();
            }

            public <T> T[] toArray(T[] array) {
                return Lists.newArrayList(iterator()).toArray(array);
            }

            @Override public String toString() {
                return Iterators.toString(iterator());
            }
        }


        public static <F, T> Collection<T> transform(Collection<F> fromCollection,
                                                     Function<? super F, T> function) {
            return new TransformedCollection<F, T>(fromCollection, function);
        }

        static class TransformedCollection<F, T> extends AbstractCollection<T> {
            final Collection<F> fromCollection;
            final Function<? super F, ? extends T> function;

            TransformedCollection(Collection<F> fromCollection,
                                  Function<? super F, ? extends T> function) {
                this.fromCollection = checkNotNull(fromCollection);
                this.function = checkNotNull(function);
            }

            @Override public void clear() {
                fromCollection.clear();
            }

            @Override public boolean isEmpty() {
                return fromCollection.isEmpty();
            }

            @Override public Iterator<T> iterator() {
                return Iterators.transform(fromCollection.iterator(), function);
            }

            @Override public int size() {
                return fromCollection.size();
            }
        }

        static boolean containsAllImpl(Collection<?> self, Collection<?> c) {
            checkNotNull(self);
            for (Object o : c) {
                if (!self.contains(o)) {
                    return false;
                }
            }
            return true;
        }

        static String toStringImpl(final Collection<?> collection) {
            StringBuilder sb
                    = newStringBuilderForCollection(collection.size()).append('[');
            STANDARD_JOINER.appendTo(
                    sb, Iterables.transform(collection, new Function<Object, Object>() {
                @Override public Object apply(Object input) {
                    return input == collection ? "(this Collection)" : input;
                }
            }));
            return sb.append(']').toString();
        }

        static StringBuilder newStringBuilderForCollection(int size) {
            checkArgument(size >= 0, "size must be non-negative");
            return new StringBuilder((int) Math.min(size * 8L, 1 << 30));
        }


        static <T> Collection<T> cast(Iterable<T> iterable) {
            return (Collection<T>) iterable;
        }

        static final Joiner STANDARD_JOINER = Joiner.on(", ");
    }

    public static class Joiner {

        public static Joiner on(String separator) {
            return new Joiner(separator);
        }


        public static Joiner on(char separator) {
            return new Joiner(String.valueOf(separator));
        }

        private final String separator;

        private Joiner(String separator) {
            this.separator = checkNotNull(separator);
        }

        private Joiner(Joiner prototype) {
            this.separator = prototype.separator;
        }


        public <A extends Appendable> A appendTo(A appendable, Iterable<?> parts) throws IOException {
            checkNotNull(appendable);
            Iterator<?> iterator = parts.iterator();
            if (iterator.hasNext()) {
                appendable.append(toString(iterator.next()));
                while (iterator.hasNext()) {
                    appendable.append(separator);
                    appendable.append(toString(iterator.next()));
                }
            }
            return appendable;
        }


        public final <A extends Appendable> A appendTo(A appendable, Object[] parts) throws IOException {
            return appendTo(appendable, Arrays.asList(parts));
        }


        public final <A extends Appendable> A appendTo(
                A appendable, @Nullable Object first, @Nullable Object second, Object... rest)
                throws IOException {
            return appendTo(appendable, iterable(first, second, rest));
        }


        public final StringBuilder appendTo(StringBuilder builder, Iterable<?> parts) {
            try {
                appendTo((Appendable) builder, parts);
            } catch (IOException impossible) {
                throw new AssertionError(impossible);
            }
            return builder;
        }


        public final StringBuilder appendTo(StringBuilder builder, Object[] parts) {
            return appendTo(builder, Arrays.asList(parts));
        }


        public final StringBuilder appendTo(
                StringBuilder builder, @Nullable Object first, @Nullable Object second, Object... rest) {
            return appendTo(builder, iterable(first, second, rest));
        }


        public final String join(Iterable<?> parts) {
            return appendTo(new StringBuilder(), parts).toString();
        }

        public final String join(Object[] parts) {
            return join(Arrays.asList(parts));
        }


        public final String join(@Nullable Object first, @Nullable Object second, Object... rest) {
            return join(iterable(first, second, rest));
        }


        public Joiner useForNull(final String nullText) {
            checkNotNull(nullText);
            return new Joiner(this) {
                @Override CharSequence toString(Object part) {
                    return (part == null) ? nullText : Joiner.this.toString(part);
                }

                @Override public Joiner useForNull(String nullText) {
                    checkNotNull(nullText); // weird: just to satisfy NullPointerTester.
                    throw new UnsupportedOperationException("already specified useForNull");
                }

                @Override public Joiner skipNulls() {
                    throw new UnsupportedOperationException("already specified useForNull");
                }
            };
        }


        public Joiner skipNulls() {
            return new Joiner(this) {
                @Override public <A extends Appendable> A appendTo(A appendable, Iterable<?> parts)
                        throws IOException {
                    checkNotNull(appendable, "appendable");
                    checkNotNull(parts, "parts");
                    Iterator<?> iterator = parts.iterator();
                    while (iterator.hasNext()) {
                        Object part = iterator.next();
                        if (part != null) {
                            appendable.append(Joiner.this.toString(part));
                            break;
                        }
                    }
                    while (iterator.hasNext()) {
                        Object part = iterator.next();
                        if (part != null) {
                            appendable.append(separator);
                            appendable.append(Joiner.this.toString(part));
                        }
                    }
                    return appendable;
                }

                @Override public Joiner useForNull(String nullText) {
                    checkNotNull(nullText); // weird: just to satisfy NullPointerTester.
                    throw new UnsupportedOperationException("already specified skipNulls");
                }

                @Override public MapJoiner withKeyValueSeparator(String kvs) {
                    checkNotNull(kvs); // weird: just to satisfy NullPointerTester.
                    throw new UnsupportedOperationException("can't use .skipNulls() with maps");
                }
            };
        }

        public MapJoiner withKeyValueSeparator(String keyValueSeparator) {
            return new MapJoiner(this, keyValueSeparator);
        }


        public final static class MapJoiner {
            private final Joiner joiner;
            private final String keyValueSeparator;

            private MapJoiner(Joiner joiner, String keyValueSeparator) {
                this.joiner = joiner; // only "this" is ever passed, so don't checkNotNull
                this.keyValueSeparator = checkNotNull(keyValueSeparator);
            }

            public <A extends Appendable> A appendTo(A appendable, Map<?, ?> map) throws IOException {
                checkNotNull(appendable);
                Iterator<? extends Map.Entry<?, ?>> iterator = map.entrySet().iterator();
                if (iterator.hasNext()) {
                    Map.Entry<?, ?> entry = iterator.next();
                    appendable.append(joiner.toString(entry.getKey()));
                    appendable.append(keyValueSeparator);
                    appendable.append(joiner.toString(entry.getValue()));
                    while (iterator.hasNext()) {
                        appendable.append(joiner.separator);
                        Map.Entry<?, ?> e = iterator.next();
                        appendable.append(joiner.toString(e.getKey()));
                        appendable.append(keyValueSeparator);
                        appendable.append(joiner.toString(e.getValue()));
                    }
                }
                return appendable;
            }


            public StringBuilder appendTo(StringBuilder builder, Map<?, ?> map) {
                try {
                    appendTo((Appendable) builder, map);
                } catch (IOException impossible) {
                    throw new AssertionError(impossible);
                }
                return builder;
            }


            public String join(Map<?, ?> map) {
                return appendTo(new StringBuilder(), map).toString();
            }


            public MapJoiner useForNull(String nullText) {
                return new MapJoiner(joiner.useForNull(nullText), keyValueSeparator);
            }
        }

        CharSequence toString(Object part) {
            return (part instanceof CharSequence) ? (CharSequence) part : part.toString();
        }

        private static Iterable<Object> iterable(
                final Object first, final Object second, final Object[] rest) {
            checkNotNull(rest);
            return new AbstractList<Object>() {
                @Override public int size() {
                    return rest.length + 2;
                }

                @Override public Object get(int index) {
                    switch (index) {
                        case 0:
                            return first;
                        case 1:
                            return second;
                        default:
                            return rest[index - 2];
                    }
                }
            };
        }
    }

    @GwtCompatible
    public static final class Objects {
        private Objects() {}

        public static boolean equal(@Nullable Object a, @Nullable Object b) {
            return a == b || (a != null && a.equals(b));
        }


        public static int hashCode(Object... objects) {
            return Arrays.hashCode(objects);
        }


        public static ToStringHelper toStringHelper(Object self) {
            return new ToStringHelper(simpleName(self.getClass()));
        }


        public static ToStringHelper toStringHelper(Class<?> clazz) {
            return new ToStringHelper(simpleName(clazz));
        }

        public static ToStringHelper toStringHelper(String className) {
            return new ToStringHelper(className);
        }

        private static String simpleName(Class<?> clazz) {
            String name = clazz.getName();

            // we want the name of the inner class all by its lonesome
            int start = name.lastIndexOf('$');

            // if this isn't an inner class, just find the start of the
            // top level class name.
            if (start == -1) {
                start = name.lastIndexOf('.');
            }
            return name.substring(start + 1);
        }

        public static <T> T firstNonNull(@Nullable T first, @Nullable T second) {
            return first != null ? first : checkNotNull(second);
        }

        public static final class ToStringHelper {
            private final StringBuilder builder;
            private String separator = "";

            private ToStringHelper(String className) {
                this.builder = new StringBuilder(32)
                        .append(checkNotNull(className))
                        .append('{');
            }

            public ToStringHelper add(String name, @Nullable Object value) {
                builder.append(separator)
                        .append(checkNotNull(name))
                        .append('=')
                        .append(value);
                separator = ", ";
                return this;
            }

            public ToStringHelper addValue(@Nullable Object value) {
                builder.append(separator).append(value);
                separator = ", ";
                return this;
            }

            @Override public String toString() {
                return builder.append('}').toString();
            }
        }
    }

    public static final class Lists {
        private Lists() {}

        // ArrayList
        public static <E> ArrayList<E> newArrayList() {
            return new ArrayList<E>();
        }

        public static <E> ArrayList<E> newArrayList(E... elements) {
            checkNotNull(elements); // for GWT
            // Avoid integer overflow when a large array is passed in
            int capacity = computeArrayListCapacity(elements.length);
            ArrayList<E> list = new ArrayList<E>(capacity);
            Collections.addAll(list, elements);
            return list;
        }

        static int computeArrayListCapacity(int arraySize) {
            checkArgument(arraySize >= 0);

            // TODO(kevinb): Figure out the right behavior, and document it
            return Ints.saturatedCast(5L + arraySize + (arraySize / 10));
        }


        public static <E> ArrayList<E> newArrayList(Iterable<? extends E> elements) {
            checkNotNull(elements); // for GWT
            // Let ArrayList's sizing logic work, if possible
            return (elements instanceof Collection)
                    ? new ArrayList<E>(Collections2.cast(elements))
                    : newArrayList(elements.iterator());
        }


        public static <E> ArrayList<E> newArrayList(Iterator<? extends E> elements) {
            checkNotNull(elements); // for GWT
            ArrayList<E> list = newArrayList();
            while (elements.hasNext()) {
                list.add(elements.next());
            }
            return list;
        }


        public static <E> ArrayList<E> newArrayListWithCapacity(
                int initialArraySize) {
            checkArgument(initialArraySize >= 0);  // for GWT.
            return new ArrayList<E>(initialArraySize);
        }


        public static <E> ArrayList<E> newArrayListWithExpectedSize(
                int estimatedSize) {
            return new ArrayList<E>(computeArrayListCapacity(estimatedSize));
        }

        // LinkedList


        public static <E> LinkedList<E> newLinkedList() {
            return new LinkedList<E>();
        }


        public static <E> LinkedList<E> newLinkedList(
                Iterable<? extends E> elements) {
            LinkedList<E> list = newLinkedList();
            for (E element : elements) {
                list.add(element);
            }
            return list;
        }


        public static <E> List<E> asList( E first, E[] rest) {
            return new OnePlusArrayList<E>(first, rest);
        }


        private static class OnePlusArrayList<E> extends AbstractList<E>
                implements Serializable, RandomAccess {
            final E first;
            final E[] rest;

            OnePlusArrayList( E first, E[] rest) {
                this.first = first;
                this.rest = checkNotNull(rest);
            }
            @Override public int size() {
                return rest.length + 1;
            }
            @Override public E get(int index) {
                // check explicitly so the IOOBE will have the right message
                checkElementIndex(index, size());
                return (index == 0) ? first : rest[index - 1];
            }
            private static final long serialVersionUID = 0;
        }


        public static <E> List<E> asList(
                 E first,  E second, E[] rest) {
            return new TwoPlusArrayList<E>(first, second, rest);
        }


        private static class TwoPlusArrayList<E> extends AbstractList<E>
                implements Serializable, RandomAccess {
            final E first;
            final E second;
            final E[] rest;

            TwoPlusArrayList( E first,  E second, E[] rest) {
                this.first = first;
                this.second = second;
                this.rest = checkNotNull(rest);
            }
            @Override public int size() {
                return rest.length + 2;
            }
            @Override public E get(int index) {
                switch (index) {
                    case 0:
                        return first;
                    case 1:
                        return second;
                    default:
                        // check explicitly so the IOOBE will have the right message
                        checkElementIndex(index, size());
                        return rest[index - 2];
                }
            }
            private static final long serialVersionUID = 0;
        }


        public static <F, T> List<T> transform(
                List<F> fromList, Function<? super F, ? extends T> function) {
            return (fromList instanceof RandomAccess)
                    ? new TransformingRandomAccessList<F, T>(fromList, function)
                    : new TransformingSequentialList<F, T>(fromList, function);
        }

        private static class TransformingSequentialList<F, T>
                extends AbstractSequentialList<T> implements Serializable {
            final List<F> fromList;
            final Function<? super F, ? extends T> function;

            TransformingSequentialList(
                    List<F> fromList, Function<? super F, ? extends T> function) {
                this.fromList = checkNotNull(fromList);
                this.function = checkNotNull(function);
            }

            @Override public void clear() {
                fromList.clear();
            }
            @Override public int size() {
                return fromList.size();
            }
            @Override public ListIterator<T> listIterator(final int index) {
                final ListIterator<F> delegate = fromList.listIterator(index);
                return new ListIterator<T>() {
                    public void add(T e) {
                        throw new UnsupportedOperationException();
                    }

                    public boolean hasNext() {
                        return delegate.hasNext();
                    }

                    public boolean hasPrevious() {
                        return delegate.hasPrevious();
                    }

                    public T next() {
                        return function.apply(delegate.next());
                    }

                    public int nextIndex() {
                        return delegate.nextIndex();
                    }

                    public T previous() {
                        return function.apply(delegate.previous());
                    }

                    public int previousIndex() {
                        return delegate.previousIndex();
                    }

                    public void remove() {
                        delegate.remove();
                    }

                    public void set(T e) {
                        throw new UnsupportedOperationException("not supported");
                    }
                };
            }

            private static final long serialVersionUID = 0;
        }

        private static class TransformingRandomAccessList<F, T>
                extends AbstractList<T> implements RandomAccess, Serializable {
            final List<F> fromList;
            final Function<? super F, ? extends T> function;

            TransformingRandomAccessList(
                    List<F> fromList, Function<? super F, ? extends T> function) {
                this.fromList = checkNotNull(fromList);
                this.function = checkNotNull(function);
            }
            @Override public void clear() {
                fromList.clear();
            }
            @Override public T get(int index) {
                return function.apply(fromList.get(index));
            }
            @Override public boolean isEmpty() {
                return fromList.isEmpty();
            }
            @Override public T remove(int index) {
                return function.apply(fromList.remove(index));
            }
            @Override public int size() {
                return fromList.size();
            }
            private static final long serialVersionUID = 0;
        }

        public static <T> List<List<T>> partition(List<T> list, int size) {
            checkNotNull(list);
            checkArgument(size > 0);
            return (list instanceof RandomAccess)
                    ? new RandomAccessPartition<T>(list, size)
                    : new Partition<T>(list, size);
        }

        private static class Partition<T> extends AbstractList<List<T>> {
            final List<T> list;
            final int size;

            Partition(List<T> list, int size) {
                this.list = list;
                this.size = size;
            }

            @Override public List<T> get(int index) {
                int listSize = size();
                checkElementIndex(index, listSize);
                int start = index * size;
                int end = Math.min(start + size, list.size());
                return list.subList(start, end);
            }

            @Override public int size() {
                return (list.size() + size - 1) / size;
            }

            @Override public boolean isEmpty() {
                return list.isEmpty();
            }
        }

        private static class RandomAccessPartition<T> extends Partition<T>
                implements RandomAccess {
            RandomAccessPartition(List<T> list, int size) {
                super(list, size);
            }
        }

        @Beta public static ImmutableList<Character> charactersOf(String string) {
            return new StringAsImmutableList(checkNotNull(string));
        }

        @SuppressWarnings("serial") // serialized using ImmutableList serialization
        private static final class StringAsImmutableList
                extends ImmutableList<Character> {

            private final String string;

            StringAsImmutableList(String string) {
                this.string = string;
            }

            @Override public boolean contains(@Nullable Object object) {
                return indexOf(object) >= 0;
            }

            @Override public int indexOf(@Nullable Object object) {
                return (object instanceof Character)
                        ? string.indexOf((Character) object) : -1;
            }

            @Override public int lastIndexOf(@Nullable Object object) {
                return (object instanceof Character)
                        ? string.lastIndexOf((Character) object) : -1;
            }

            @Override public UnmodifiableListIterator<Character> listIterator(
                    int index) {
                return new AbstractIndexedListIterator<Character>(size(), index) {
                    @Override protected Character get(int index) {
                        return string.charAt(index);
                    }
                };
            }

            @Override public ImmutableList<Character> subList(
                    int fromIndex, int toIndex) {
                return charactersOf(string.substring(fromIndex, toIndex));
            }

            @Override boolean isPartialView() {
                return false;
            }

            @Override public Character get(int index) {
                return string.charAt(index);
            }

            @Override public int size() {
                return string.length();
            }

            @Override public boolean equals(@Nullable Object obj) {
                if (!(obj instanceof List)) {
                    return false;
                }
                List<?> list = (List<?>) obj;
                int n = string.length();
                if (n != list.size()) {
                    return false;
                }
                Iterator<?> iterator = list.iterator();
                for (int i = 0; i < n; i++) {
                    Object elem = iterator.next();
                    if (!(elem instanceof Character)
                            || ((Character) elem).charValue() != string.charAt(i)) {
                        return false;
                    }
                }
                return true;
            }

            int hash = 0;

            @Override
            public int hashCode() {
                int h = hash;
                if (h == 0) {
                    h = 1;
                    for (int i = 0; i < string.length(); i++) {
                        h = h * 31 + string.charAt(i);
                    }
                    hash = h;
                }
                return h;
            }
        }
         public static List<Character> charactersOf(CharSequence sequence) {
            return new CharSequenceAsList(checkNotNull(sequence));
        }

        private static final class CharSequenceAsList
                extends AbstractList<Character> {
            private final CharSequence sequence;

            CharSequenceAsList(CharSequence sequence) {
                this.sequence = sequence;
            }

            @Override public Character get(int index) {
                return sequence.charAt(index);
            }

            @Override public boolean contains( Object o) {
                return indexOf(o) >= 0;
            }

            @Override public int indexOf(Object o) {
                if (o instanceof Character) {
                    char c = (Character) o;
                    for (int i = 0; i < sequence.length(); i++) {
                        if (sequence.charAt(i) == c) {
                            return i;
                        }
                    }
                }
                return -1;
            }

            @Override public int lastIndexOf( Object o) {
                if (o instanceof Character) {
                    char c = ((Character) o).charValue();
                    for (int i = sequence.length() - 1; i >= 0; i--) {
                        if (sequence.charAt(i) == c) {
                            return i;
                        }
                    }
                }
                return -1;
            }

            @Override public int size() {
                return sequence.length();
            }

            @Override public List<Character> subList(int fromIndex, int toIndex) {
                return charactersOf(sequence.subSequence(fromIndex, toIndex));
            }

            @Override public int hashCode() {
                int hash = 1;
                for (int i = 0; i < sequence.length(); i++) {
                    hash = hash * 31 + sequence.charAt(i);
                }
                return hash;
            }

            @Override public boolean equals( Object o) {
                if (!(o instanceof List)) {
                    return false;
                }
                List<?> list = (List<?>) o;
                int n = sequence.length();
                if (n != list.size()) {
                    return false;
                }
                Iterator<?> iterator = list.iterator();
                for (int i = 0; i < n; i++) {
                    Object elem = iterator.next();
                    if (!(elem instanceof Character)
                            || ((Character) elem).charValue() != sequence.charAt(i)) {
                        return false;
                    }
                }
                return true;
            }
        }

        public static <T> List<T> reverse(List<T> list) {
            if (list instanceof ReverseList) {
                return ((ReverseList<T>) list).getForwardList();
            } else if (list instanceof RandomAccess) {
                return new RandomAccessReverseList<T>(list);
            } else {
                return new ReverseList<T>(list);
            }
        }

        private static class ReverseList<T> extends AbstractList<T> {
            private final List<T> forwardList;

            ReverseList(List<T> forwardList) {
                this.forwardList = checkNotNull(forwardList);
            }

            List<T> getForwardList() {
                return forwardList;
            }

            private int reverseIndex(int index) {
                int size = size();
                checkElementIndex(index, size);
                return (size - 1) - index;
            }

            private int reversePosition(int index) {
                int size = size();
                checkPositionIndex(index, size);
                return size - index;
            }

            @Override public void add(int index,  T element) {
                forwardList.add(reversePosition(index), element);
            }

            @Override public void clear() {
                forwardList.clear();
            }

            @Override public T remove(int index) {
                return forwardList.remove(reverseIndex(index));
            }

            @Override protected void removeRange(int fromIndex, int toIndex) {
                subList(fromIndex, toIndex).clear();
            }

            @Override public T set(int index,  T element) {
                return forwardList.set(reverseIndex(index), element);
            }

            @Override public T get(int index) {
                return forwardList.get(reverseIndex(index));
            }

            @Override public boolean isEmpty() {
                return forwardList.isEmpty();
            }

            @Override public int size() {
                return forwardList.size();
            }

            @Override public boolean contains( Object o) {
                return forwardList.contains(o);
            }

            @Override public boolean containsAll(Collection<?> c) {
                return forwardList.containsAll(c);
            }

            @Override public List<T> subList(int fromIndex, int toIndex) {
                checkPositionIndexes(fromIndex, toIndex, size());
                return reverse(forwardList.subList(
                        reversePosition(toIndex), reversePosition(fromIndex)));
            }

            @Override public int indexOf( Object o) {
                int index = forwardList.lastIndexOf(o);
                return (index >= 0) ? reverseIndex(index) : -1;
            }

            @Override public int lastIndexOf( Object o) {
                int index = forwardList.indexOf(o);
                return (index >= 0) ? reverseIndex(index) : -1;
            }

            @Override public Iterator<T> iterator() {
                return listIterator();
            }

            @Override public ListIterator<T> listIterator(int index) {
                int start = reversePosition(index);
                final ListIterator<T> forwardIterator = forwardList.listIterator(start);
                return new ListIterator<T>() {

                    boolean canRemove;
                    boolean canSet;

                    @Override public void add(T e) {
                        forwardIterator.add(e);
                        forwardIterator.previous();
                        canSet = canRemove = false;
                    }

                    @Override public boolean hasNext() {
                        return forwardIterator.hasPrevious();
                    }

                    @Override public boolean hasPrevious() {
                        return forwardIterator.hasNext();
                    }

                    @Override public T next() {
                        if (!hasNext()) {
                            throw new NoSuchElementException();
                        }
                        canSet = canRemove = true;
                        return forwardIterator.previous();
                    }

                    @Override public int nextIndex() {
                        return reversePosition(forwardIterator.nextIndex());
                    }

                    @Override public T previous() {
                        if (!hasPrevious()) {
                            throw new NoSuchElementException();
                        }
                        canSet = canRemove = true;
                        return forwardIterator.next();
                    }

                    @Override public int previousIndex() {
                        return nextIndex() - 1;
                    }

                    @Override public void remove() {
                        checkState(canRemove);
                        forwardIterator.remove();
                        canRemove = canSet = false;
                    }

                    @Override public void set(T e) {
                        checkState(canSet);
                        forwardIterator.set(e);
                    }
                };
            }
        }

        private static class RandomAccessReverseList<T> extends ReverseList<T>
                implements RandomAccess {
            RandomAccessReverseList(List<T> forwardList) {
                super(forwardList);
            }
        }

        static int hashCodeImpl(List<?> list){
            int hashCode = 1;
            for (Object o : list) {
                hashCode = 31 * hashCode + (o == null ? 0 : o.hashCode());
            }
            return hashCode;
        }

        static boolean equalsImpl(List<?> list, Object object) {
            if (object == checkNotNull(list)) {
                return true;
            }
            if (!(object instanceof List)) {
                return false;
            }

            List<?> o = (List<?>) object;

            return list.size() == o.size()
                    && Iterators.elementsEqual(list.iterator(), o.iterator());
        }

        static <E> boolean addAllImpl(
                List<E> list, int index, Iterable<? extends E> elements) {
            boolean changed = false;
            ListIterator<E> listIterator = list.listIterator(index);
            for (E e : elements) {
                listIterator.add(e);
                changed = true;
            }
            return changed;
        }

        static int indexOfImpl(List<?> list, @Nullable Object element){
            ListIterator<?> listIterator = list.listIterator();
            while (listIterator.hasNext()) {
                if (Objects.equal(element, listIterator.next())) {
                    return listIterator.previousIndex();
                }
            }
            return -1;
        }

        static int lastIndexOfImpl(List<?> list, Object element){
            ListIterator<?> listIterator = list.listIterator(list.size());
            while (listIterator.hasPrevious()) {
                if (Objects.equal(element, listIterator.previous())) {
                    return listIterator.nextIndex();
                }
            }
            return -1;
        }

        static <E> ListIterator<E> listIteratorImpl(List<E> list, int index) {
            return new AbstractListWrapper<E>(list).listIterator(index);
        }

        static <E> List<E> subListImpl(
                final List<E> list, int fromIndex, int toIndex) {
            List<E> wrapper;
            if (list instanceof RandomAccess) {
                wrapper = new RandomAccessListWrapper<E>(list) {
                    @Override public ListIterator<E> listIterator(int index) {
                        return backingList.listIterator(index);
                    }

                    private static final long serialVersionUID = 0;
                };
            } else {
                wrapper = new AbstractListWrapper<E>(list) {
                    @Override public ListIterator<E> listIterator(int index) {
                        return backingList.listIterator(index);
                    }

                    private static final long serialVersionUID = 0;
                };
            }
            return wrapper.subList(fromIndex, toIndex);
        }

        private static class AbstractListWrapper<E> extends AbstractList<E> {
            final List<E> backingList;

            AbstractListWrapper(List<E> backingList) {
                this.backingList = checkNotNull(backingList);
            }

            @Override public void add(int index, E element) {
                backingList.add(index, element);
            }

            @Override public boolean addAll(int index, Collection<? extends E> c) {
                return backingList.addAll(index, c);
            }

            @Override public E get(int index) {
                return backingList.get(index);
            }

            @Override public E remove(int index) {
                return backingList.remove(index);
            }

            @Override public E set(int index, E element) {
                return backingList.set(index, element);
            }

            @Override public boolean contains(Object o) {
                return backingList.contains(o);
            }

            @Override public int size() {
                return backingList.size();
            }
        }

        private static class RandomAccessListWrapper<E>
                extends AbstractListWrapper<E> implements RandomAccess {
            RandomAccessListWrapper(List<E> backingList) {
                super(backingList);
            }
        }
    }

    public static final class RefreshHelper implements Refreshable {

        private static final Logger log = LoggerFactory.getLogger(RefreshHelper.class);

        private final List<Refreshable> dependencies;
        private final ReentrantLock refreshLock;
        private final Callable<?> refreshRunnable;

        public RefreshHelper(Callable<?> refreshRunnable) {
            this.dependencies = Lists.newArrayListWithCapacity(3);
            this.refreshLock = new ReentrantLock();
            this.refreshRunnable = refreshRunnable;
        }

        public void addDependency(Refreshable refreshable) {
            if (refreshable != null) {
                dependencies.add(refreshable);
            }
        }

        public void removeDependency(Refreshable refreshable) {
            if (refreshable != null) {
                dependencies.remove(refreshable);
            }
        }

        @Override
        public void refresh(Collection<Refreshable> alreadyRefreshed) {
            if (refreshLock.tryLock()) {
                try {
                    alreadyRefreshed = buildRefreshed(alreadyRefreshed);
                    for (Refreshable dependency : dependencies) {
                        maybeRefresh(alreadyRefreshed, dependency);
                    }
                    if (refreshRunnable != null) {
                        try {
                            refreshRunnable.call();
                        } catch (Exception e) {
                            log.warn("Unexpected exception while refreshing", e);
                        }
                    }
                } finally {
                    refreshLock.unlock();
                }
            }
        }

        public static Collection<Refreshable> buildRefreshed(Collection<Refreshable> currentAlreadyRefreshed) {
            return currentAlreadyRefreshed == null ? new HashSet<Refreshable>(3) : currentAlreadyRefreshed;
        }

        public static void maybeRefresh(Collection<Refreshable> alreadyRefreshed, Refreshable refreshable) {
            if (!alreadyRefreshed.contains(refreshable)) {
                alreadyRefreshed.add(refreshable);
                log.info("Added refreshable: {}", refreshable);
                refreshable.refresh(alreadyRefreshed);
                log.info("Refreshed: {}", alreadyRefreshed);
            }
        }
    }
     /*
    public static class GenericUserBasedRecommender extends AbstractRecommender implements UserBasedRecommender {

        private static final Logger log = LoggerFactory.getLogger(GenericUserBasedRecommender.class);

        private final UserNeighborhood neighborhood;
        private final UserSimilarity similarity;
        private final RefreshHelper refreshHelper;
        private EstimatedPreferenceCapper capper;

        public GenericUserBasedRecommender(DataModel dataModel,
                                           UserNeighborhood neighborhood,
                                           UserSimilarity similarity) {
            super(dataModel);
            checkArgument(neighborhood != null, "neighborhood is null");
            this.neighborhood = neighborhood;
            this.similarity = similarity;
            this.refreshHelper = new RefreshHelper(new Callable<Void>() {
                @Override
                public Void call() {
                    capper = buildCapper();
                    return null;
                }
            });
            refreshHelper.addDependency(dataModel);
            refreshHelper.addDependency(similarity);
            refreshHelper.addDependency(neighborhood);
            capper = buildCapper();
        }

        public UserSimilarity getSimilarity() {
            return similarity;
        }

        @Override
        public List<RecommendedItem> recommend(long userID, int howMany, IDRescorer rescorer) throws TasteException {
            checkArgument(howMany >= 1, "howMany must be at least 1");

            log.debug("Recommending items for user ID '{}'", userID);

            long[] theNeighborhood = neighborhood.getUserNeighborhood(userID);

            if (theNeighborhood.length == 0) {
                return Collections.emptyList();
            }

            FastIDSet allItemIDs = getAllOtherItems(theNeighborhood, userID);

            TopItems.Estimator<Long> estimator = new Estimator(userID, theNeighborhood);

            List<RecommendedItem> topItems = TopItems
                    .getTopItems(howMany, allItemIDs.iterator(), rescorer, estimator);

            log.debug("Recommendations are: {}", topItems);
            return topItems;
        }

        @Override
        public float estimatePreference(long userID, long itemID) throws TasteException {
            DataModel model = getDataModel();
            Float actualPref = model.getPreferenceValue(userID, itemID);
            if (actualPref != null) {
                return actualPref;
            }
            long[] theNeighborhood = neighborhood.getUserNeighborhood(userID);
            return doEstimatePreference(userID, theNeighborhood, itemID);
        }

        @Override
        public long[] mostSimilarUserIDs(long userID, int howMany) throws TasteException {
            return mostSimilarUserIDs(userID, howMany, null);
        }

        @Override
        public long[] mostSimilarUserIDs(long userID, int howMany, Rescorer<LongPair> rescorer) throws TasteException {
            TopItems.Estimator<Long> estimator = new MostSimilarEstimator(userID, similarity, rescorer);
            return doMostSimilarUsers(howMany, estimator);
        }

        private long[] doMostSimilarUsers(int howMany, TopItems.Estimator<Long> estimator) throws TasteException {
            DataModel model = getDataModel();
            return TopItems.getTopUsers(howMany, model.getUserIDs(), null, estimator);
        }

        protected float doEstimatePreference(long theUserID, long[] theNeighborhood, long itemID) throws TasteException {
            if (theNeighborhood.length == 0) {
                return Float.NaN;
            }
            DataModel dataModel = getDataModel();
            double preference = 0.0;
            double totalSimilarity = 0.0;
            int count = 0;
            for (long userID : theNeighborhood) {
                if (userID != theUserID) {
                    // See GenericItemBasedRecommender.doEstimatePreference() too
                    Float pref = dataModel.getPreferenceValue(userID, itemID);
                    if (pref != null) {
                        double theSimilarity = similarity.userSimilarity(theUserID, userID);
                        if (!Double.isNaN(theSimilarity)) {
                            preference += theSimilarity * pref;
                            totalSimilarity += theSimilarity;
                            count++;
                        }
                    }
                }
            }
            // Throw out the estimate if it was based on no data points, of course, but also if based on
            // just one. This is a bit of a band-aid on the 'stock' item-based algorithm for the moment.
            // The reason is that in this case the estimate is, simply, the user's rating for one item
            // that happened to have a defined similarity. The similarity score doesn't matter, and that
            // seems like a bad situation.
            if (count <= 1) {
                return Float.NaN;
            }
            float estimate = (float) (preference / totalSimilarity);
            if (capper != null) {
                estimate = capper.capEstimate(estimate);
            }
            return estimate;
        }

        protected FastIDSet getAllOtherItems(long[] theNeighborhood, long theUserID) throws TasteException {
            DataModel dataModel = getDataModel();
            FastIDSet possibleItemIDs = new FastIDSet();
            for (long userID : theNeighborhood) {
                possibleItemIDs.addAll(dataModel.getItemIDsFromUser(userID));
            }
            possibleItemIDs.removeAll(dataModel.getItemIDsFromUser(theUserID));
            return possibleItemIDs;
        }

        @Override
        public void refresh(Collection<Refreshable> alreadyRefreshed) {
            refreshHelper.refresh(alreadyRefreshed);
        }

        @Override
        public String toString() {
            return "GenericUserBasedRecommender[neighborhood:" + neighborhood + ']';
        }

        private EstimatedPreferenceCapper buildCapper() {
            DataModel dataModel = getDataModel();
            if (Float.isNaN(dataModel.getMinPreference()) && Float.isNaN(dataModel.getMaxPreference())) {
                return null;
            } else {
                return new EstimatedPreferenceCapper(dataModel);
            }
        }

        private static final class MostSimilarEstimator implements TopItems.Estimator<Long> {

            private final long toUserID;
            private final UserSimilarity similarity;
            private final Rescorer<LongPair> rescorer;

            private MostSimilarEstimator(long toUserID, UserSimilarity similarity, Rescorer<LongPair> rescorer) {
                this.toUserID = toUserID;
                this.similarity = similarity;
                this.rescorer = rescorer;
            }

            @Override
            public double estimate(Long userID) throws TasteException {
                // Don't consider the user itself as a possible most similar user
                if (userID == toUserID) {
                    return Double.NaN;
                }
                if (rescorer == null) {
                    return similarity.userSimilarity(toUserID, userID);
                } else {
                    LongPair pair = new LongPair(toUserID, userID);
                    if (rescorer.isFiltered(pair)) {
                        return Double.NaN;
                    }
                    double originalEstimate = similarity.userSimilarity(toUserID, userID);
                    return rescorer.rescore(pair, originalEstimate);
                }
            }
        }

        private final class Estimator implements TopItems.Estimator<Long> {

            private final long theUserID;
            private final long[] theNeighborhood;

            Estimator(long theUserID, long[] theNeighborhood) {
                this.theUserID = theUserID;
                this.theNeighborhood = theNeighborhood;
            }

            @Override
            public double estimate(Long itemID) throws TasteException {
                return doEstimatePreference(theUserID, theNeighborhood, itemID);
            }
        }
    }
             */

}
